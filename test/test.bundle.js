/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./test/test.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/moo/moo.js":
/*!*********************************!*\
  !*** ./node_modules/moo/moo.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(root, factory) {\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) /* global define */\n  } else {}\n}(this, function() {\n  'use strict';\n\n  var hasOwnProperty = Object.prototype.hasOwnProperty\n\n  // polyfill assign(), so we support IE9+\n  var assign = typeof Object.assign === 'function' ? Object.assign :\n    // https://tc39.github.io/ecma262/#sec-object.assign\n    function(target, sources) {\n      if (target == null) {\n        throw new TypeError('Target cannot be null or undefined');\n      }\n      target = Object(target)\n\n      for (var i = 1; i < arguments.length; i++) {\n        var source = arguments[i]\n        if (source == null) continue\n\n        for (var key in source) {\n          if (hasOwnProperty.call(source, key)) {\n            target[key] = source[key]\n          }\n        }\n      }\n      return target\n    }\n\n  var hasSticky = typeof new RegExp().sticky === 'boolean'\n\n  /***************************************************************************/\n\n  function isRegExp(o) { return o && o.constructor === RegExp }\n  function isObject(o) { return o && typeof o === 'object' && o.constructor !== RegExp && !Array.isArray(o) }\n\n  function reEscape(s) {\n    return s.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&')\n  }\n  function reGroups(s) {\n    var re = new RegExp('|' + s)\n    return re.exec('').length - 1\n  }\n  function reCapture(s) {\n    return '(' + s + ')'\n  }\n  function reUnion(regexps) {\n    var source =  regexps.map(function(s) {\n      return \"(?:\" + s + \")\"\n    }).join('|')\n    return \"(?:\" + source + \")\"\n  }\n\n  function regexpOrLiteral(obj) {\n    if (typeof obj === 'string') {\n      return '(?:' + reEscape(obj) + ')'\n\n    } else if (isRegExp(obj)) {\n      // TODO: consider /u support\n      if (obj.ignoreCase) { throw new Error('RegExp /i flag not allowed') }\n      if (obj.global) { throw new Error('RegExp /g flag is implied') }\n      if (obj.sticky) { throw new Error('RegExp /y flag is implied') }\n      if (obj.multiline) { throw new Error('RegExp /m flag is implied') }\n      return obj.source\n\n    } else {\n      throw new Error('not a pattern: ' + obj)\n    }\n  }\n\n  function objectToRules(object) {\n    var keys = Object.getOwnPropertyNames(object)\n    var result = []\n    for (var i=0; i<keys.length; i++) {\n      var key = keys[i]\n      var thing = object[key]\n      var rules = Array.isArray(thing) ? thing : [thing]\n      var match = []\n      rules.forEach(function(rule) {\n        if (isObject(rule)) {\n          if (match.length) result.push(ruleOptions(key, match))\n          result.push(ruleOptions(key, rule))\n          match = []\n        } else {\n          match.push(rule)\n        }\n      })\n      if (match.length) result.push(ruleOptions(key, match))\n    }\n    return result\n  }\n\n  function arrayToRules(array) {\n    var result = []\n    for (var i=0; i<array.length; i++) {\n      var obj = array[i]\n      if (!obj.name) {\n        throw new Error('Rule has no name: ' + JSON.stringify(obj))\n      }\n      result.push(ruleOptions(obj.name, obj))\n    }\n    return result\n  }\n\n  function ruleOptions(name, obj) {\n    if (typeof obj !== 'object' || Array.isArray(obj) || isRegExp(obj)) {\n      obj = { match: obj }\n    }\n\n    // nb. error implies lineBreaks\n    var options = assign({\n      tokenType: name,\n      lineBreaks: !!obj.error,\n      pop: false,\n      next: null,\n      push: null,\n      error: false,\n      value: null,\n      getType: null,\n    }, obj)\n\n    // convert to array\n    var match = options.match\n    options.match = Array.isArray(match) ? match : match ? [match] : []\n    options.match.sort(function(a, b) {\n      return isRegExp(a) && isRegExp(b) ? 0\n           : isRegExp(b) ? -1 : isRegExp(a) ? +1 : b.length - a.length\n    })\n    if (options.keywords) {\n      options.getType = keywordTransform(options.keywords)\n    }\n    return options\n  }\n\n  function compileRules(rules, hasStates) {\n    rules = Array.isArray(rules) ? arrayToRules(rules) : objectToRules(rules)\n\n    var errorRule = null\n    var groups = []\n    var parts = []\n    for (var i=0; i<rules.length; i++) {\n      var options = rules[i]\n\n      if (options.error) {\n        if (errorRule) {\n          throw new Error(\"Multiple error rules not allowed: (for token '\" + options.tokenType + \"')\")\n        }\n        errorRule = options\n      }\n\n      // skip rules with no match\n      if (options.match.length === 0) {\n        continue\n      }\n      groups.push(options)\n\n      // convert to RegExp\n      var pat = reUnion(options.match.map(regexpOrLiteral))\n\n      // validate\n      var regexp = new RegExp(pat)\n      if (regexp.test(\"\")) {\n        throw new Error(\"RegExp matches empty string: \" + regexp)\n      }\n      var groupCount = reGroups(pat)\n      if (groupCount > 0) {\n        throw new Error(\"RegExp has capture groups: \" + regexp + \"\\nUse (?: … ) instead\")\n      }\n      if (!hasStates && (options.pop || options.push || options.next)) {\n        throw new Error(\"State-switching options are not allowed in stateless lexers (for token '\" + options.tokenType + \"')\")\n      }\n\n      // try and detect rules matching newlines\n      if (!options.lineBreaks && regexp.test('\\n')) {\n        throw new Error('Rule should declare lineBreaks: ' + regexp)\n      }\n\n      // store regex\n      parts.push(reCapture(pat))\n    }\n\n    var suffix = hasSticky ? '' : '|(?:)'\n    var flags = hasSticky ? 'ym' : 'gm'\n    var combined = new RegExp(reUnion(parts) + suffix, flags)\n\n    return {regexp: combined, groups: groups, error: errorRule}\n  }\n\n  function compile(rules) {\n    var result = compileRules(rules)\n    return new Lexer({start: result}, 'start')\n  }\n\n  function compileStates(states, start) {\n    var keys = Object.getOwnPropertyNames(states)\n    if (!start) start = keys[0]\n\n    var map = Object.create(null)\n    for (var i=0; i<keys.length; i++) {\n      var key = keys[i]\n      map[key] = compileRules(states[key], true)\n    }\n\n    for (var i=0; i<keys.length; i++) {\n      var groups = map[keys[i]].groups\n      for (var j=0; j<groups.length; j++) {\n        var g = groups[j]\n        var state = g && (g.push || g.next)\n        if (state && !map[state]) {\n          throw new Error(\"Missing state '\" + state + \"' (in token '\" + g.tokenType + \"' of state '\" + keys[i] + \"')\")\n        }\n        if (g && g.pop && +g.pop !== 1) {\n          throw new Error(\"pop must be 1 (in token '\" + g.tokenType + \"' of state '\" + keys[i] + \"')\")\n        }\n      }\n    }\n\n    return new Lexer(map, start)\n  }\n\n  function keywordTransform(map) {\n    var reverseMap = Object.create(null)\n    var byLength = Object.create(null)\n    var types = Object.getOwnPropertyNames(map)\n    for (var i=0; i<types.length; i++) {\n      var tokenType = types[i]\n      var item = map[tokenType]\n      var keywordList = Array.isArray(item) ? item : [item]\n      keywordList.forEach(function(keyword) {\n        (byLength[keyword.length] = byLength[keyword.length] || []).push(keyword)\n        if (typeof keyword !== 'string') {\n          throw new Error(\"keyword must be string (in keyword '\" + tokenType + \"')\")\n        }\n        reverseMap[keyword] = tokenType\n      })\n    }\n\n    // fast string lookup\n    // https://jsperf.com/string-lookups\n    function str(x) { return JSON.stringify(x) }\n    var source = ''\n    source += '(function(value) {\\n'\n    source += 'switch (value.length) {\\n'\n    for (var length in byLength) {\n      var keywords = byLength[length]\n      source += 'case ' + length + ':\\n'\n      source += 'switch (value) {\\n'\n      keywords.forEach(function(keyword) {\n        var tokenType = reverseMap[keyword]\n        source += 'case ' + str(keyword) + ': return ' + str(tokenType) + '\\n'\n      })\n      source += '}\\n'\n    }\n    source += '}\\n'\n    source += '})'\n    return eval(source) // getType\n  }\n\n  /***************************************************************************/\n\n  var Lexer = function(states, state) {\n    this.startState = state\n    this.states = states\n    this.buffer = ''\n    this.stack = []\n    this.reset()\n  }\n\n  Lexer.prototype.reset = function(data, info) {\n    this.buffer = data || ''\n    this.index = 0\n    this.line = info ? info.line : 1\n    this.col = info ? info.col : 1\n    this.setState(info ? info.state : this.startState)\n    return this\n  }\n\n  Lexer.prototype.save = function() {\n    return {\n      line: this.line,\n      col: this.col,\n      state: this.state,\n    }\n  }\n\n  Lexer.prototype.setState = function(state) {\n    if (!state || this.state === state) return\n    this.state = state\n    var info = this.states[state]\n    this.groups = info.groups\n    this.error = info.error || {lineBreaks: true, shouldThrow: true}\n    this.re = info.regexp\n  }\n\n  Lexer.prototype.popState = function() {\n    this.setState(this.stack.pop())\n  }\n\n  Lexer.prototype.pushState = function(state) {\n    this.stack.push(this.state)\n    this.setState(state)\n  }\n\n  Lexer.prototype._eat = hasSticky ? function(re) { // assume re is /y\n    return re.exec(this.buffer)\n  } : function(re) { // assume re is /g\n    var match = re.exec(this.buffer)\n    // will always match, since we used the |(?:) trick\n    if (match[0].length === 0) {\n      return null\n    }\n    return match\n  }\n\n  Lexer.prototype._getGroup = function(match) {\n    if (match === null) {\n      return -1\n    }\n\n    var groupCount = this.groups.length\n    for (var i = 0; i < groupCount; i++) {\n      if (match[i + 1] !== undefined) {\n        return i\n      }\n    }\n    throw new Error('oops')\n  }\n\n  function tokenToString() {\n    return this.value\n  }\n\n  Lexer.prototype.next = function() {\n    var re = this.re\n    var buffer = this.buffer\n\n    var index = re.lastIndex = this.index\n    if (index === buffer.length) {\n      return // EOF\n    }\n\n    var match = this._eat(re)\n    var i = this._getGroup(match)\n\n    var group, text\n    if (i === -1) {\n      group = this.error\n\n      // consume rest of buffer\n      text = buffer.slice(index)\n\n    } else {\n      text = match[0]\n      group = this.groups[i]\n    }\n\n    // count line breaks\n    var lineBreaks = 0\n    if (group.lineBreaks) {\n      var matchNL = /\\n/g\n      var nl = 1\n      if (text === '\\n') {\n        lineBreaks = 1\n      } else {\n        while (matchNL.exec(text)) { lineBreaks++; nl = matchNL.lastIndex }\n      }\n    }\n\n    var token = {\n      type: (group.getType && group.getType(text)) || group.tokenType,\n      value: group.value ? group.value(text) : text,\n      text: text,\n      toString: tokenToString,\n      offset: index,\n      lineBreaks: lineBreaks,\n      line: this.line,\n      col: this.col,\n    }\n    // nb. adding more props to token object will make V8 sad!\n\n    var size = text.length\n    this.index += size\n    this.line += lineBreaks\n    if (lineBreaks !== 0) {\n      this.col = size - nl + 1\n    } else {\n      this.col += size\n    }\n    // throw, if no rule with {error: true}\n    if (group.shouldThrow) {\n      throw new Error(this.formatError(token, \"invalid syntax\"))\n    }\n\n    if (group.pop) this.popState()\n    else if (group.push) this.pushState(group.push)\n    else if (group.next) this.setState(group.next)\n    return token\n  }\n\n  if (typeof Symbol !== 'undefined' && Symbol.iterator) {\n    var LexerIterator = function(lexer) {\n      this.lexer = lexer\n    }\n\n    LexerIterator.prototype.next = function() {\n      var token = this.lexer.next()\n      return {value: token, done: !token}\n    }\n\n    LexerIterator.prototype[Symbol.iterator] = function() {\n      return this\n    }\n\n    Lexer.prototype[Symbol.iterator] = function() {\n      return new LexerIterator(this)\n    }\n  }\n\n  Lexer.prototype.formatError = function(token, message) {\n    var value = token.value\n    var index = token.offset\n    var eol = token.lineBreaks ? value.indexOf('\\n') : value.length\n    var start = Math.max(0, index - token.col + 1)\n    var firstLine = this.buffer.substring(start, index + eol)\n    message += \" at line \" + token.line + \" col \" + token.col + \":\\n\\n\"\n    message += \"  \" + firstLine + \"\\n\"\n    message += \"  \" + Array(token.col).join(\" \") + \"^\"\n    return message\n  }\n\n  Lexer.prototype.clone = function() {\n    return new Lexer(this.states, this.state)\n  }\n\n  Lexer.prototype.has = function(tokenType) {\n    for (var s in this.states) {\n      var groups = this.states[s].groups\n      for (var i=0; i<groups.length; i++) {\n        var group = groups[i]\n        if (group.tokenType === tokenType) return true\n        if (group.keywords && hasOwnProperty.call(group.keywords, tokenType)) {\n          return true\n        }\n      }\n    }\n    return false\n  }\n\n\n  return {\n    compile: compile,\n    states: compileStates,\n    error: Object.freeze({error: true}),\n  }\n\n}))\n\n\n//# sourceURL=webpack:///./node_modules/moo/moo.js?");

/***/ }),

/***/ "./node_modules/nearley/lib/nearley.js":
/*!*********************************************!*\
  !*** ./node_modules/nearley/lib/nearley.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("(function(root, factory) {\n    if (typeof module === 'object' && module.exports) {\n        module.exports = factory();\n    } else {\n        root.nearley = factory();\n    }\n}(this, function() {\n\n    function Rule(name, symbols, postprocess) {\n        this.id = ++Rule.highestId;\n        this.name = name;\n        this.symbols = symbols;        // a list of literal | regex class | nonterminal\n        this.postprocess = postprocess;\n        return this;\n    }\n    Rule.highestId = 0;\n\n    Rule.prototype.toString = function(withCursorAt) {\n        function stringifySymbolSequence (e) {\n            return e.literal ? JSON.stringify(e.literal) :\n                   e.type ? '%' + e.type : e.toString();\n        }\n        var symbolSequence = (typeof withCursorAt === \"undefined\")\n                             ? this.symbols.map(stringifySymbolSequence).join(' ')\n                             : (   this.symbols.slice(0, withCursorAt).map(stringifySymbolSequence).join(' ')\n                                 + \" ● \"\n                                 + this.symbols.slice(withCursorAt).map(stringifySymbolSequence).join(' ')     );\n        return this.name + \" → \" + symbolSequence;\n    }\n\n\n    // a State is a rule at a position from a given starting point in the input stream (reference)\n    function State(rule, dot, reference, wantedBy) {\n        this.rule = rule;\n        this.dot = dot;\n        this.reference = reference;\n        this.data = [];\n        this.wantedBy = wantedBy;\n        this.isComplete = this.dot === rule.symbols.length;\n    }\n\n    State.prototype.toString = function() {\n        return \"{\" + this.rule.toString(this.dot) + \"}, from: \" + (this.reference || 0);\n    };\n\n    State.prototype.nextState = function(child) {\n        var state = new State(this.rule, this.dot + 1, this.reference, this.wantedBy);\n        state.left = this;\n        state.right = child;\n        if (state.isComplete) {\n            state.data = state.build();\n        }\n        return state;\n    };\n\n    State.prototype.build = function() {\n        var children = [];\n        var node = this;\n        do {\n            children.push(node.right.data);\n            node = node.left;\n        } while (node.left);\n        children.reverse();\n        return children;\n    };\n\n    State.prototype.finish = function() {\n        if (this.rule.postprocess) {\n            this.data = this.rule.postprocess(this.data, this.reference, Parser.fail);\n        }\n    };\n\n\n    function Column(grammar, index) {\n        this.grammar = grammar;\n        this.index = index;\n        this.states = [];\n        this.wants = {}; // states indexed by the non-terminal they expect\n        this.scannable = []; // list of states that expect a token\n        this.completed = {}; // states that are nullable\n    }\n\n\n    Column.prototype.process = function(nextColumn) {\n        var states = this.states;\n        var wants = this.wants;\n        var completed = this.completed;\n\n        for (var w = 0; w < states.length; w++) { // nb. we push() during iteration\n            var state = states[w];\n\n            if (state.isComplete) {\n                state.finish();\n                if (state.data !== Parser.fail) {\n                    // complete\n                    var wantedBy = state.wantedBy;\n                    for (var i = wantedBy.length; i--; ) { // this line is hot\n                        var left = wantedBy[i];\n                        this.complete(left, state);\n                    }\n\n                    // special-case nullables\n                    if (state.reference === this.index) {\n                        // make sure future predictors of this rule get completed.\n                        var exp = state.rule.name;\n                        (this.completed[exp] = this.completed[exp] || []).push(state);\n                    }\n                }\n\n            } else {\n                // queue scannable states\n                var exp = state.rule.symbols[state.dot];\n                if (typeof exp !== 'string') {\n                    this.scannable.push(state);\n                    continue;\n                }\n\n                // predict\n                if (wants[exp]) {\n                    wants[exp].push(state);\n\n                    if (completed.hasOwnProperty(exp)) {\n                        var nulls = completed[exp];\n                        for (var i = 0; i < nulls.length; i++) {\n                            var right = nulls[i];\n                            this.complete(state, right);\n                        }\n                    }\n                } else {\n                    wants[exp] = [state];\n                    this.predict(exp);\n                }\n            }\n        }\n    }\n\n    Column.prototype.predict = function(exp) {\n        var rules = this.grammar.byName[exp] || [];\n\n        for (var i = 0; i < rules.length; i++) {\n            var r = rules[i];\n            var wantedBy = this.wants[exp];\n            var s = new State(r, 0, this.index, wantedBy);\n            this.states.push(s);\n        }\n    }\n\n    Column.prototype.complete = function(left, right) {\n        var copy = left.nextState(right);\n        this.states.push(copy);\n    }\n\n\n    function Grammar(rules, start) {\n        this.rules = rules;\n        this.start = start || this.rules[0].name;\n        var byName = this.byName = {};\n        this.rules.forEach(function(rule) {\n            if (!byName.hasOwnProperty(rule.name)) {\n                byName[rule.name] = [];\n            }\n            byName[rule.name].push(rule);\n        });\n    }\n\n    // So we can allow passing (rules, start) directly to Parser for backwards compatibility\n    Grammar.fromCompiled = function(rules, start) {\n        var lexer = rules.Lexer;\n        if (rules.ParserStart) {\n          start = rules.ParserStart;\n          rules = rules.ParserRules;\n        }\n        var rules = rules.map(function (r) { return (new Rule(r.name, r.symbols, r.postprocess)); });\n        var g = new Grammar(rules, start);\n        g.lexer = lexer; // nb. storing lexer on Grammar is iffy, but unavoidable\n        return g;\n    }\n\n\n    function StreamLexer() {\n      this.reset(\"\");\n    }\n\n    StreamLexer.prototype.reset = function(data, state) {\n        this.buffer = data;\n        this.index = 0;\n        this.line = state ? state.line : 1;\n        this.lastLineBreak = state ? -state.col : 0;\n    }\n\n    StreamLexer.prototype.next = function() {\n        if (this.index < this.buffer.length) {\n            var ch = this.buffer[this.index++];\n            if (ch === '\\n') {\n              this.line += 1;\n              this.lastLineBreak = this.index;\n            }\n            return {value: ch};\n        }\n    }\n\n    StreamLexer.prototype.save = function() {\n      return {\n        line: this.line,\n        col: this.index - this.lastLineBreak,\n      }\n    }\n\n    StreamLexer.prototype.formatError = function(token, message) {\n        // nb. this gets called after consuming the offending token,\n        // so the culprit is index-1\n        var buffer = this.buffer;\n        if (typeof buffer === 'string') {\n            var nextLineBreak = buffer.indexOf('\\n', this.index);\n            if (nextLineBreak === -1) nextLineBreak = buffer.length;\n            var line = buffer.substring(this.lastLineBreak, nextLineBreak)\n            var col = this.index - this.lastLineBreak;\n            message += \" at line \" + this.line + \" col \" + col + \":\\n\\n\";\n            message += \"  \" + line + \"\\n\"\n            message += \"  \" + Array(col).join(\" \") + \"^\"\n            return message;\n        } else {\n            return message + \" at index \" + (this.index - 1);\n        }\n    }\n\n\n    function Parser(rules, start, options) {\n        if (rules instanceof Grammar) {\n            var grammar = rules;\n            var options = start;\n        } else {\n            var grammar = Grammar.fromCompiled(rules, start);\n        }\n        this.grammar = grammar;\n\n        // Read options\n        this.options = {\n            keepHistory: false,\n            lexer: grammar.lexer || new StreamLexer,\n        };\n        for (var key in (options || {})) {\n            this.options[key] = options[key];\n        }\n\n        // Setup lexer\n        this.lexer = this.options.lexer;\n        this.lexerState = undefined;\n\n        // Setup a table\n        var column = new Column(grammar, 0);\n        var table = this.table = [column];\n\n        // I could be expecting anything.\n        column.wants[grammar.start] = [];\n        column.predict(grammar.start);\n        // TODO what if start rule is nullable?\n        column.process();\n        this.current = 0; // token index\n    }\n\n    // create a reserved token for indicating a parse fail\n    Parser.fail = {};\n\n    Parser.prototype.feed = function(chunk) {\n        var lexer = this.lexer;\n        lexer.reset(chunk, this.lexerState);\n\n        var token;\n        while (token = lexer.next()) {\n            // We add new states to table[current+1]\n            var column = this.table[this.current];\n\n            // GC unused states\n            if (!this.options.keepHistory) {\n                delete this.table[this.current - 1];\n            }\n\n            var n = this.current + 1;\n            var nextColumn = new Column(this.grammar, n);\n            this.table.push(nextColumn);\n\n            // Advance all tokens that expect the symbol\n            var literal = token.value;\n            var value = lexer.constructor === StreamLexer ? token.value : token;\n            var scannable = column.scannable;\n            for (var w = scannable.length; w--; ) {\n                var state = scannable[w];\n                var expect = state.rule.symbols[state.dot];\n                // Try to consume the token\n                // either regex or literal\n                if (expect.test ? expect.test(value) :\n                    expect.type ? expect.type === token.type\n                                : expect.literal === literal) {\n                    // Add it\n                    var next = state.nextState({data: value, token: token, isToken: true, reference: n - 1});\n                    nextColumn.states.push(next);\n                }\n            }\n\n            // Next, for each of the rules, we either\n            // (a) complete it, and try to see if the reference row expected that\n            //     rule\n            // (b) predict the next nonterminal it expects by adding that\n            //     nonterminal's start state\n            // To prevent duplication, we also keep track of rules we have already\n            // added\n\n            nextColumn.process();\n\n            // If needed, throw an error:\n            if (nextColumn.states.length === 0) {\n                // No states at all! This is not good.\n                var message = this.lexer.formatError(token, \"invalid syntax\") + \"\\n\";\n                message += \"Unexpected \" + (token.type ? token.type + \" token: \" : \"\");\n                message += JSON.stringify(token.value !== undefined ? token.value : token) + \"\\n\";\n                var err = new Error(message);\n                err.offset = this.current;\n                err.token = token;\n                throw err;\n            }\n\n            // maybe save lexer state\n            if (this.options.keepHistory) {\n              column.lexerState = lexer.save()\n            }\n\n            this.current++;\n        }\n        if (column) {\n          this.lexerState = lexer.save()\n        }\n\n        // Incrementally keep track of results\n        this.results = this.finish();\n\n        // Allow chaining, for whatever it's worth\n        return this;\n    };\n\n    Parser.prototype.save = function() {\n        var column = this.table[this.current];\n        column.lexerState = this.lexerState;\n        return column;\n    };\n\n    Parser.prototype.restore = function(column) {\n        var index = column.index;\n        this.current = index;\n        this.table[index] = column;\n        this.table.splice(index + 1);\n        this.lexerState = column.lexerState;\n\n        // Incrementally keep track of results\n        this.results = this.finish();\n    };\n\n    // nb. deprecated: use save/restore instead!\n    Parser.prototype.rewind = function(index) {\n        if (!this.options.keepHistory) {\n            throw new Error('set option `keepHistory` to enable rewinding')\n        }\n        // nb. recall column (table) indicies fall between token indicies.\n        //        col 0   --   token 0   --   col 1\n        this.restore(this.table[index]);\n    };\n\n    Parser.prototype.finish = function() {\n        // Return the possible parsings\n        var considerations = [];\n        var start = this.grammar.start;\n        var column = this.table[this.table.length - 1]\n        column.states.forEach(function (t) {\n            if (t.rule.name === start\n                    && t.dot === t.rule.symbols.length\n                    && t.reference === 0\n                    && t.data !== Parser.fail) {\n                considerations.push(t);\n            }\n        });\n        return considerations.map(function(c) {return c.data; });\n    };\n\n    return {\n        Parser: Parser,\n        Grammar: Grammar,\n        Rule: Rule,\n    };\n\n}));\n\n\n//# sourceURL=webpack:///./node_modules/nearley/lib/nearley.js?");

/***/ }),

/***/ "./src/PlaybackStyle/PlaybackStyle.js":
/*!********************************************!*\
  !*** ./src/PlaybackStyle/PlaybackStyle.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return PlaybackStyle; });\n/* harmony import */ var _loader_loader_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../loader/loader.js */ \"./src/loader/loader.js\");\n/* harmony import */ var _parser_parser_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../parser/parser.js */ \"./src/parser/parser.js\");\n\n\n\nclass PlaybackStyle {\n  /**\n   * Set the main ast (the one that plays all its instruments by default).\n   * @param {ast.GlobalScope} main the main ast\n   * @param {Map.<string: ast.GlobalScope>} asts A map of asts by their path\n   */\n  constructor(mainPath) {\n    this._mainPath = mainPath;\n    this._ASTs = new Map();\n    // @TODO: generate a globals object that gets passed down the ast\n    // for throwing errors without using actual JS errors\n    // and letting GlobalScopes request instruments from deps\n    // and other things I'll think of later\n    // (do we need an ASTNode class that all nodes inherit from?)\n    this._loadDependencies();\n    // @TODO: complain when you try to play before loading is done\n  }\n  /**\n   * Parse each file, pull its dependencies, put it all in a cache, rinse and\n   * repeat.\n   * @private\n   */\n  async _loadDependencies() {\n    let pendingDependencies = [this._mainPath];\n    let dependencyPath;\n    // @TODO: verify that dependencies have compatible time signature to main\n    while(dependencyPath = pendingDependencies.pop()) {\n      let rawfile;\n      try {\n        rawfile = await _loader_loader_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].load(dependencyPath);\n      } catch(e) {\n        throw new Error(`Couldn't locate imported style \"${dependencyPath}\".`);\n      }\n      let ast = await _parser_parser_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].parse(rawfile);\n      this._ASTs.set(dependencyPath, ast);\n      ast.init();\n      console.log(dependencyPath, pendingDependencies);\n      for(let newDependency of ast.dependencies) {\n        if(!this._ASTs.has(newDependency)) {\n          pendingDependencies.push(newDependency);\n        }\n      }\n    }\n  }\n  async play(song) {\n    for(measure of song) {\n      let notes = this._main.execute(measure);\n      await player.play(notes); // ????????????????????\n    }\n  }\n}\n\n\n//# sourceURL=webpack:///./src/PlaybackStyle/PlaybackStyle.js?");

/***/ }),

/***/ "./src/ast/ArgumentOperators.js":
/*!**************************************!*\
  !*** ./src/ast/ArgumentOperators.js ***!
  \**************************************/
/*! exports provided: AnchorArgument, BooleanNot, BooleanAnd, BooleanOr */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AnchorArgument\", function() { return AnchorArgument; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BooleanNot\", function() { return BooleanNot; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BooleanAnd\", function() { return BooleanAnd; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BooleanOr\", function() { return BooleanOr; });\n/* harmony import */ var _type_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./type_utils.js */ \"./src/ast/type_utils.js\");\n\n\nclass AnchorArgument {\n  constructor(anchor) {\n    this.anchor = anchor;\n  }\n}\n\nclass BooleanOperator {\n  constructor() {\n    this.args = Array.prototype.slice.call(arguments);\n  }\n  init(scope) {\n    this.scope = scope\n    this.args.forEach(arg => {\n      if(arg.init) arg.init(scope);\n    });\n  }\n  resolve_args() {\n    return this.args.map(arg => {\n      if(arg.init) {\n        return arg.init();\n      } else {\n        return arg;\n      }\n    });\n  }\n}\n\nclass BooleanNot extends BooleanOperator {\n  constructor() {\n    super(arguments);\n  }\n  execute() {\n    let args = this.resolve_args();\n    return !Object(_type_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"cast_bool\"])(args[0]);\n  }\n}\nclass BooleanAnd extends BooleanOperator {\n  constructor() {\n    super(arguments);\n  }\n  execute() {\n    // sorry no short-circuiting because this code is prettier\n    // @TODO: add short-circuiting if this actually makes it too slow\n    let args = this.resolve_args();\n    return Object(_type_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"cast_bool\"])(args[0]) && Object(_type_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"cast_bool\"])(args[1]);\n  }\n}\nclass BooleanOr extends BooleanOperator {\n  constructor() {\n    super(arguments);\n  }\n  execute(arg) {\n    let args = this.resolve_args();\n    return Object(_type_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"cast_bool\"])(args[0]) || Object(_type_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"cast_bool\"])(args[1]);\n  }\n}\n\n\n//# sourceURL=webpack:///./src/ast/ArgumentOperators.js?");

/***/ }),

/***/ "./src/ast/BeatGroups.js":
/*!*******************************!*\
  !*** ./src/ast/BeatGroups.js ***!
  \*******************************/
/*! exports provided: BeatGroupLiteral, Measure, DrumBeatGroupLiteral */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BeatGroupLiteral\", function() { return BeatGroupLiteral; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Measure\", function() { return Measure; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DrumBeatGroupLiteral\", function() { return DrumBeatGroupLiteral; });\n/* harmony import */ var _FunctionCall_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./FunctionCall.js */ \"./src/ast/FunctionCall.js\");\n\n\nclass BeatGroupLiteral {\n  constructor(measures) {\n    this.measures = measures;\n  }\n  // @TODO for non-drums, make sure I'm not in a drum literal\n  // because of choose() I don't think this is possible 'till execution?\n}\n\nclass Measure {\n  constructor(beats) {\n    this.beats = beats;\n  }\n}\n\nclass DrumBeatGroupLiteral {\n  constructor(drum, beatGroup) {\n    this.drum = drum;\n    if(beatGroup instanceof _FunctionCall_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]) { // we were passed a function call (e.g. choose)\n      this.beatGroup = beatGroup; // for now there's no diff in functionality...\n    } else {\n      this.beatGroup = beatGroup;\n    }\n    // @TODO make sure our beats are all drummy\n  }\n}\n\n\n//# sourceURL=webpack:///./src/ast/BeatGroups.js?");

/***/ }),

/***/ "./src/ast/ConfigStatements.js":
/*!*************************************!*\
  !*** ./src/ast/ConfigStatements.js ***!
  \*************************************/
/*! exports provided: MetaStatement, OptionsStatement, ImportStatement */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MetaStatement\", function() { return MetaStatement; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"OptionsStatement\", function() { return OptionsStatement; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ImportStatement\", function() { return ImportStatement; });\n/* harmony import */ var _Scope_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Scope.js */ \"./src/ast/Scope.js\");\n\n\nclass MetaStatement extends _Scope_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n  constructor(function_calls) {\n    super();\n    this.name = '@meta';\n    this.type = '@meta';\n    this.function_calls = function_calls;\n  }\n  init(scope) {\n    this.scope = scope;\n    \n    // nothing in here can be dynamic so resolve these at compile time\n    for(let function_call of this.function_calls) {\n      function_call.init(this);\n      function_call.execute();\n    }\n    \n    scope.meta = this.vars;\n  }\n}\n\nclass OptionsStatement extends _Scope_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n  constructor(function_calls) {\n    super();\n    this.name = '@options';\n    this.type = '@options';\n    this.function_calls = function_calls;\n  }\n  init(scope) {\n    \n    // nothing in here /should/ be dynamic so resolve these at compile time\n    for(let function_call of this.function_calls) {\n      function_call.init(this);\n      function_call.execute();\n    }\n    \n    this.scope = scope;\n    // in this case we're actually overwriting our scope's variables, not\n    // vise-versa\n    scope.vars = new Map([...scope.vars, ...this.vars]);\n  }\n}\n\nclass ImportStatement {\n  constructor(path, identifier) {\n    this.path = path;\n    this.identifier = identifier;\n  }\n}\n\n\n//# sourceURL=webpack:///./src/ast/ConfigStatements.js?");

/***/ }),

/***/ "./src/ast/FunctionCall.js":
/*!*********************************!*\
  !*** ./src/ast/FunctionCall.js ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return FunctionCall; });\n/* harmony import */ var _function_data_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./function_data.js */ \"./src/ast/function_data.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./errors.js */ \"./src/ast/errors.js\");\n\n\n\n/**\n * If the value is a FunctionCall, call it and return the returned value.\n * Otherwise, return the value itself.\n * @private\n */ // @TODO: if this is needed elsewhere, put it somewhere useful.\n\nclass FunctionCall {\n  /**\n   * @constructor\n   * @param {string} identifier The name of the function. Ideally it should\n   * match the name of one of the functions in function_data.js\n   */\n  constructor(identifier, args) {\n    this.identifier = identifier;\n    this.definition = _function_data_js__WEBPACK_IMPORTED_MODULE_0__[\"definitions\"].get(identifier);\n    this.args = args;\n    this.scope = null;\n  }\n  init(scope) {\n    this.scope = scope;\n    if(!this.definition) {\n      throw new _errors_js__WEBPACK_IMPORTED_MODULE_1__[\"FunctionNameError\"](this.identifier, this.scope);\n    }\n    this.returns = this.definition.returns;\n    _function_data_js__WEBPACK_IMPORTED_MODULE_0__[\"assertScope\"](this.identifier, this.definition.scope, this.scope);\n    \n    this.args.forEach(arg => {\n      if(arg.init) arg.init(scope);\n    });\n    \n    _function_data_js__WEBPACK_IMPORTED_MODULE_0__[\"assertArgTypes\"](this.identifier, this.args, this.definition.types, this.scope);\n  }\n  execute() { // don't want to mess with JS's Function.prototype.call()\n    let evaluated_args = this.args.map(arg => {\n      if(arg.execute) {\n        return arg.execute();\n      } else {\n        return arg;\n      }\n    });\n    return this.definition.execute(evaluated_args, this.scope);\n  }\n}\n\n\n//# sourceURL=webpack:///./src/ast/FunctionCall.js?");

/***/ }),

/***/ "./src/ast/GlobalScope.js":
/*!********************************!*\
  !*** ./src/ast/GlobalScope.js ***!
  \********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return GlobalScope; });\n/* harmony import */ var _Scope_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Scope.js */ \"./src/ast/Scope.js\");\n/* harmony import */ var _ConfigStatements_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ConfigStatements.js */ \"./src/ast/ConfigStatements.js\");\n/* harmony import */ var _Track_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Track.js */ \"./src/ast/Track.js\");\n\n\n\n\nclass GlobalScope extends _Scope_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n  constructor(statements) {\n    super();\n    \n    this.name = 'global';\n    this.type = 'global';\n    \n    this.statements = statements;\n  }\n  \n  init() {\n    // set some default values\n    this.vars.set('octave', 2);\n    this.vars.set('volume', 1);\n    this.vars.set('private', false);\n    this.vars.set('time-signature', [4, 4]);\n    this.vars.set('tempo', 120);\n    \n    this.tracks = new Map();\n    this.meta = [];\n    // @TODO: stop circular dependencies? cache them and mark one as mom\n    this.importedStyles = new Map();\n    this.dependencies = [];\n    \n    for(let statement of this.statements) {\n      if(statement instanceof _ConfigStatements_js__WEBPACK_IMPORTED_MODULE_1__[\"MetaStatement\"]\n        || statement instanceof _ConfigStatements_js__WEBPACK_IMPORTED_MODULE_1__[\"OptionsStatement\"]) {\n        this.meta.push(statement);\n      } else if(statement instanceof _ConfigStatements_js__WEBPACK_IMPORTED_MODULE_1__[\"ImportStatement\"]) {\n        this.importedStyles.set(statement.identifier, statement.path);\n        this.dependencies.push(statement.path);\n      } else if(statement instanceof _Track_js__WEBPACK_IMPORTED_MODULE_2__[\"TrackStatement\"]) {\n        this.tracks.set(statement.name, statement);\n      }\n    }\n    // handle meta blocks first since they set variables in own scope\n    this.meta.forEach(statement => statement.init(this));\n    \n    // -- handle importing before statements --\n    \n    this.tracks.forEach(statement => statement.init(this));\n  }\n}\n\n\n//# sourceURL=webpack:///./src/ast/GlobalScope.js?");

/***/ }),

/***/ "./src/ast/Pattern.js":
/*!****************************!*\
  !*** ./src/ast/Pattern.js ***!
  \****************************/
/*! exports provided: PatternStatement, PatternExpressionGroup, PatternCall, JoinedPatternExpression */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PatternStatement\", function() { return PatternStatement; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PatternExpressionGroup\", function() { return PatternExpressionGroup; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PatternCall\", function() { return PatternCall; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"JoinedPatternExpression\", function() { return JoinedPatternExpression; });\n/* harmony import */ var _Scope_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Scope.js */ \"./src/ast/Scope.js\");\n\n\nclass PatternStatement {\n  constructor(opts) {\n    this.identifier = opts.identifier,\n    this.expression = opts.expression,\n    this.condition = (opts.condition !== undefined) ? opts.condition : null;\n  }\n  init(scope) {\n    this.scope = scope;\n    if(this.expression.init) this.expression.init(scope, this); // I am not a scope\n  }\n}\nclass PatternExpressionGroup extends _Scope_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n  constructor(expressions) {\n    super();\n    this.type = 'PatternExpressionGroup';\n    this.name = '@pattern(<anonymous>)';\n    \n    this.vars.set('private', false);\n    this.vars.set('chance', 1);\n    \n    this.expressions = expressions;\n  }\n  init(scope, patternStatement = null) {\n    super.init(scope);\n    this.patternStatement = patternStatement;\n    if(this.patternStatement) {\n      this.name = `@pattern(${this.patternStatement})`;\n    }\n    this.expressions.forEach(expression => {\n      if(expression.init) expression.init(this);\n    });\n  }\n}\nclass PatternCall {\n  constructor(opts) {\n    this.import = opts.import || null;\n    this.track = opts.track || null;\n    this.pattern = opts.pattern;\n  }\n}\nclass JoinedPatternExpression {\n  constructor(patterns) {\n    this.patterns = patterns;\n  }\n}\n\n\n//# sourceURL=webpack:///./src/ast/Pattern.js?");

/***/ }),

/***/ "./src/ast/Scope.js":
/*!**************************!*\
  !*** ./src/ast/Scope.js ***!
  \**************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Scope; });\n/*\n * In Playback styles, basically any pair of curly brackets defines a scope\n * which inherits settings from its parent scope but can overwrite them.\n */\nclass Scope {\n  constructor() {\n    this.vars = new Map();\n    this.name = null;\n    this.type = null;\n    this.scope = null;\n  }\n  init(scope) { // parent scope, if that's unclear\n    this.scope = scope;\n    \n    // in case this.vars was set in the constructor\n    this.vars = new Map([...this.scope.vars, ...this.vars]);\n  }\n}\n\n\n//# sourceURL=webpack:///./src/ast/Scope.js?");

/***/ }),

/***/ "./src/ast/Track.js":
/*!**************************!*\
  !*** ./src/ast/Track.js ***!
  \**************************/
/*! exports provided: TrackStatement, TrackCall */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TrackStatement\", function() { return TrackStatement; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TrackCall\", function() { return TrackCall; });\n/* harmony import */ var _Scope_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Scope.js */ \"./src/ast/Scope.js\");\n/* harmony import */ var _FunctionCall_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./FunctionCall.js */ \"./src/ast/FunctionCall.js\");\n\n\n\nclass TrackStatement extends _Scope_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n  constructor(opts) {\n    super();\n    this.name = opts.identifier;\n    this.type = '@track';\n    \n    this.instrument = opts.instrument;\n    this.identifier = opts.identifier;\n    this.members = opts.members;\n  }\n  init(scope) {\n    super.init(scope);\n    this.function_calls = [];\n    this.patterns = new Map();\n    this.members.forEach(member => {\n      // initialize them all now, var inheritence is handled during execution\n      member.init(this);\n      if(member instanceof _FunctionCall_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]) {\n        this.function_calls.push(member);\n      } else {\n        this.patterns.set(member.identifier, member);\n      }\n    });\n  }\n}\nclass TrackCall {\n  constructor(opts) {\n    this.import = opts.import;\n    this.track = opts.track;\n    this.trackStatement = null; // will be set by the loader.\n  }\n}\n\n\n//# sourceURL=webpack:///./src/ast/Track.js?");

/***/ }),

/***/ "./src/ast/ast_nodes.js":
/*!******************************!*\
  !*** ./src/ast/ast_nodes.js ***!
  \******************************/
/*! exports provided: GlobalScope, MetaStatement, OptionsStatement, ImportStatement, TrackStatement, TrackCall, PatternStatement, PatternExpressionGroup, PatternCall, JoinedPatternExpression, FunctionCall, AnchorArgument, BooleanNot, BooleanAnd, BooleanOr, BeatGroupLiteral, Measure, DrumBeatGroupLiteral, BeatLiteral, DrumBeatLiteral */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BeatLiteral\", function() { return BeatLiteral; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DrumBeatLiteral\", function() { return DrumBeatLiteral; });\n/* harmony import */ var _GlobalScope_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./GlobalScope.js */ \"./src/ast/GlobalScope.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"GlobalScope\", function() { return _GlobalScope_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]; });\n\n/* harmony import */ var _ConfigStatements_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ConfigStatements.js */ \"./src/ast/ConfigStatements.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"MetaStatement\", function() { return _ConfigStatements_js__WEBPACK_IMPORTED_MODULE_1__[\"MetaStatement\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"OptionsStatement\", function() { return _ConfigStatements_js__WEBPACK_IMPORTED_MODULE_1__[\"OptionsStatement\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"ImportStatement\", function() { return _ConfigStatements_js__WEBPACK_IMPORTED_MODULE_1__[\"ImportStatement\"]; });\n\n/* harmony import */ var _Track_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Track.js */ \"./src/ast/Track.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"TrackStatement\", function() { return _Track_js__WEBPACK_IMPORTED_MODULE_2__[\"TrackStatement\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"TrackCall\", function() { return _Track_js__WEBPACK_IMPORTED_MODULE_2__[\"TrackCall\"]; });\n\n/* harmony import */ var _Pattern_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Pattern.js */ \"./src/ast/Pattern.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"PatternStatement\", function() { return _Pattern_js__WEBPACK_IMPORTED_MODULE_3__[\"PatternStatement\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"PatternExpressionGroup\", function() { return _Pattern_js__WEBPACK_IMPORTED_MODULE_3__[\"PatternExpressionGroup\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"PatternCall\", function() { return _Pattern_js__WEBPACK_IMPORTED_MODULE_3__[\"PatternCall\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"JoinedPatternExpression\", function() { return _Pattern_js__WEBPACK_IMPORTED_MODULE_3__[\"JoinedPatternExpression\"]; });\n\n/* harmony import */ var _FunctionCall_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./FunctionCall.js */ \"./src/ast/FunctionCall.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"FunctionCall\", function() { return _FunctionCall_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"]; });\n\n/* harmony import */ var _ArgumentOperators_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ArgumentOperators.js */ \"./src/ast/ArgumentOperators.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"AnchorArgument\", function() { return _ArgumentOperators_js__WEBPACK_IMPORTED_MODULE_5__[\"AnchorArgument\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"BooleanNot\", function() { return _ArgumentOperators_js__WEBPACK_IMPORTED_MODULE_5__[\"BooleanNot\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"BooleanAnd\", function() { return _ArgumentOperators_js__WEBPACK_IMPORTED_MODULE_5__[\"BooleanAnd\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"BooleanOr\", function() { return _ArgumentOperators_js__WEBPACK_IMPORTED_MODULE_5__[\"BooleanOr\"]; });\n\n/* harmony import */ var _BeatGroups_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./BeatGroups.js */ \"./src/ast/BeatGroups.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"BeatGroupLiteral\", function() { return _BeatGroups_js__WEBPACK_IMPORTED_MODULE_6__[\"BeatGroupLiteral\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Measure\", function() { return _BeatGroups_js__WEBPACK_IMPORTED_MODULE_6__[\"Measure\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"DrumBeatGroupLiteral\", function() { return _BeatGroups_js__WEBPACK_IMPORTED_MODULE_6__[\"DrumBeatGroupLiteral\"]; });\n\n/**\n * Constructors for most kinds of nodes in the AST (excuding strings and things\n * that can be represented more easily by their JS value).\n *\n * It's probably bad form/risky to parse directly to the form that's\n * interpreted. Eh.\n */\n\n\n\n\n\n\n\n\n\n\n\n/* beats */\nfunction BeatLiteral(opts) {\n  this.time = opts.time || {time: 'auto'};\n  this.pitch = opts.pitch;\n  this.octave = opts.octave || 'inherit';\n}\n\n/* drums */\nfunction DrumBeatLiteral(opts) {\n  this.time = opts.time;\n  this.accented = opts.accented || false;\n  }\n\n\n//# sourceURL=webpack:///./src/ast/ast_nodes.js?");

/***/ }),

/***/ "./src/ast/errors.js":
/*!***************************!*\
  !*** ./src/ast/errors.js ***!
  \***************************/
/*! exports provided: FunctionNameError, FunctionScopeError, FunctionArgumentsError */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FunctionNameError\", function() { return FunctionNameError; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FunctionScopeError\", function() { return FunctionScopeError; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FunctionArgumentsError\", function() { return FunctionArgumentsError; });\n// does this have to be an Error? idc\nclass PlaybackError extends Error {\n  constructor(message, scope) {\n    super(`${message}\\nScope: \"${scope.name}\"`)\n  }\n}\n\n/* Function-related errors */\nclass FunctionNameError extends PlaybackError {\n  constructor(identifier, scope) {\n    super(`No function exists with name \"${identifier}\"`, scope);\n  }\n}\nclass FunctionScopeError extends PlaybackError {\n  constructor(message, scope) {\n    super(message, scope);\n  }\n}\nclass FunctionArgumentsError extends PlaybackError {\n  constructor(message, scope) {\n    super(message, scope);\n  }\n}\n\n\n//# sourceURL=webpack:///./src/ast/errors.js?");

/***/ }),

/***/ "./src/ast/function_data.js":
/*!**********************************!*\
  !*** ./src/ast/function_data.js ***!
  \**********************************/
/*! exports provided: assertArgTypes, assertScope, definitions */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"assertArgTypes\", function() { return assertArgTypes; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"assertScope\", function() { return assertScope; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"definitions\", function() { return definitions; });\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./errors.js */ \"./src/ast/errors.js\");\n/* harmony import */ var _FunctionCall_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./FunctionCall.js */ \"./src/ast/FunctionCall.js\");\n/* harmony import */ var _type_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./type_utils.js */ \"./src/ast/type_utils.js\");\n\n\n\n\nlet definitions = new Map();\n\n/**\n * Make an assertion about argument count and types.\n * @param {string} identifier The function name.\n * @param {Array} args The arguments passed to the function.\n * @param {Array.<string|Function>} types Array of the types (typeof) or classes\n * (instanceof) to expect.\n * @param {Scope} scope The scope, for error logging.\n */\nfunction assertArgTypes(identifier, args, types, scope) {\n  if(types == '*') return;\n  if(args.length != types.length) {\n    throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__[\"FunctionArgumentsError\"](`\"${identifier}\" requires ${types.length} arguments.`, scope);\n  }\n  for(let i in args) {\n    if(types[i] == '*') continue;\n    let arg = args[i];\n    if(arg instanceof _FunctionCall_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]) {\n      arg = arg.returns;\n      if(arg == '*') {\n        continue; // what's the correct functionality here? cry?\n      } else if(typeof types[i] == 'string') {\n        if(arg != types[i]) {\n          throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__[\"FunctionArgumentsError\"](`Argument ${Number(i)+1} of \"${identifier}\" must be a ${types[i]}.`, scope);\n        }\n      } else {\n        if(arg != types[i]) {\n          throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__[\"FunctionArgumentsError\"](`Argument ${Number(i)+1} of \"${identifier}\" must be a ${types[i].name}.`, scope);\n        }\n      }\n    } else {\n      if(typeof types[i] == 'string') {\n        if(typeof arg != types[i]) {\n          throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__[\"FunctionArgumentsError\"](`Argument ${Number(i)+1} of \"${identifier}\" must be a ${types[i]}.`, scope);\n        }\n      } else {\n        if(!(arg instanceof types[i])) {\n          throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__[\"FunctionArgumentsError\"](`Argument ${Number(i)+1} of \"${identifier}\" must be a ${types[i].name}.`, scope);\n        }\n      }\n    }\n  }\n}\n/**\n * Make an assertion about the scope in which the function is called.\n * @param {string} identifier The function's name.\n * @param {string='no-meta'} goalscope One of 4 string options:\n * - 'meta': the function throws if it's called outside a @meta block.\n * - 'options': the function throws if it's called outside an @options block.\n * - 'no-config': the function throws if it's called inside a @meta or @options\n *   block, but runs anywhere else that the parser will let you call a function.\n * - 'pattern': the function throws if called outside a pattern scope.\n * - 'no-meta' (default): the function throws if it's called inside a @meta\n *   block, but runs anywhere else that the parser will let you call a function.\n * @param {Scope} scope The calling scope.\n */\nfunction assertScope(identifier, goalscope = 'no-meta', scope) {\n  if(goalscope == 'meta') {\n    if(scope.type != '@meta') {\n      throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__[\"FunctionScopeError\"](`Function \"${identifier}\" must only be called within a @meta block.\"`, scope);\n    }\n  } else if(goalscope == 'options') {\n    if(scope.type != '@options') {\n      throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__[\"FunctionScopeError\"](`Function \"${identifier}\" must only be called within an @options block.\"`, scope);\n    }\n  } else if(goalscope == 'no-config') {\n    // ensure that config blocks can be resolved at compile time\n    if(scope.type == '@meta' || scope.type == '@options') {\n      throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__[\"FunctionScopeError\"](`Function \"${identifier}\" must not be called within a @meta or @options block.\"`, scope);\n    }\n  } else if(goalscope == 'pattern') { \n    if(scope.type != 'PatternExpressionGroup') {\n      throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__[\"FunctionScopeError\"](`Function \"${identifier}\" must only be called within a @pattern block.\"`, scope);\n    }\n    // @TODO: what about @pattern foo private() -- makes no sense but yea\n  } else if(goalscope == 'no-meta') { \n    if(scope.type == '@meta') {\n      throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__[\"FunctionScopeError\"](`Function \"${identifier}\" must not be called within a @meta block.\"`, scope);\n    }\n  }\n}\n/**\n * Define a function.\n * @param {string} identifier The name of the function.\n * @param {Object} opts Options passed. See below.\n * @param {Array.<string|Function>|string='*'} opts.types If set, throw error\n * unless the arguments passed to the function map to these. Can be strings\n * (typeof) or classes (instanceof), or the single string '*' to accept\n * anything. See assertArgTypes above.\n * @param {string='no-meta'} opts.scope Throw error unless the calling\n * scope matches. See assertScope above.\n * @param {string|Function|Nil='*'} opts.returns The return type. If set to '*'\n * it may return anything (for example, choose() returns one of whatever's\n * passed to it regardless of type).\n * @param {Function} func The function to run. It's passed 3 arguments:\n * - args: an array of the arguments passed in the Playback function call.\n * - scope: the calling scope. So it can set in scope.vars.\n * - argErr: a function. If the function does further testing on its\n *   arguments and there's an issue, pass this the error message and it throws.\n */\nlet define = function(identifier, opts, func) {\n  let definition = {\n    types: opts.types || '*',\n    returns: opts.returns || '*',\n    scope: opts.scope || 'no-meta',\n    execute: (args, scope) => {\n      let argErr = message => {\n        throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__[\"FunctionArgumentsError\"](message, scope);\n      };\n      return func(args, scope, argErr);\n    }\n  };\n  \n  definitions.set(identifier, definition);\n}\n\n/**\n * Quickly define a single-argument function that simply sets a var of the same\n * name in its parent scope.\n * @param {string} identifier The name of the function.\n * @param {string|Function} type Throw unless the argument is of this type (see\n * assertArgTypes above).\n * @param {?string=null} goalscope Throw error unless the calling scope matches.\n * See assertScope above.\n */\nlet defineVar = function(identifier, type, goalscope = null) {\n  let opts = {\n    types: [type],\n    scope: goalscope,\n    returns: _type_utils_js__WEBPACK_IMPORTED_MODULE_2__[\"Nil\"]\n  };\n  define(identifier, opts, (args, scope, argErr) => {\n    scope.vars.set(identifier, args[0]);\n  })\n}\n\n/**\n * Quickly define a function that sets a a var of the same name in its parent\n * scope. If it has 0 args it sets the var to true, if it has 1 boolean arg\n * it sets the var to that.\n * @param {string} identifier The name of the function.\n * @param {?string=null} goalscope Throw error unless the calling scope matches.\n * See assertScope above.\n */\nlet defineBoolean = function(identifier, goalscope = null) {\n  let opts = {\n    types: '*',\n    scopes: goalscope,\n    returns: _type_utils_js__WEBPACK_IMPORTED_MODULE_2__[\"Nil\"]\n  }\n  define(identifier, opts, (args, scope, argErr) => {\n    if(args.length) {\n      assertArgTypes(identifier, args, ['boolean'], scope);\n      scope.vars.set(identifier, args[0]);\n    } else {\n      scope.vars.set(identifier, true);\n    }\n  })\n}\n\n/*********** ACTUAL FUNCTION DEFINITIONS ***********/\n\n/*** @meta functions ***/\ndefineVar('name', 'string', 'meta');\ndefineVar('author', 'string', 'meta');\ndefineVar('description', 'string', 'meta');\ndefineVar('playback-version', 'number', 'meta');\n\n/*** @options functions ***/\ndefine('time-signature',\n  {\n    types: ['number', 'number'],\n    scope: 'options',\n    returns: _type_utils_js__WEBPACK_IMPORTED_MODULE_2__[\"Nil\"]\n  },\n  (args, scope, argErr) => {\n    if(!Number.isInteger(Math.log2(args[1]))) {\n      argErr('Argument 2 of \"time-signature\" must be a power of 2.');\n    }\n    scope.vars.set('time-signature', [args[0], args[1]]);\n  });\ndefineBoolean('swing', 'options');\n\n/*** anywhere but @meta functions ***/\ndefine('volume',\n  {\n    types: ['number'],\n    scope: 'no-meta',\n    returns: _type_utils_js__WEBPACK_IMPORTED_MODULE_2__[\"Nil\"]\n  },\n  (args, scope, argErr) => {\n    if(args[0] < 0 || args[0] > 1) {\n      argErr('Argument 1 of \"volume\" must be in range 0-1 (inclusive).');\n    }\n    scope.vars.set('volume', args[0]);\n  });\ndefineBoolean('invertible', 'no-meta');\ndefineVar('octave', 'number', 'no-meta');\n\n/*** anywhere but config functions (strictly dynamic functions) ***/\ndefine('choose',\n  {\n    types: '*',\n    scope: 'no-config',\n    returns: '*'\n  },\n  (args, scope, argErr) => {\n    let nonNilArgs = args.filter(arg => arg !== _type_utils_js__WEBPACK_IMPORTED_MODULE_2__[\"Nil\"]);\n    return nonNilArgs[Math.floor(Math.random() * nonNilArgs.length)];\n  });\n\n/*** pattern-only functions ***/\ndefineBoolean('private', 'pattern');\ndefineVar('length', 'number', 'pattern');\ndefine('chance',\n  {\n    types: ['number'],\n    scope: 'pattern',\n    returns: _type_utils_js__WEBPACK_IMPORTED_MODULE_2__[\"Nil\"]\n  },\n  (args, scope, argErr) => {\n    if(args[0] < 0 || args[0] > 1) {\n      argErr('Argument 1 of \"chance\" must be in range 0-1 (inclusive).');\n    }\n    scope.vars.set('chance', args[0]);\n  });\n\n\n\n\n//# sourceURL=webpack:///./src/ast/function_data.js?");

/***/ }),

/***/ "./src/ast/type_utils.js":
/*!*******************************!*\
  !*** ./src/ast/type_utils.js ***!
  \*******************************/
/*! exports provided: Nil, cast_bool */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Nil\", function() { return Nil; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"cast_bool\", function() { return cast_bool; });\nlet Nil = Symbol('Nil');\nlet cast_bool = function(arg) {\n  if(arg === Nil || arg === false) {\n    return false;\n  } else {\n    return true;\n  }\n}\n\n\n\n\n//# sourceURL=webpack:///./src/ast/type_utils.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _loader_loader_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./loader/loader.js */ \"./src/loader/loader.js\");\n/* harmony import */ var _parser_parser_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./parser/parser.js */ \"./src/parser/parser.js\");\n/* harmony import */ var _PlaybackStyle_PlaybackStyle_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./PlaybackStyle/PlaybackStyle.js */ \"./src/PlaybackStyle/PlaybackStyle.js\");\n\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  load: _loader_loader_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].load,\n  PlaybackStyle: _PlaybackStyle_PlaybackStyle_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"],\n  /**\n   * is there a way to link here to the jsdoc where the function is defined?\n   */\n  parse: _parser_parser_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].parse\n});\n\n\n//# sourceURL=webpack:///./src/index.js?");

/***/ }),

/***/ "./src/lexer/lexer.js":
/*!****************************!*\
  !*** ./src/lexer/lexer.js ***!
  \****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var moo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! moo */ \"./node_modules/moo/moo.js\");\n/* harmony import */ var moo__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(moo__WEBPACK_IMPORTED_MODULE_0__);\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (moo__WEBPACK_IMPORTED_MODULE_0___default.a.states({\n  main: {\n    comment: {\n      match:/\\/\\/.*?(?:\\n|$)/, // consuming newline should be fine since this is _?. Can I do eof anchor here? Guess we'll find out \n      lineBreaks: true\n    },\n    quoted_string: /\"(?:[^\\\\\"\\n]|\\\\.)*\"/, // thanx https://stackoverflow.com/a/249937/1784306\n    ws: {\n      match: /\\s+/,\n      lineBreaks: true\n    },\n    at_rule: ['@meta', '@options', '@import', '@track', '@pattern'],\n    identifier: {\n      // start with alpha, may contain digits and dashes but not end with dash\n      match: /[a-zA-z](?:[a-zA-Z\\-\\d]*[a-zA-Z\\d])?/,\n      keywords: {\n        keyword: ['if', 'as'],\n        boolean: ['true', 'false']\n      }\n    },\n    number: /(?:\\d*\\.)?\\d+/,\n    brackets: ['{', '}', '(', ')'],\n    left_angle: {match: '<', push: 'beat'},\n    operators: ['&', '+', '-', '*', '/', '.']\n  },\n  beat: {\n    beat_ws: / +/,\n    beat_colon: ':',\n    beat_number: /(?:\\d*\\.)?\\d+/,\n    beat_flag: /[a-zA-Z]/,\n    beat_right_angle: {match: '>', pop: true},\n    beat_operators: ['|', '+', '-', '*', '/']\n  }\n}));\n\n\n//# sourceURL=webpack:///./src/lexer/lexer.js?");

/***/ }),

/***/ "./src/loader/loader.js":
/*!******************************!*\
  !*** ./src/loader/loader.js ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fs */ \"fs\");\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_0__);\n // lol this shouldn't be allowed\n\n/**\n * Style locator algorithm:\n * if the path begins with . or / look in the filesystem\n * otherwise, look in:\n * 1. styles folder in this repo\n * 2. (node_modules equivalent?)\n * 3. a styles repo to be created later\n * (in either case, if the path doesn't end in .play it's implied, but other\n * file names are respected)\n * note to self: that means no dots in style names\n * @TODO: deal with relative paths outside of the repo vs inside\n * @TODO: windows/unix - https://nodejs.org/api/path.html#path_windows_vs_posix\n */\n\n/**\n * Load a file.\n * (node is working on implementing fs promises but they're behind a flag iirc)\n * @param {string} path The path to the file to load.\n * @return {Promise.<string>} Resolves to the content of the file.\n */\nlet load = function load(path) {\n  return new Promise(function(resolve, reject) {\n    if(path.startsWith('.') || path.startsWith('/'))\n    fs__WEBPACK_IMPORTED_MODULE_0___default.a.readFile(path, 'utf8', (err, data) => err ? reject(err) : resolve(data));\n  });\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  load: load\n});\n\n\n//# sourceURL=webpack:///./src/loader/loader.js?");

/***/ }),

/***/ "./src/parser/grammar.ne":
/*!*******************************!*\
  !*** ./src/parser/grammar.ne ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _lexer_lexer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lexer/lexer.js */ \"./src/lexer/lexer.js\");\n/* harmony import */ var _ast_ast_nodes_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ast/ast_nodes.js */ \"./src/ast/ast_nodes.js\");\n// Generated automatically by nearley, version unknown\n// http://github.com/Hardmath123/nearley\nfunction id(x) { return x[0]; }\n\n\n\nlet Lexer = _lexer_lexer_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\nlet ParserRules = [\n    {\"name\": \"main$macrocall$2\", \"symbols\": [\"TopLevelStatement\"]},\n    {\"name\": \"main$macrocall$1$ebnf$1\", \"symbols\": []},\n    {\"name\": \"main$macrocall$1$ebnf$1$subexpression$1\", \"symbols\": [\"_\", \"main$macrocall$2\"], \"postprocess\": d => d[1][0]},\n    {\"name\": \"main$macrocall$1$ebnf$1\", \"symbols\": [\"main$macrocall$1$ebnf$1\", \"main$macrocall$1$ebnf$1$subexpression$1\"], \"postprocess\": function arrpush(d) {return d[0].concat([d[1]]);}},\n    {\"name\": \"main$macrocall$1\", \"symbols\": [\"main$macrocall$2\", \"main$macrocall$1$ebnf$1\"], \"postprocess\": d => d[0].concat(d[1])},\n    {\"name\": \"main\", \"symbols\": [\"_?\", \"main$macrocall$1\", \"_?\"], \"postprocess\": d => new _ast_ast_nodes_js__WEBPACK_IMPORTED_MODULE_1__[\"GlobalScope\"](d[1])},\n    {\"name\": \"TopLevelStatement\", \"symbols\": [\"ConfigurationStatement\"], \"postprocess\": id},\n    {\"name\": \"TopLevelStatement\", \"symbols\": [\"ImportStatement\"], \"postprocess\": id},\n    {\"name\": \"TopLevelStatement\", \"symbols\": [\"TrackStatement\"], \"postprocess\": id},\n    {\"name\": \"TopLevelStatement\", \"symbols\": [\"TrackCallStatement\"], \"postprocess\": id},\n    {\"name\": \"ConfigurationStatement\", \"symbols\": [{\"literal\":\"@meta\"}, \"_?\", {\"literal\":\"{\"}, \"_?\", \"ConfigurationList\", \"_?\", {\"literal\":\"}\"}], \"postprocess\": d => new _ast_ast_nodes_js__WEBPACK_IMPORTED_MODULE_1__[\"MetaStatement\"](d[4])},\n    {\"name\": \"ConfigurationStatement\", \"symbols\": [{\"literal\":\"@options\"}, \"_?\", {\"literal\":\"{\"}, \"_?\", \"ConfigurationList\", \"_?\", {\"literal\":\"}\"}], \"postprocess\": d => new _ast_ast_nodes_js__WEBPACK_IMPORTED_MODULE_1__[\"OptionsStatement\"](d[4])},\n    {\"name\": \"ConfigurationList$macrocall$2\", \"symbols\": [\"FunctionCallExpression\"]},\n    {\"name\": \"ConfigurationList$macrocall$1$ebnf$1\", \"symbols\": []},\n    {\"name\": \"ConfigurationList$macrocall$1$ebnf$1$subexpression$1\", \"symbols\": [\"_\", \"ConfigurationList$macrocall$2\"], \"postprocess\": d => d[1][0]},\n    {\"name\": \"ConfigurationList$macrocall$1$ebnf$1\", \"symbols\": [\"ConfigurationList$macrocall$1$ebnf$1\", \"ConfigurationList$macrocall$1$ebnf$1$subexpression$1\"], \"postprocess\": function arrpush(d) {return d[0].concat([d[1]]);}},\n    {\"name\": \"ConfigurationList$macrocall$1\", \"symbols\": [\"ConfigurationList$macrocall$2\", \"ConfigurationList$macrocall$1$ebnf$1\"], \"postprocess\": d => d[0].concat(d[1])},\n    {\"name\": \"ConfigurationList\", \"symbols\": [\"ConfigurationList$macrocall$1\"], \"postprocess\": id},\n    {\"name\": \"ImportStatement\", \"symbols\": [{\"literal\":\"@import\"}, \"_\", \"StringLiteral\", \"_\", {\"literal\":\"as\"}, \"_\", \"Identifier\"], \"postprocess\": d => new _ast_ast_nodes_js__WEBPACK_IMPORTED_MODULE_1__[\"ImportStatement\"](d[2], d[6])},\n    {\"name\": \"TrackStatement$macrocall$2\", \"symbols\": [\"TrackMember\"]},\n    {\"name\": \"TrackStatement$macrocall$1$ebnf$1\", \"symbols\": []},\n    {\"name\": \"TrackStatement$macrocall$1$ebnf$1$subexpression$1\", \"symbols\": [\"_\", \"TrackStatement$macrocall$2\"], \"postprocess\": d => d[1][0]},\n    {\"name\": \"TrackStatement$macrocall$1$ebnf$1\", \"symbols\": [\"TrackStatement$macrocall$1$ebnf$1\", \"TrackStatement$macrocall$1$ebnf$1$subexpression$1\"], \"postprocess\": function arrpush(d) {return d[0].concat([d[1]]);}},\n    {\"name\": \"TrackStatement$macrocall$1\", \"symbols\": [\"TrackStatement$macrocall$2\", \"TrackStatement$macrocall$1$ebnf$1\"], \"postprocess\": d => d[0].concat(d[1])},\n    {\"name\": \"TrackStatement\", \"symbols\": [{\"literal\":\"@track\"}, \"_\", \"StringLiteral\", \"_\", {\"literal\":\"as\"}, \"_\", \"Identifier\", \"_?\", {\"literal\":\"{\"}, \"_?\", \"TrackStatement$macrocall$1\", \"_?\", {\"literal\":\"}\"}], \"postprocess\": d => new _ast_ast_nodes_js__WEBPACK_IMPORTED_MODULE_1__[\"TrackStatement\"]({instrument: d[2], identifier: d[6], members: d[10]})},\n    {\"name\": \"TrackMember\", \"symbols\": [\"FunctionCallExpression\"], \"postprocess\": id},\n    {\"name\": \"TrackMember\", \"symbols\": [\"PatternStatement\"], \"postprocess\": id},\n    {\"name\": \"TrackCallStatement\", \"symbols\": [{\"literal\":\"@track\"}, \"_?\", {\"literal\":\"(\"}, \"_?\", \"Identifier\", {\"literal\":\".\"}, \"Identifier\", \"_?\", {\"literal\":\")\"}], \"postprocess\": d => new _ast_ast_nodes_js__WEBPACK_IMPORTED_MODULE_1__[\"TrackCall\"]({import: d[4], track: d[6]})},\n    {\"name\": \"PatternStatement\", \"symbols\": [{\"literal\":\"@pattern\"}, \"_\", \"Identifier\", \"_\", \"PatternConditional\", \"_?\", \"PatternExpression\"], \"postprocess\": d => new _ast_ast_nodes_js__WEBPACK_IMPORTED_MODULE_1__[\"PatternStatement\"]({identifier: d[2], expression: d[6], condition: d[4]})},\n    {\"name\": \"PatternStatement\", \"symbols\": [{\"literal\":\"@pattern\"}, \"_\", \"Identifier\", \"_\", \"PatternExpression\"], \"postprocess\": d => new _ast_ast_nodes_js__WEBPACK_IMPORTED_MODULE_1__[\"PatternStatement\"]({identifier: d[2], expression: d[4]})},\n    {\"name\": \"PatternConditional\", \"symbols\": [{\"literal\":\"if\"}, \"_?\", {\"literal\":\"(\"}, \"_?\", \"FunctionCallArgument\", \"_?\", {\"literal\":\")\"}], \"postprocess\": d => d[4]},\n    {\"name\": \"PatternExpression\", \"symbols\": [\"PatternExpression_NoJoin\"], \"postprocess\": id},\n    {\"name\": \"PatternExpression\", \"symbols\": [\"JoinedPatternExpression\"], \"postprocess\": id},\n    {\"name\": \"PatternExpression_NoJoin\", \"symbols\": [\"PatternExpressionGroup\"], \"postprocess\": id},\n    {\"name\": \"PatternExpression_NoJoin\", \"symbols\": [\"BeatGroupLiteral\"], \"postprocess\": id},\n    {\"name\": \"PatternExpression_NoJoin\", \"symbols\": [\"DrumBeatGroupLiteral\"], \"postprocess\": id},\n    {\"name\": \"PatternExpression_NoJoin\", \"symbols\": [\"FunctionCallExpression\"], \"postprocess\": id},\n    {\"name\": \"PatternExpression_NoJoin\", \"symbols\": [\"PatternCallExpression\"], \"postprocess\": id},\n    {\"name\": \"PatternExpressionGroup$macrocall$2\", \"symbols\": [\"PatternExpression\"]},\n    {\"name\": \"PatternExpressionGroup$macrocall$1$ebnf$1\", \"symbols\": []},\n    {\"name\": \"PatternExpressionGroup$macrocall$1$ebnf$1$subexpression$1\", \"symbols\": [\"_\", \"PatternExpressionGroup$macrocall$2\"], \"postprocess\": d => d[1][0]},\n    {\"name\": \"PatternExpressionGroup$macrocall$1$ebnf$1\", \"symbols\": [\"PatternExpressionGroup$macrocall$1$ebnf$1\", \"PatternExpressionGroup$macrocall$1$ebnf$1$subexpression$1\"], \"postprocess\": function arrpush(d) {return d[0].concat([d[1]]);}},\n    {\"name\": \"PatternExpressionGroup$macrocall$1\", \"symbols\": [\"PatternExpressionGroup$macrocall$2\", \"PatternExpressionGroup$macrocall$1$ebnf$1\"], \"postprocess\": d => d[0].concat(d[1])},\n    {\"name\": \"PatternExpressionGroup\", \"symbols\": [{\"literal\":\"{\"}, \"_?\", \"PatternExpressionGroup$macrocall$1\", \"_?\", {\"literal\":\"}\"}], \"postprocess\": d => new _ast_ast_nodes_js__WEBPACK_IMPORTED_MODULE_1__[\"PatternExpressionGroup\"](d[2])},\n    {\"name\": \"PatternCallExpression\", \"symbols\": [{\"literal\":\"@pattern\"}, \"_?\", {\"literal\":\"(\"}, \"_?\", \"Identifier\", \"_?\", {\"literal\":\")\"}], \"postprocess\": d => new _ast_ast_nodes_js__WEBPACK_IMPORTED_MODULE_1__[\"PatternCall\"]({pattern: d[4]})},\n    {\"name\": \"PatternCallExpression\", \"symbols\": [{\"literal\":\"@pattern\"}, \"_?\", {\"literal\":\"(\"}, \"_?\", \"Identifier\", {\"literal\":\".\"}, \"Identifier\", \"_?\", {\"literal\":\")\"}], \"postprocess\": d => new _ast_ast_nodes_js__WEBPACK_IMPORTED_MODULE_1__[\"PatternCall\"]({track: d[4], pattern: d[6]})},\n    {\"name\": \"PatternCallExpression\", \"symbols\": [{\"literal\":\"@pattern\"}, \"_?\", {\"literal\":\"(\"}, \"_?\", \"Identifier\", {\"literal\":\".\"}, \"Identifier\", {\"literal\":\".\"}, \"Identifier\", \"_?\", {\"literal\":\")\"}], \"postprocess\": d => new _ast_ast_nodes_js__WEBPACK_IMPORTED_MODULE_1__[\"PatternCall\"]({import: d[4], track: d[6], pattern: d[8]})},\n    {\"name\": \"JoinedPatternExpression$macrocall$2\", \"symbols\": [\"PatternExpression_NoJoin\"]},\n    {\"name\": \"JoinedPatternExpression$macrocall$3\", \"symbols\": [{\"literal\":\"&\"}]},\n    {\"name\": \"JoinedPatternExpression$macrocall$1$ebnf$1$subexpression$1\", \"symbols\": [\"_?\", \"JoinedPatternExpression$macrocall$3\", \"_?\", \"JoinedPatternExpression$macrocall$2\"], \"postprocess\": d => d[3][0]},\n    {\"name\": \"JoinedPatternExpression$macrocall$1$ebnf$1\", \"symbols\": [\"JoinedPatternExpression$macrocall$1$ebnf$1$subexpression$1\"]},\n    {\"name\": \"JoinedPatternExpression$macrocall$1$ebnf$1$subexpression$2\", \"symbols\": [\"_?\", \"JoinedPatternExpression$macrocall$3\", \"_?\", \"JoinedPatternExpression$macrocall$2\"], \"postprocess\": d => d[3][0]},\n    {\"name\": \"JoinedPatternExpression$macrocall$1$ebnf$1\", \"symbols\": [\"JoinedPatternExpression$macrocall$1$ebnf$1\", \"JoinedPatternExpression$macrocall$1$ebnf$1$subexpression$2\"], \"postprocess\": function arrpush(d) {return d[0].concat([d[1]]);}},\n    {\"name\": \"JoinedPatternExpression$macrocall$1\", \"symbols\": [\"JoinedPatternExpression$macrocall$2\", \"JoinedPatternExpression$macrocall$1$ebnf$1\"], \"postprocess\": d => d[0].concat(d[1])},\n    {\"name\": \"JoinedPatternExpression\", \"symbols\": [\"JoinedPatternExpression$macrocall$1\"], \"postprocess\": d => new _ast_ast_nodes_js__WEBPACK_IMPORTED_MODULE_1__[\"JoinedPatternExpression\"](d[0])},\n    {\"name\": \"FunctionCallExpression$macrocall$2\", \"symbols\": [\"FunctionCallArgument\"]},\n    {\"name\": \"FunctionCallExpression$macrocall$1$ebnf$1\", \"symbols\": []},\n    {\"name\": \"FunctionCallExpression$macrocall$1$ebnf$1$subexpression$1\", \"symbols\": [\"_\", \"FunctionCallExpression$macrocall$2\"], \"postprocess\": d => d[1][0]},\n    {\"name\": \"FunctionCallExpression$macrocall$1$ebnf$1\", \"symbols\": [\"FunctionCallExpression$macrocall$1$ebnf$1\", \"FunctionCallExpression$macrocall$1$ebnf$1$subexpression$1\"], \"postprocess\": function arrpush(d) {return d[0].concat([d[1]]);}},\n    {\"name\": \"FunctionCallExpression$macrocall$1\", \"symbols\": [\"FunctionCallExpression$macrocall$2\", \"FunctionCallExpression$macrocall$1$ebnf$1\"], \"postprocess\": d => d[0].concat(d[1])},\n    {\"name\": \"FunctionCallExpression\", \"symbols\": [\"Identifier\", \"_?\", {\"literal\":\"(\"}, \"_?\", \"FunctionCallExpression$macrocall$1\", \"_?\", {\"literal\":\")\"}], \"postprocess\": d => new _ast_ast_nodes_js__WEBPACK_IMPORTED_MODULE_1__[\"FunctionCall\"](d[0], d[4])},\n    {\"name\": \"FunctionCallExpression\", \"symbols\": [\"Identifier\", \"_?\", {\"literal\":\"(\"}, {\"literal\":\")\"}], \"postprocess\": d => new _ast_ast_nodes_js__WEBPACK_IMPORTED_MODULE_1__[\"FunctionCall\"](d[0], [])},\n    {\"name\": \"FunctionCallArgument\", \"symbols\": [\"NumericExpression\"], \"postprocess\": id},\n    {\"name\": \"FunctionCallArgument\", \"symbols\": [\"StringLiteral\"], \"postprocess\": id},\n    {\"name\": \"FunctionCallArgument\", \"symbols\": [\"BooleanLiteral\"], \"postprocess\": id},\n    {\"name\": \"FunctionCallArgument\", \"symbols\": [\"PatternExpression\"], \"postprocess\": id},\n    {\"name\": \"FunctionCallArgument\", \"symbols\": [\"BL_PP_Anchor\"], \"postprocess\": d => new _ast_ast_nodes_js__WEBPACK_IMPORTED_MODULE_1__[\"AnchorArgument\"](d[0])},\n    {\"name\": \"FunctionCallArgument\", \"symbols\": [{\"literal\":\"not\"}, \"_\", \"FunctionCallArgument\"], \"postprocess\": d => new _ast_ast_nodes_js__WEBPACK_IMPORTED_MODULE_1__[\"BooleanNot\"](d[2])},\n    {\"name\": \"FunctionCallArgument\", \"symbols\": [\"FunctionCallArgument\", \"_\", {\"literal\":\"and\"}, \"_\", \"FunctionCallArgument\"], \"postprocess\": d => new _ast_ast_nodes_js__WEBPACK_IMPORTED_MODULE_1__[\"BooleanAnd\"](d[0], d[4])},\n    {\"name\": \"FunctionCallArgument\", \"symbols\": [\"FunctionCallArgument\", \"_\", {\"literal\":\"or\"}, \"_\", \"FunctionCallArgument\"], \"postprocess\": d => new _ast_ast_nodes_js__WEBPACK_IMPORTED_MODULE_1__[\"BooleanOr\"](d[0], d[4])},\n    {\"name\": \"BeatGroupLiteral\", \"symbols\": [{\"literal\":\"<\"}, \"_?\", \"MeasureGroup\", \"_?\", {\"literal\":\">\"}], \"postprocess\": d => new _ast_ast_nodes_js__WEBPACK_IMPORTED_MODULE_1__[\"BeatGroupLiteral\"](d[2])},\n    {\"name\": \"MeasureGroup$macrocall$2\", \"symbols\": [\"Measure\"]},\n    {\"name\": \"MeasureGroup$macrocall$3\", \"symbols\": [{\"literal\":\"|\"}]},\n    {\"name\": \"MeasureGroup$macrocall$1$ebnf$1\", \"symbols\": []},\n    {\"name\": \"MeasureGroup$macrocall$1$ebnf$1$subexpression$1\", \"symbols\": [\"_?\", \"MeasureGroup$macrocall$3\", \"_?\", \"MeasureGroup$macrocall$2\"], \"postprocess\": d => d[3][0]},\n    {\"name\": \"MeasureGroup$macrocall$1$ebnf$1\", \"symbols\": [\"MeasureGroup$macrocall$1$ebnf$1\", \"MeasureGroup$macrocall$1$ebnf$1$subexpression$1\"], \"postprocess\": function arrpush(d) {return d[0].concat([d[1]]);}},\n    {\"name\": \"MeasureGroup$macrocall$1\", \"symbols\": [\"MeasureGroup$macrocall$2\", \"MeasureGroup$macrocall$1$ebnf$1\"], \"postprocess\": d => d[0].concat(d[1])},\n    {\"name\": \"MeasureGroup\", \"symbols\": [\"MeasureGroup$macrocall$1\"], \"postprocess\": id},\n    {\"name\": \"Measure$macrocall$2\", \"symbols\": [\"BeatLiteral\"]},\n    {\"name\": \"Measure$macrocall$1$ebnf$1\", \"symbols\": []},\n    {\"name\": \"Measure$macrocall$1$ebnf$1$subexpression$1\", \"symbols\": [\"_\", \"Measure$macrocall$2\"], \"postprocess\": d => d[1][0]},\n    {\"name\": \"Measure$macrocall$1$ebnf$1\", \"symbols\": [\"Measure$macrocall$1$ebnf$1\", \"Measure$macrocall$1$ebnf$1$subexpression$1\"], \"postprocess\": function arrpush(d) {return d[0].concat([d[1]]);}},\n    {\"name\": \"Measure$macrocall$1\", \"symbols\": [\"Measure$macrocall$2\", \"Measure$macrocall$1$ebnf$1\"], \"postprocess\": d => d[0].concat(d[1])},\n    {\"name\": \"Measure\", \"symbols\": [\"Measure$macrocall$1\"], \"postprocess\": d => new _ast_ast_nodes_js__WEBPACK_IMPORTED_MODULE_1__[\"Measure\"](d[0])},\n    {\"name\": \"BeatLiteral\", \"symbols\": [\"BL_TimePart\", {\"literal\":\":\"}, \"BL_PitchPart\", {\"literal\":\":\"}, \"BL_OctavePart\"], \"postprocess\": d => new _ast_ast_nodes_js__WEBPACK_IMPORTED_MODULE_1__[\"BeatLiteral\"]({time: d[0], pitch: d[2], octave: d[4]})},\n    {\"name\": \"BeatLiteral\", \"symbols\": [{\"literal\":\":\"}, \"BL_PitchPart\", {\"literal\":\":\"}, \"BL_OctavePart\"], \"postprocess\": d => new _ast_ast_nodes_js__WEBPACK_IMPORTED_MODULE_1__[\"BeatLiteral\"]({pitch: d[1], octave: d[3]})},\n    {\"name\": \"BeatLiteral\", \"symbols\": [\"BL_TimePart\", {\"literal\":\":\"}, \"BL_PitchPart\"], \"postprocess\": d => new _ast_ast_nodes_js__WEBPACK_IMPORTED_MODULE_1__[\"BeatLiteral\"]({time: d[0], pitch: d[2]})},\n    {\"name\": \"BeatLiteral\", \"symbols\": [{\"literal\":\":\"}, \"BL_PitchPart\"], \"postprocess\": d => new _ast_ast_nodes_js__WEBPACK_IMPORTED_MODULE_1__[\"BeatLiteral\"]({pitch: d[1]})},\n    {\"name\": \"BeatLiteral\", \"symbols\": [\"DrumBeatLiteral\"], \"postprocess\": id},\n    {\"name\": \"BL_TimePart\", \"symbols\": [\"NumericExpression\"], \"postprocess\": d => ({time: d[0]})},\n    {\"name\": \"BL_TimePart\", \"symbols\": [\"BL_TP_Flag\"], \"postprocess\": d => ({time: 'auto', flag: d[0]})},\n    {\"name\": \"BL_TimePart\", \"symbols\": [\"NumericExpression\", \"BL_TP_Flag\"], \"postprocess\": d => ({time: d[0], flag: d[1]})},\n    {\"name\": \"BL_TP_Flag\", \"symbols\": [{\"literal\":\"s\"}], \"postprocess\": d => 'STACCATO'},\n    {\"name\": \"BL_TP_Flag\", \"symbols\": [{\"literal\":\"a\"}], \"postprocess\": d => 'ACCENTED'},\n    {\"name\": \"BL_PitchPart\", \"symbols\": [\"BL_PP_Degree\"], \"postprocess\": id},\n    {\"name\": \"BL_PitchPart\", \"symbols\": [\"BL_PP_Chord\"], \"postprocess\": id},\n    {\"name\": \"BL_PP_Degree\", \"symbols\": [\"NumberLiteral\"], \"postprocess\": d => ({degree: d[0]})},\n    {\"name\": \"BL_PP_Degree\", \"symbols\": [\"BL_PP_Anchor\"], \"postprocess\": d => ({anchor: d[0], degree: 1})},\n    {\"name\": \"BL_PP_Degree\", \"symbols\": [\"BL_PP_Anchor\", \"NumberLiteral\"], \"postprocess\": d => ({anchor: d[0], degree: d[1]})},\n    {\"name\": \"BL_PP_Chord\", \"symbols\": [{\"literal\":\"c\"}], \"postprocess\": d => ({chord: true, degree: 1})},\n    {\"name\": \"BL_PP_Chord\", \"symbols\": [\"BL_PP_Degree\", {\"literal\":\"c\"}], \"postprocess\": d => ({chord: true, anchor: d[0].anchor, degree: d[0].degree})},\n    {\"name\": \"BL_PP_Chord\", \"symbols\": [{\"literal\":\"c\"}, \"BL_PP_Roll\"], \"postprocess\": d => ({chord: true, roll: d[1], degree: 1})},\n    {\"name\": \"BL_PP_Chord\", \"symbols\": [\"BL_PP_Degree\", {\"literal\":\"c\"}, \"BL_PP_Roll\"], \"postprocess\": d => ({chord: true, roll: d[2], anchor: d[0].anchor, degree: d[0].degree})},\n    {\"name\": \"BL_PP_Anchor\", \"symbols\": [{\"literal\":\"k\"}], \"postprocess\": d => 'KEY'},\n    {\"name\": \"BL_PP_Anchor\", \"symbols\": [{\"literal\":\"n\"}], \"postprocess\": d => 'NEXT'},\n    {\"name\": \"BL_PP_Anchor\", \"symbols\": [{\"literal\":\"s\"}], \"postprocess\": d => 'STEP'},\n    {\"name\": \"BL_PP_Anchor\", \"symbols\": [{\"literal\":\"a\"}], \"postprocess\": d => 'ARPEGGIATE'},\n    {\"name\": \"BL_PP_Roll\", \"symbols\": [{\"literal\":\"r\"}], \"postprocess\": d => 'ROLL_UP'},\n    {\"name\": \"BL_PP_Roll\", \"symbols\": [{\"literal\":\"r\"}, {\"literal\":\"d\"}], \"postprocess\": d => 'ROLL_DOWN'},\n    {\"name\": \"BL_OctavePart\", \"symbols\": [\"NumberLiteral\"], \"postprocess\": id},\n    {\"name\": \"DrumBeatGroupLiteral\", \"symbols\": [\"StringLiteral\", \"_?\", \"BeatGroupLiteral\"], \"postprocess\": d => new _ast_ast_nodes_js__WEBPACK_IMPORTED_MODULE_1__[\"DrumBeatGroupLiteral\"](d[0], d[2])},\n    {\"name\": \"DrumBeatGroupLiteral\", \"symbols\": [\"StringLiteral\", \"_?\", \"FunctionCallExpression\"], \"postprocess\": d => new _ast_ast_nodes_js__WEBPACK_IMPORTED_MODULE_1__[\"DrumBeatGroupLiteral\"](d[0], d[2])},\n    {\"name\": \"DrumBeatLiteral\", \"symbols\": [\"NumberLiteral\"], \"postprocess\": d => new _ast_ast_nodes_js__WEBPACK_IMPORTED_MODULE_1__[\"DrumBeatLiteral\"]({time: d[0]})},\n    {\"name\": \"DrumBeatLiteral\", \"symbols\": [\"NumberLiteral\", {\"literal\":\"a\"}], \"postprocess\": d => new _ast_ast_nodes_js__WEBPACK_IMPORTED_MODULE_1__[\"DrumBeatLiteral\"]({time: d[0], accented: true})},\n    {\"name\": \"NumericExpression\", \"symbols\": [\"NE_addsub\"], \"postprocess\": id},\n    {\"name\": \"NE_parens\", \"symbols\": [{\"literal\":\"(\"}, \"NE_addsub\", {\"literal\":\")\"}], \"postprocess\": d => d[1]},\n    {\"name\": \"NE_parens\", \"symbols\": [\"NumberLiteral\"], \"postprocess\": id},\n    {\"name\": \"NE_muldiv\", \"symbols\": [\"NE_muldiv\", {\"literal\":\"*\"}, \"NE_parens\"], \"postprocess\": d => (d[0] * d[2])},\n    {\"name\": \"NE_muldiv\", \"symbols\": [\"NE_muldiv\", {\"literal\":\"/\"}, \"NE_parens\"], \"postprocess\": d => (d[0] / d[2])},\n    {\"name\": \"NE_muldiv\", \"symbols\": [\"NE_parens\"], \"postprocess\": id},\n    {\"name\": \"NE_addsub\", \"symbols\": [\"NE_addsub\", {\"literal\":\"+\"}, \"NE_muldiv\"], \"postprocess\": d => (d[0] + d[2])},\n    {\"name\": \"NE_addsub\", \"symbols\": [\"NE_addsub\", {\"literal\":\"-\"}, \"NE_muldiv\"], \"postprocess\": d => (d[0] - d[2])},\n    {\"name\": \"NE_addsub\", \"symbols\": [\"NE_muldiv\"], \"postprocess\": id},\n    {\"name\": \"Identifier\", \"symbols\": [(_lexer_lexer_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].has(\"identifier\") ? {type: \"identifier\"} : identifier)], \"postprocess\": d => d[0].value},\n    {\"name\": \"NumberLiteral\", \"symbols\": [(_lexer_lexer_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].has(\"number\") ? {type: \"number\"} : number)], \"postprocess\": d => Number(d[0].value)},\n    {\"name\": \"NumberLiteral\", \"symbols\": [(_lexer_lexer_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].has(\"beat_number\") ? {type: \"beat_number\"} : beat_number)], \"postprocess\": d => Number(d[0].value)},\n    {\"name\": \"BooleanLiteral\", \"symbols\": [(_lexer_lexer_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].has(\"boolean\") ? {type: \"boolean\"} : boolean)], \"postprocess\": d => Boolean(d[0].value)},\n    {\"name\": \"StringLiteral\", \"symbols\": [(_lexer_lexer_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].has(\"quoted_string\") ? {type: \"quoted_string\"} : quoted_string)], \"postprocess\": d => d[0].value.slice(1, -1)},\n    {\"name\": \"_?$ebnf$1\", \"symbols\": [\"_\"], \"postprocess\": id},\n    {\"name\": \"_?$ebnf$1\", \"symbols\": [], \"postprocess\": function(d) {return null;}},\n    {\"name\": \"_?\", \"symbols\": [\"_?$ebnf$1\"], \"postprocess\": () => null},\n    {\"name\": \"_\", \"symbols\": [(_lexer_lexer_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].has(\"ws\") ? {type: \"ws\"} : ws)], \"postprocess\": () => null},\n    {\"name\": \"_\", \"symbols\": [(_lexer_lexer_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].has(\"beat_ws\") ? {type: \"beat_ws\"} : beat_ws)], \"postprocess\": () => null},\n    {\"name\": \"_$ebnf$1\", \"symbols\": [(_lexer_lexer_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].has(\"ws\") ? {type: \"ws\"} : ws)], \"postprocess\": id},\n    {\"name\": \"_$ebnf$1\", \"symbols\": [], \"postprocess\": function(d) {return null;}},\n    {\"name\": \"_$ebnf$2$subexpression$1$ebnf$1\", \"symbols\": [(_lexer_lexer_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].has(\"ws\") ? {type: \"ws\"} : ws)], \"postprocess\": id},\n    {\"name\": \"_$ebnf$2$subexpression$1$ebnf$1\", \"symbols\": [], \"postprocess\": function(d) {return null;}},\n    {\"name\": \"_$ebnf$2$subexpression$1\", \"symbols\": [(_lexer_lexer_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].has(\"comment\") ? {type: \"comment\"} : comment), \"_$ebnf$2$subexpression$1$ebnf$1\"]},\n    {\"name\": \"_$ebnf$2\", \"symbols\": [\"_$ebnf$2$subexpression$1\"]},\n    {\"name\": \"_$ebnf$2$subexpression$2$ebnf$1\", \"symbols\": [(_lexer_lexer_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].has(\"ws\") ? {type: \"ws\"} : ws)], \"postprocess\": id},\n    {\"name\": \"_$ebnf$2$subexpression$2$ebnf$1\", \"symbols\": [], \"postprocess\": function(d) {return null;}},\n    {\"name\": \"_$ebnf$2$subexpression$2\", \"symbols\": [(_lexer_lexer_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].has(\"comment\") ? {type: \"comment\"} : comment), \"_$ebnf$2$subexpression$2$ebnf$1\"]},\n    {\"name\": \"_$ebnf$2\", \"symbols\": [\"_$ebnf$2\", \"_$ebnf$2$subexpression$2\"], \"postprocess\": function arrpush(d) {return d[0].concat([d[1]]);}},\n    {\"name\": \"_\", \"symbols\": [\"_$ebnf$1\", \"_$ebnf$2\"], \"postprocess\": () => null},\n    {\"name\": \"_$ebnf$3\", \"symbols\": [(_lexer_lexer_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].has(\"beat_ws\") ? {type: \"beat_ws\"} : beat_ws)], \"postprocess\": id},\n    {\"name\": \"_$ebnf$3\", \"symbols\": [], \"postprocess\": function(d) {return null;}},\n    {\"name\": \"_$ebnf$4$subexpression$1$ebnf$1\", \"symbols\": [(_lexer_lexer_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].has(\"beat_ws\") ? {type: \"beat_ws\"} : beat_ws)], \"postprocess\": id},\n    {\"name\": \"_$ebnf$4$subexpression$1$ebnf$1\", \"symbols\": [], \"postprocess\": function(d) {return null;}},\n    {\"name\": \"_$ebnf$4$subexpression$1\", \"symbols\": [(_lexer_lexer_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].has(\"comment\") ? {type: \"comment\"} : comment), \"_$ebnf$4$subexpression$1$ebnf$1\"]},\n    {\"name\": \"_$ebnf$4\", \"symbols\": [\"_$ebnf$4$subexpression$1\"]},\n    {\"name\": \"_$ebnf$4$subexpression$2$ebnf$1\", \"symbols\": [(_lexer_lexer_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].has(\"beat_ws\") ? {type: \"beat_ws\"} : beat_ws)], \"postprocess\": id},\n    {\"name\": \"_$ebnf$4$subexpression$2$ebnf$1\", \"symbols\": [], \"postprocess\": function(d) {return null;}},\n    {\"name\": \"_$ebnf$4$subexpression$2\", \"symbols\": [(_lexer_lexer_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].has(\"comment\") ? {type: \"comment\"} : comment), \"_$ebnf$4$subexpression$2$ebnf$1\"]},\n    {\"name\": \"_$ebnf$4\", \"symbols\": [\"_$ebnf$4\", \"_$ebnf$4$subexpression$2\"], \"postprocess\": function arrpush(d) {return d[0].concat([d[1]]);}},\n    {\"name\": \"_\", \"symbols\": [\"_$ebnf$3\", \"_$ebnf$4\"], \"postprocess\": () => null}\n];\nlet ParserStart = \"main\";\n/* harmony default export */ __webpack_exports__[\"default\"] = ({ Lexer, ParserRules, ParserStart });\n\n\n//# sourceURL=webpack:///./src/parser/grammar.ne?");

/***/ }),

/***/ "./src/parser/parser.js":
/*!******************************!*\
  !*** ./src/parser/parser.js ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var nearley__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! nearley */ \"./node_modules/nearley/lib/nearley.js\");\n/* harmony import */ var nearley__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(nearley__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _grammar_ne__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./grammar.ne */ \"./src/parser/grammar.ne\");\n\n\n/**\n * Parses a string into a set of possible abstract systax trees (ASTs) trees of\n * objects representing the syntax of the file.\n * @param {string} data The string to parse\n * @return {Promise.<Array>.<GlobalScope>} A promise that resolves to an array\n * of parsings, each of which is an AST. (Ideally there should be 1 parsing.)\n *\n * See ast_nodes.js or the grammar itself for an idea of what the nodes in the\n * tree might look like.\n * @private\n */\nlet string_to_ast = function string_to_ast(data) {\n  // Create a Parser object from our grammar.\n  // (I don't think you can reset the parser so make a new one each time)\n  const parser = new nearley__WEBPACK_IMPORTED_MODULE_0___default.a.Parser(nearley__WEBPACK_IMPORTED_MODULE_0___default.a.Grammar.fromCompiled(_grammar_ne__WEBPACK_IMPORTED_MODULE_1__[\"default\"]));\n  \n  return new Promise(function(resolve, reject) {\n    try {\n      parser.feed(data);\n    } catch(err) {\n      // Because tabs screw up the formatting of SyntaxError messages.\n      err.message = err.message.replace(/\\t/g, ' ');\n      reject(err);\n    }\n    resolve(parser.results);\n  });\n};\n\n/**\n * Parse a string into an Abstract Syntax Tree (AST) -- a tree of objects\n * representing the syntax of the file.\n * @param {string}  data The string to parse\n * @return {Promise.<GlobalScope>} The Abstract Systax Tree (AST).\n */\n let parse = function parse(data) {\n   return new Promise(function(resolve, reject) {\n     string_to_ast(data)\n       .then(parses => {\n         if(!parses.length) {\n           throw new SyntaxError('Something went wrong, input not parseable.');\n         }\n         resolve(parses[0]);\n       });\n   });\n };\n \n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  string_to_ast: string_to_ast,\n  parse: parse\n});\n\n\n//# sourceURL=webpack:///./src/parser/parser.js?");

/***/ }),

/***/ "./src/parser/test/test.js":
/*!*********************************!*\
  !*** ./src/parser/test/test.js ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _loader_loader_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../loader/loader.js */ \"./src/loader/loader.js\");\n/* harmony import */ var _parser_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../parser.js */ \"./src/parser/parser.js\");\n/* harmony import */ var assert__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! assert */ \"assert\");\n/* harmony import */ var assert__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(assert__WEBPACK_IMPORTED_MODULE_2__);\n\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function() {\n  \n  // load a couple test files\n  // yes one promise can have multiple thens, I checked in chrome console\n  let styles_dir = 'src/parser/test/styles/';\n  let file_ambig = _loader_loader_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].load(styles_dir + 'ambig.play');\n  let file_example = _loader_loader_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].load(styles_dir + 'example.play');\n  \n  /**\n   * Parser smoketest: try parsing an old/modified version of the swing style\n   * (this is the file I add new features to when I'm modifying the grammar)\n   */\n  file_example.then(_parser_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].parse).then(ast => {\n    ast.init()\n    // assert.ok(ast.tracks[0] typeof Track);\n  });\n  \n  /** test for grammar ambiguities with:\n   *  - \"|\" and \"&\"-separated lists\n   *  - whitespace-separated lists\n   *  - multiple lines of // comments\n   */\n  file_ambig\n    .then(_parser_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].string_to_ast)\n    .then(results => {\n      assert__WEBPACK_IMPORTED_MODULE_2___default.a.equal(results.length, 1, 'expected 1 parse (grammar ambiguous)');\n    });\n});;\n\n\n//# sourceURL=webpack:///./src/parser/test/test.js?");

/***/ }),

/***/ "./test/test.js":
/*!**********************!*\
  !*** ./test/test.js ***!
  \**********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _src_parser_test_test_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../src/parser/test/test.js */ \"./src/parser/test/test.js\");\n/* harmony import */ var _src_parser_parser_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../src/parser/parser.js */ \"./src/parser/parser.js\");\n/* harmony import */ var _src_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../src/index.js */ \"./src/index.js\");\n\n\n\n\n//const verbose = process.argv.includes('--verbose');\n\n// run parser tests\nObject(_src_parser_test_test_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])();\n\n// @TODO: have a set of tests directly on playback.js to make sure the apis\n// export correctly cuz webpack is being iffy about that\n\nclass Song {\n  constructor(measures) {\n    this.measures = measures;\n    this.length = this.measures.length;\n    this._idx = -1;\n  }\n  next() {\n    if(++this._idx < this.length) {\n      return {value: this.measures[this._idx], done: false};\n    } else {\n      return {value: undefined, done: true};\n    }\n  }\n  lookahead(dist) {\n    return this.measures[this._idx + dist];\n  }\n}\nlet song = new Song([\n  // Each array is a measure, and each item in an array is a beat.\n  // null inside a measure means there's no chord set for that beat.\n  ['A-', null, null, null], ['E', null, null, null], ['A-7', null, null, null], ['A-6', null, null, null],\n  ['CM7', null, 'A7', null], ['D-7', null, 'G7', null], ['C6', null, null, null], ['Bdim7', null, 'E7', null],\n  ['A-', null, null, null], ['E', null, null, null], ['A-7', null, null, null], ['A-6', null, null, null],\n  ['CM7', null, 'A7', null], ['D-7', null, 'G7', null], ['C6', null, null, null], ['C6', null, null, null]\n]);\n\nnew _src_index_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].PlaybackStyle('./test/styles/example.play');\n\n\n//# sourceURL=webpack:///./test/test.js?");

/***/ }),

/***/ "assert":
/*!*************************!*\
  !*** external "assert" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"assert\");\n\n//# sourceURL=webpack:///external_%22assert%22?");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"fs\");\n\n//# sourceURL=webpack:///external_%22fs%22?");

/***/ })

/******/ });