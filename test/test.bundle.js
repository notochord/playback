/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// object to store loaded chunks
/******/ 	// "0" means "already loaded"
/******/ 	var installedChunks = {
/******/ 		"main": 0
/******/ 	};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// uncaught error handler for webpack runtime
/******/ 	__webpack_require__.oe = function(err) {
/******/ 		process.nextTick(function() {
/******/ 			throw err; // catch this error by using import().catch()
/******/ 		});
/******/ 	};
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./test/test.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/MIDI/Note.js":
/*!**************************!*\
  !*** ./src/MIDI/Note.js ***!
  \**************************/
/*! exports provided: AwaitingDrum, Note, NoteSet */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AwaitingDrum\", function() { return AwaitingDrum; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Note\", function() { return Note; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NoteSet\", function() { return NoteSet; });\n/* harmony import */ var _lib_tonal_min_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/tonal.min.js */ \"./src/lib/tonal.min.js\");\n/* harmony import */ var _drums_json_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./drums.json.js */ \"./src/MIDI/drums.json.js\");\n\n\n\n/**\n * There are some inconsistencies with the official MIDI drum names, this\n * transformation will hopefully ease the pain there.\n * Note: What's the more general word for case-folding? Just \"normalizing\"? Eh\n * @param {string} name\n * @return {string}\n */\nfunction normalizeDrumName(name) {\n  return name.toLowerCase().replace(/ |-|_/g, ' ');\n}\n\n// make a map of drum names, which is the inverse of the given JSON file\nlet DRUM_MAP = new Map();\nfor(let midi in _drums_json_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]) {\n  let name = normalizeDrumName(_drums_json_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"][midi])\n  DRUM_MAP.set(name, midi);\n}\n\n/**\n * Special pitch value meaning the note will be set later by a DrumBeatGroup\n */\nlet AwaitingDrum = Symbol('AwaitingDrum');\n\n\nclass Note {\n  /**\n   * @param {Object} opts Options object.\n   * @param {number} opts.time The note's time, in beats.\n   * @param {string} opts.pitch A string representing the pitch and octave of the note. e.x. 'A4'\n   * @param {number} opts.duraion The note's duration, in beats.\n   * @param {number} opts.volume The note's volume, as a float 0-1 (inclusive).\n   */\n  constructor(opts) {\n    /**\n     * The note's time, in beats.\n     * @type {number}\n     */\n    this.time = opts.time;\n    /**\n     * A string representing the pitch and octave of the note.\n     * @type {string}\n     * @example 'A4'\n     */\n    this.pitch = opts.pitch;\n    /**\n     * The note's duration, in beats.\n     * @type {number}\n     */\n    this.duration = opts.duration;\n    /**\n     * The note's volume, as a float 0-1 (inclusive).\n     * @type {number}\n     */\n    this.volume = opts.volume;\n  }\n  /**\n   * An integer representing the MIDI pitch value of the note.\n   * @type {number}\n   */\n  get midi() {\n    if(this.pitch === AwaitingDrum) {\n      return null;\n    } else {\n      let drumValue = DRUM_MAP.get(normalizeDrumName(this.pitch));\n      if(drumValue) {\n        return drumValue;\n      } else {\n        return _lib_tonal_min_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Note.midi(this.pitch);\n      }\n    }\n  }\n  /**\n   * An integer 0-127 that roughly correlates to volume\n   * @type {number}\n   */\n  get velocity() {\n    return Math.floor(this.volume * 127);\n  }\n}\n\nclass NoteSet extends Array {\n  constructor() {\n    super();\n    this.push(...arguments);\n  }\n}\n\n\n//# sourceURL=webpack:///./src/MIDI/Note.js?");

/***/ }),

/***/ "./src/MIDI/drums.json.js":
/*!********************************!*\
  !*** ./src/MIDI/drums.json.js ***!
  \********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  \"26\": \"Silence\",\n  \"27\": \"High-Q\",\n  \"28\": \"Slap\",\n  \"29\": \"Scratch Push\",\n  \"30\": \"Scratch Pull\",\n  \"31\": \"Sticks\",\n  \"32\": \"Square Click\",\n  \"33\": \"Metronome Click\",\n  \"34\": \"Metronome Bell\",\n  \"35\": \"Acoustic Bass Drum\",\n  \"36\": \"Bass Drum\",\n  \"37\": \"Side Stick\",\n  \"38\": \"Acoustic Snare\",\n  \"39\": \"Hand Clap\",\n  \"40\": \"Electric Snare\",\n  \"41\": \"Low Floor Tom\",\n  \"42\": \"Closed Hi Hat\",\n  \"43\": \"High Floor Tom\",\n  \"44\": \"Pedal Hi-Hat\",\n  \"45\": \"Low Tom\",\n  \"46\": \"Open Hi-Hat\",\n  \"47\": \"Low-Mid Tom\",\n  \"48\": \"Hi-Mid Tom\",\n  \"49\": \"Crash Cymbal 1\",\n  \"50\": \"High Tom\",\n  \"51\": \"Ride Cymbal 1\",\n  \"52\": \"Chinese Cymbal\",\n  \"53\": \"Ride Bell\",\n  \"54\": \"Tambourine\",\n  \"55\": \"Splash Cymbal\",\n  \"56\": \"Cowbell\",\n  \"57\": \"Crash Cymbal 2\",\n  \"58\": \"Vibraslap\",\n  \"59\": \"Ride Cymbal 2\",\n  \"60\": \"Hi Bongo\",\n  \"61\": \"Low Bongo\",\n  \"62\": \"Mute Hi Conga\",\n  \"63\": \"Open Hi Conga\",\n  \"64\": \"Low Conga\",\n  \"65\": \"High Timbale\",\n  \"66\": \"Low Timbale\",\n  \"67\": \"High Agogo\",\n  \"68\": \"Low Agogo\",\n  \"69\": \"Cabasa\",\n  \"70\": \"Maracas\",\n  \"71\": \"Short Whistle\",\n  \"72\": \"Long Whistle\",\n  \"73\": \"Short Guiro\",\n  \"74\": \"Long Guiro\",\n  \"75\": \"Claves\",\n  \"76\": \"Hi Wood Block\",\n  \"77\": \"Low Wood Block\",\n  \"78\": \"Mute Cuica\",\n  \"79\": \"Open Cuica\",\n  \"80\": \"Mute Triangle\",\n  \"81\": \"Open Triangle\",\n  \"82\": \"Shaker\",\n  \"83\": \"Jingle Bell\",\n  \"84\": \"Bell Tree\",\n  \"85\": \"Castanets\",\n  \"86\": \"Mute Surdo\",\n  \"87\": \"Open Surdo\"\n});\n\n\n//# sourceURL=webpack:///./src/MIDI/drums.json.js?");

/***/ }),

/***/ "./src/PlaybackStyle/PlaybackStyle.js":
/*!********************************************!*\
  !*** ./src/PlaybackStyle/PlaybackStyle.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return PlaybackStyle; });\n/* harmony import */ var _loader_loader_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../loader/loader.js */ \"./src/loader/loader-node.js\");\n/* harmony import */ var _parser_parser_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../parser/parser.js */ \"./src/parser/parser.js\");\n\n\n\nclass PlaybackStyle {\n  /**\n   * Set the main ast (the one that plays all its instruments by default).\n   * @param {ast.GlobalScope} main the main ast\n   * @param {Map.<string: ast.GlobalScope>} asts A map of asts by their path\n   */\n  constructor(mainPath) {\n    this._mainPath = mainPath;\n    this._ASTs = new Map();\n    this._initialized = false;\n  }\n  /**\n   * Parse each file, pull its dependencies, put it all in a cache, rinse and\n   * repeat.\n   * @private\n   */\n  async _loadDependencies() {\n    let pendingDependencies = [this._mainPath];\n    let dependencyPath;\n    // @TODO: verify that dependencies have compatible time signature to main\n    while(dependencyPath = pendingDependencies.pop()) {\n      let rawfile;\n      try {\n        rawfile = await Object(_loader_loader_js__WEBPACK_IMPORTED_MODULE_0__[\"load\"])(dependencyPath);\n      } catch(e) {\n        throw new Error(`Couldn't locate imported style \"${dependencyPath}\".`);\n      }\n      let ast = await Object(_parser_parser_js__WEBPACK_IMPORTED_MODULE_1__[\"parse\"])(rawfile);\n      this._ASTs.set(dependencyPath, ast);\n      ast.init();\n      for(let newDependency of ast.dependencies) {\n        if(!this._ASTs.has(newDependency)) {\n          pendingDependencies.push(newDependency);\n        }\n      }\n    }\n    this._main = this._ASTs.get(this._mainPath);\n  }\n  _link() {\n    this._main.link(this._ASTs);\n  }\n  /**\n   * Initialize the style, which includes loading dependencies and linking\n   * track/pattern calls. Must be called before compiling/playing.\n   */\n  async init() {\n    await this._loadDependencies();\n    this._link();\n    this._initialized = true;\n  }\n  /**\n   * Compile a song into a set of MIDI-like note instructions.\n   * @param {Song} song A Playback Song (notochord????)\n   * @returns {NoteSet.<Note>} An array-like object containing MIDI-like note\n   * instructions.\n   */\n  compile(song) {\n    if(!this._initialized) {\n      throw new Error('PlayBack style must be initialized before compiling');\n    }\n    let songIterator = song[Symbol.iterator]();\n    let nextValue = songIterator.next();\n    console.log('nextValue', nextValue)\n    let notes = this._main.execute(songIterator);\n    console.log('---final result---');\n    console.log(notes);\n    \n    /*\n    while(nextValue = songIterator.next(), !nextValue.done) {\n      this._main.execute(songIterator);\n    }\n    */\n  }\n  async play(song) {\n    this.compile(song);\n    // @TODO: take the MIDI events and play them\n  }\n}\n\n\n//# sourceURL=webpack:///./src/PlaybackStyle/PlaybackStyle.js?");

/***/ }),

/***/ "./src/ast/ArgumentOperators.js":
/*!**************************************!*\
  !*** ./src/ast/ArgumentOperators.js ***!
  \**************************************/
/*! exports provided: AnchorArgument, BooleanNot, BooleanAnd, BooleanOr */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AnchorArgument\", function() { return AnchorArgument; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BooleanNot\", function() { return BooleanNot; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BooleanAnd\", function() { return BooleanAnd; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BooleanOr\", function() { return BooleanOr; });\n/* harmony import */ var _type_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./type_utils.js */ \"./src/ast/type_utils.js\");\n\n\nclass AnchorArgument {\n  constructor(anchor) {\n    this.anchor = anchor;\n  }\n}\n\nclass BooleanOperator {\n  constructor() {\n    this.args = Array.prototype.slice.call(arguments);\n  }\n  link(ASTs, parentStyle, parentTrack) {\n    this.args.forEach(arg => {\n      if(arg.link) arg.link(ASTs, parentStyle, parentTrack);\n    });\n  }\n  init(scope) {\n    this.scope = scope\n    this.args.forEach(arg => {\n      if(arg.init) arg.init(scope);\n    });\n  }\n  resolve_args(songIterator) {\n    return this.args.map(arg => {\n      if(arg.init) {\n        return arg.init(songIterator);\n      } else {\n        return arg;\n      }\n    });\n  }\n}\n\nclass BooleanNot extends BooleanOperator {\n  constructor() {\n    super(arguments);\n  }\n  execute(songIterator) {\n    let args = this.resolve_args(songIterator);\n    return !Object(_type_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"cast_bool\"])(args[0]);\n  }\n}\nclass BooleanAnd extends BooleanOperator {\n  constructor() {\n    super(arguments);\n  }\n  execute(songIterator) {\n    // sorry no short-circuiting because this code is prettier\n    // @TODO: add short-circuiting if this actually makes it too slow\n    let args = this.resolve_args(songIterator);\n    return Object(_type_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"cast_bool\"])(args[0]) && Object(_type_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"cast_bool\"])(args[1]);\n  }\n}\nclass BooleanOr extends BooleanOperator {\n  constructor() {\n    super(arguments);\n  }\n  execute(songIterator) {\n    let args = this.resolve_args(songIterator);\n    return Object(_type_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"cast_bool\"])(args[0]) || Object(_type_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"cast_bool\"])(args[1]);\n  }\n}\n\n\n//# sourceURL=webpack:///./src/ast/ArgumentOperators.js?");

/***/ }),

/***/ "./src/ast/BeatGroups.js":
/*!*******************************!*\
  !*** ./src/ast/BeatGroups.js ***!
  \*******************************/
/*! exports provided: BeatGroupLiteral, Measure, DrumBeatGroupLiteral */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BeatGroupLiteral\", function() { return BeatGroupLiteral; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Measure\", function() { return Measure; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DrumBeatGroupLiteral\", function() { return DrumBeatGroupLiteral; });\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./errors.js */ \"./src/ast/errors.js\");\n/* harmony import */ var _type_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./type_utils.js */ \"./src/ast/type_utils.js\");\n/* harmony import */ var _MIDI_Note_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../MIDI/Note.js */ \"./src/MIDI/Note.js\");\n/* harmony import */ var _FunctionCall_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./FunctionCall.js */ \"./src/ast/FunctionCall.js\");\n\n\n\n\n\nclass BeatGroupLiteral {\n  constructor(measures) {\n    this.measures = measures;\n    this.scope = null;\n  }\n  init(scope) {\n    this.scope = scope;\n    this.measures.forEach(measure => measure.init(scope));\n  }\n  link() {return;}\n  execute(songIterator) {\n    let joinedMeasures = new _MIDI_Note_js__WEBPACK_IMPORTED_MODULE_2__[\"NoteSet\"]();\n    for(let i = 0; i < this.measures.length; i++) {\n      let offset = i * 4; // @TODO: pull in actual meter somehow\n      let measureNotes = this.measures[i].execute(songIterator);\n      if(measureNotes === _type_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"Nil\"]) return _type_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"Nil\"]; // lets a/s abort the beatgroup\n      for(let measureNote of measureNotes) {\n        measureNote.time += offset;\n        joinedMeasures.push(measureNote);\n      }\n    }\n    return joinedMeasures;\n  }\n}\n\nclass Measure {\n  constructor(beats) {\n    this.beats = beats;\n    this.beatsPerMeasure = null;\n    this.scope = null;\n  }\n  calculateDurationAfter(beatIndex) {\n    let currentBeat = this.beats[beatIndex];\n    let currentBeatTime = currentBeat.getTime();\n    \n    let nextBeatTime;\n    if(beatIndex + 1 >= this.beats.length) {\n      nextBeatTime = this.beatsPerMeasure + 1;\n    } else {\n      let nextBeat = this.beats[beatIndex + 1];\n      nextBeatTime = nextBeat.getTime();\n    }\n    return nextBeatTime - currentBeatTime;\n  }\n  init(scope) {\n    this.scope = scope;\n    this.beatsPerMeasure = this.scope.vars.get('time-signature')[0];\n    // @TODO does this need more math?\n    this.beats.forEach((beat, i) => {\n      beat.init(scope, this, i);\n    });\n  }\n  execute(songIterator) {\n    // each beat returns a NoteSet since it could be a chord or whatever\n    let joined = new _MIDI_Note_js__WEBPACK_IMPORTED_MODULE_2__[\"NoteSet\"]();\n    for(let beat of this.beats) {\n      let notes = beat.execute(songIterator);\n      if(notes === _type_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"Nil\"]) return _type_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"Nil\"]; // lets a and s abort the beatgroup.\n      joined.push(...notes);\n    }\n    return joined;\n  }\n}\n\nclass DrumBeatGroupLiteral {\n  constructor(drum, beatGroup) {\n    this.drum = drum;\n    this.beatGroup = beatGroup; // for now there's no diff in functionality...\n    // @TODO make sure our beats are all drummy\n  }\n  init(scope) {\n    this.scope = scope;\n    if(this.beatGroup.init) this.beatGroup.init(scope);\n  }\n  link() {return;} // @TODO: I think patterncalls are allowed here?\n  execute(songIterator) {\n    let notes = this.beatGroup.execute(songIterator);\n    for(let note of notes) {\n      if(note.pitch === _MIDI_Note_js__WEBPACK_IMPORTED_MODULE_2__[\"AwaitingDrum\"]) {\n        note.pitch = this.drum; // @TODO: convert to number?\n      } else {\n        throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__[\"MelodicBeatInDrumBeatGroupError\"](this.scope);\n      }\n    }\n    return notes;\n  }\n}\n\n\n//# sourceURL=webpack:///./src/ast/BeatGroups.js?");

/***/ }),

/***/ "./src/ast/BeatLiterals.js":
/*!*********************************!*\
  !*** ./src/ast/BeatLiterals.js ***!
  \*********************************/
/*! exports provided: MelodicBeatLiteral, DrumBeatLiteral */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MelodicBeatLiteral\", function() { return MelodicBeatLiteral; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DrumBeatLiteral\", function() { return DrumBeatLiteral; });\n/* harmony import */ var _lib_tonal_min_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/tonal.min.js */ \"./src/lib/tonal.min.js\");\n/* harmony import */ var _MIDI_Note_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../MIDI/Note.js */ \"./src/MIDI/Note.js\");\n//import {Nil} from './type_utils.js';\n\n\n\nclass MelodicBeatLiteral {\n  constructor(opts) {\n    this.time = opts.time || {time: 'auto'};\n    this.pitch = opts.pitch;\n    this.octave = opts.octave || 'inherit';\n    this.scope = null;\n    this.parentMeasure = null;\n    this.indexInMeasure = null;\n  }\n  init(scope, parentMeasure, indexInMeasure) {\n    this.scope = scope;\n    this.parentMeasure = parentMeasure;\n    this.indexInMeasure = indexInMeasure;\n  }\n  getTime() {\n    if(this.time.time === 'auto') {\n      return this.indexInMeasure + 1;\n    } else {\n      return this.time.time;\n    }\n  }\n  /**\n   * Normalize a chord into a form tonal can handle\n   * @param {string} chord\n   * @return {string}\n   */\n  normalizeChord(chord) {\n    return chord\n      .replace(/-/g, '_') // tonal uses _ over - for minor7\n      .replace(/minor|min/g, 'm'); // tonal is surprisingly bad at identifying minor chords??\n  }\n  chordToScaleName(chord) {\n    let chordType = _lib_tonal_min_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Chord.tokenize(chord)[1];\n\n    // @TODO: make this more robust\n    let names = _lib_tonal_min_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Chord.props(chordType).names;\n    if(names.includes('dim')) return 'diminished';\n    if(names.includes('aug')) return 'augmented';\n    if(names.includes('Major')) return 'major';\n    if(names.includes('minor')) return 'minor';\n    if(names.includes('minor7')) return 'dorian';\n    if(names.includes('Dominant')) return 'mixolydian';\n    // if none of the above match, do our best to find the closest fit\n    let closestScale = 'major'\n    names.forEach(name => {\n      if(name.startsWith('dim')) closestScale = 'diminished';\n      if(name.startsWith('aug')) closestScale = 'augmented';\n      if(name.startsWith('M')) closestScale = 'major';\n      if(name.startsWith('m')) closestScale = 'minor';\n    });\n    return closestScale;\n  };\n  getPitches(songIterator) { // should current chord be requested from measure?\n    let anchorChord, root;\n    \n    switch(this.pitch.anchor) {\n      case 'KEY': {\n        anchorChord = songIterator.song.getKey();\n        break;\n      }\n      case 'NEXT': {\n        let nextMeasure = songIterator.getRelative(1);\n        if(nextMeasure) {\n          anchorChord = nextMeasure[0];\n        } else {\n          anchorChord = songIterator.song.getKey();\n        }\n        break;\n      }\n      case 'STEP':\n      case 'ARPEGGIATE': { // @TODO\n        anchorChord = songIterator.getRelative(0)[0];\n        break;\n      }\n      default: {\n        // crawl backward through this measure to get the last set beat\n        let lastSetBeat = Math.floor(this.getTime());\n        do {\n          anchorChord = songIterator.getRelative(0)[lastSetBeat];\n          lastSetBeat--;\n        } while(!anchorChord);\n      }\n    }\n\n    anchorChord = this.normalizeChord(anchorChord);\n\n    let anchorTonic = _lib_tonal_min_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Chord.tokenize(anchorChord)[0]; // does this always work? *shrug*\n    let anchorScaleName = this.chordToScaleName(anchorChord);\n    let scalePCs = _lib_tonal_min_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Scale.notes(anchorTonic, anchorScaleName);\n    let rootPC = scalePCs[this.pitch.degree - 1];\n    root = _lib_tonal_min_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Note.from({oct: this.getOctave()}, rootPC);\n\n    if(this.pitch.chord) {\n      // this feels extremely incorrect\n      // why would anyone need it to work this way\n      let anchorChordType = _lib_tonal_min_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Chord.tokenize(anchorChord)[1];\n      return _lib_tonal_min_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Chord.notes(root, anchorChordType);\n    } else {\n      return [root];\n    }\n  }\n  getOctave() {\n    if(this.octave === 'inherit') {\n      return this.scope.vars.get('octave');\n    } else {\n      return this.octave;\n    }\n  }\n  getDuration() {\n    let duration;\n    duration = this.parentMeasure.calculateDurationAfter(this.indexInMeasure);\n    if(this.time.flag === 'STACCATO') {\n      // @TODO: how does one calculate staccatoness?\n    }\n    return duration;\n  }\n  getVolume() {\n    let volume = this.scope.vars.get('volume');\n    if(this.time.flag === 'ACCENTED') volume = Math.min(1, volume += .1);\n    return volume;\n  }\n  execute(songIterator) {\n    let notes = new _MIDI_Note_js__WEBPACK_IMPORTED_MODULE_1__[\"NoteSet\"]();\n    let time = this.getTime(); // @TODO: this varies with rolling\n    let pitches = this.getPitches(songIterator);\n    let duration = this.getDuration(); // @TODO: this varies with rolling\n    let volume = this.getVolume();\n    \n    for(let pitch of pitches) {\n      notes.push(new _MIDI_Note_js__WEBPACK_IMPORTED_MODULE_1__[\"Note\"]({\n        time: time,\n        pitch: pitch,\n        duration: duration,\n        volume: volume\n      }));\n    }\n    \n    return notes;\n  }\n}\n\nclass DrumBeatLiteral {\n  constructor(opts) {\n    this.time = opts.time;\n    this.accented = opts.accented || false;\n    this.scope = null;\n    this.parentMeasure = null;\n    this.indexInMeasure = null;\n  }\n  init(scope, parentMeasure, indexInMeasure) {\n    this.scope = scope;\n    this.parentMeasure = parentMeasure;\n    this.indexInMeasure = indexInMeasure;\n  }\n  getTime() {\n    return this.time;\n  }\n  getDuration() {\n    let duration;\n    duration = this.parentMeasure.calculateDurationAfter(this.indexInMeasure);\n    return duration;\n  }\n  getVolume() {\n    let volume = this.scope.vars.get('volume');\n    if(this.accented) volume = Math.min(1, volume += .1);\n    return volume;\n  }\n  execute(songIterator) {\n    let time = this.getTime();\n    let duration = this.getDuration();\n    let volume = this.getVolume();\n    \n    return new _MIDI_Note_js__WEBPACK_IMPORTED_MODULE_1__[\"NoteSet\"](\n      new _MIDI_Note_js__WEBPACK_IMPORTED_MODULE_1__[\"Note\"]({\n        time: time,\n        pitch: _MIDI_Note_js__WEBPACK_IMPORTED_MODULE_1__[\"AwaitingDrum\"],\n        duration: duration,\n        volume: volume\n      })\n    );\n  }\n}\n\n\n//# sourceURL=webpack:///./src/ast/BeatLiterals.js?");

/***/ }),

/***/ "./src/ast/ConfigStatements.js":
/*!*************************************!*\
  !*** ./src/ast/ConfigStatements.js ***!
  \*************************************/
/*! exports provided: MetaStatement, OptionsStatement, ImportStatement */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MetaStatement\", function() { return MetaStatement; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"OptionsStatement\", function() { return OptionsStatement; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ImportStatement\", function() { return ImportStatement; });\n/* harmony import */ var _Scope_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Scope.js */ \"./src/ast/Scope.js\");\n\n\nclass MetaStatement extends _Scope_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n  constructor(function_calls) {\n    super();\n    this.name = '@meta';\n    this.type = '@meta';\n    this.function_calls = function_calls;\n  }\n  init(scope) {\n    this.scope = scope;\n    \n    // nothing in here can be dynamic so resolve these at compile time\n    for(let function_call of this.function_calls) {\n      function_call.init(this);\n      function_call.execute();\n    }\n    \n    scope.meta = this.vars;\n  }\n}\n\nclass OptionsStatement extends _Scope_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n  constructor(function_calls) {\n    super();\n    this.name = '@options';\n    this.type = '@options';\n    this.function_calls = function_calls;\n  }\n  init(scope) {\n    \n    // nothing in here /should/ be dynamic so resolve these at compile time\n    for(let function_call of this.function_calls) {\n      function_call.init(this);\n      function_call.execute();\n    }\n    \n    this.scope = scope;\n    // in this case we're actually overwriting our scope's variables, not\n    // vise-versa\n    scope.vars = new Map([...scope.vars, ...this.vars]);\n  }\n}\n\nclass ImportStatement {\n  constructor(path, identifier) {\n    this.path = path;\n    this.identifier = identifier;\n  }\n}\n\n\n//# sourceURL=webpack:///./src/ast/ConfigStatements.js?");

/***/ }),

/***/ "./src/ast/FunctionCall.js":
/*!*********************************!*\
  !*** ./src/ast/FunctionCall.js ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return FunctionCall; });\n/* harmony import */ var _function_data_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./function_data.js */ \"./src/ast/function_data.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./errors.js */ \"./src/ast/errors.js\");\n\n\n\n/**\n * If the value is a FunctionCall, call it and return the returned value.\n * Otherwise, return the value itself.\n * @private\n */ // @TODO: if this is needed elsewhere, put it somewhere useful.\n\nclass FunctionCall {\n  /**\n   * @constructor\n   * @param {string} identifier The name of the function. Ideally it should\n   * match the name of one of the functions in function_data.js\n   */\n  constructor(identifier, args) {\n    this.identifier = identifier;\n    this.definition = _function_data_js__WEBPACK_IMPORTED_MODULE_0__[\"definitions\"].get(identifier);\n    this.args = args;\n    this.scope = null;\n  }\n  init(scope) {\n    this.scope = scope;\n    if(!this.definition) {\n      throw new _errors_js__WEBPACK_IMPORTED_MODULE_1__[\"FunctionNameError\"](this.identifier, this.scope);\n    }\n    this.returns = this.definition.returns;\n    _function_data_js__WEBPACK_IMPORTED_MODULE_0__[\"assertScope\"](this.identifier, this.definition.scope, this.scope);\n    \n    this.args.forEach(arg => {\n      if(arg.init) arg.init(scope);\n    });\n    \n    _function_data_js__WEBPACK_IMPORTED_MODULE_0__[\"assertArgTypes\"](this.identifier, this.args, this.definition.types, this.scope);\n  }\n  link(ASTs, parentStyle, parentTrack) {\n    this.args.forEach(arg => {\n      if(arg.link) arg.link(ASTs, parentStyle, parentTrack);\n    });\n  }\n  execute(songIterator) {\n    if(!this.scope) throw new Error('function not initialized :(');\n    let evaluated_args = this.args.map(arg => {\n      if(arg.execute) {\n        return arg.execute(songIterator);\n      } else {\n        return arg;\n      }\n    });\n    let return_value = this.definition.execute(evaluated_args, this.scope);\n    if(return_value === undefined) {\n      throw new Error(`Function \"${this.identifier}\" can return undefined`);\n    }\n    return return_value;\n  }\n}\n\n\n//# sourceURL=webpack:///./src/ast/FunctionCall.js?");

/***/ }),

/***/ "./src/ast/GlobalScope.js":
/*!********************************!*\
  !*** ./src/ast/GlobalScope.js ***!
  \********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return GlobalScope; });\n/* harmony import */ var _type_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./type_utils.js */ \"./src/ast/type_utils.js\");\n/* harmony import */ var _MIDI_Note_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../MIDI/Note.js */ \"./src/MIDI/Note.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./errors.js */ \"./src/ast/errors.js\");\n/* harmony import */ var _Scope_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Scope.js */ \"./src/ast/Scope.js\");\n/* harmony import */ var _ConfigStatements_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ConfigStatements.js */ \"./src/ast/ConfigStatements.js\");\n/* harmony import */ var _Track_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Track.js */ \"./src/ast/Track.js\");\n\n\n\n\n\n\n\nclass GlobalScope extends _Scope_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"] {\n  constructor(statements) {\n    super();\n    \n    this.name = 'global';\n    this.type = 'global';\n    \n    this.statements = statements;\n  }\n  \n  init() {\n    // set some default values\n    this.vars.set('octave', 2);\n    this.vars.set('volume', 1);\n    this.vars.set('private', false);\n    this.vars.set('time-signature', [4, 4]);\n    this.vars.set('tempo', 120);\n    \n    this.tracks = new Map();\n    this.meta = [];\n    // @TODO: stop circular dependencies? cache them and mark one as mom\n    this.importedStyles = new Map();\n    this.trackCalls = [];\n    this.dependencies = [];\n    \n    for(let statement of this.statements) {\n      if(statement instanceof _ConfigStatements_js__WEBPACK_IMPORTED_MODULE_4__[\"MetaStatement\"]\n        || statement instanceof _ConfigStatements_js__WEBPACK_IMPORTED_MODULE_4__[\"OptionsStatement\"]) {\n        // @TODO: make sure there's exactly 1 meta block\n        this.meta.push(statement);\n      } else if(statement instanceof _ConfigStatements_js__WEBPACK_IMPORTED_MODULE_4__[\"ImportStatement\"]) {\n        this.importedStyles.set(statement.identifier, statement.path);\n        this.dependencies.push(statement.path);\n      } else if(statement instanceof _Track_js__WEBPACK_IMPORTED_MODULE_5__[\"TrackStatement\"]) {\n        this.tracks.set(statement.name, statement);\n      } else if(statement instanceof _Track_js__WEBPACK_IMPORTED_MODULE_5__[\"TrackCall\"]) {\n        this.trackCalls.push(statement);\n      }\n    }\n    // handle meta blocks first since they set variables in own scope\n    this.meta.forEach(statement => statement.init(this));\n    \n    // -- handle importing before statements --\n    \n    this.tracks.forEach(statement => statement.init(this));\n  }\n  link(ASTs) {\n    for(let trackCall of this.trackCalls) {\n      // get path name of style\n      let importPath = this.importedStyles.get(trackCall.import);\n      \n      let ast = ASTs.get(importPath);\n      if(!ast) throw new _errors_js__WEBPACK_IMPORTED_MODULE_2__[\"NoSuchStyleError\"](trackCall.import, this);\n      let trackStatement = ast.tracks.get(trackCall.track);\n      if(!trackStatement) throw new _errors_js__WEBPACK_IMPORTED_MODULE_2__[\"NoSuchTrackError\"](\n        trackCall.import,\n        trackCall.track,\n        this);\n      //trackCall.trackStatement = trackStatement;\n      this.tracks.set(`${trackCall.import}.${trackCall.track}`, trackStatement);\n    }\n    \n    for(let [, track] of this.tracks) {\n      track.link(ASTs, this);\n    }\n  }\n  execute(songIterator) {\n    let trackNoteMap = new Map();\n    for(let [, track] of this.tracks) {\n      let trackNotes = track.execute(songIterator);\n      trackNoteMap.set(track.instrument, trackNotes);\n    }\n    return trackNoteMap;\n  }\n}\n\n\n//# sourceURL=webpack:///./src/ast/GlobalScope.js?");

/***/ }),

/***/ "./src/ast/Pattern.js":
/*!****************************!*\
  !*** ./src/ast/Pattern.js ***!
  \****************************/
/*! exports provided: PatternExpressionGroup, PatternStatement, PatternCall, JoinedPatternExpression */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PatternExpressionGroup\", function() { return PatternExpressionGroup; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PatternStatement\", function() { return PatternStatement; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PatternCall\", function() { return PatternCall; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"JoinedPatternExpression\", function() { return JoinedPatternExpression; });\n/* harmony import */ var _type_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./type_utils.js */ \"./src/ast/type_utils.js\");\n/* harmony import */ var _MIDI_Note_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../MIDI/Note.js */ \"./src/MIDI/Note.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./errors.js */ \"./src/ast/errors.js\");\n/* harmony import */ var _Scope_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Scope.js */ \"./src/ast/Scope.js\");\n/* harmony import */ var _FunctionCall_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./FunctionCall.js */ \"./src/ast/FunctionCall.js\");\n/* harmony import */ var _BeatGroups_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./BeatGroups.js */ \"./src/ast/BeatGroups.js\");\n\n\n\n\n\n\n\nclass PatternExpressionGroup extends _Scope_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"] {\n  constructor(expressions) {\n    super();\n    this.type = 'PatternExpressionGroup';\n    this.name = '@pattern(<anonymous>)';\n    \n    this.vars.set('private', false);\n    this.vars.set('chance', 1);\n    \n    this.expressions = expressions;\n    this.function_calls = [];\n    this.non_function_call_expressions = [];\n  }\n  init(scope, patternStatement = null) {\n    super.init(scope);\n    this.patternStatement = patternStatement;\n    if(this.patternStatement) {\n      this.name = `@pattern(${this.patternStatement})`;\n    }\n    this.expressions.forEach(expression => {\n      if(expression.init) {\n        expression.init(this);\n      } else {\n        throw ['expression not initialized:', expression];\n      }\n      if(expression instanceof _FunctionCall_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"]) {\n        this.function_calls.push(expression);\n      } else {\n        this.non_function_call_expressions.push(expression);\n      }\n    });\n  }\n  link(ASTs, parentStyle, parentTrack) {\n    this.expressions.forEach(expression => {\n      expression.link(ASTs, parentStyle, parentTrack);\n    });\n  }\n  execute(songIterator, callerIsTrack = false) {\n    let beats = _type_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"Nil\"];\n    for(let function_call of this.function_calls) {\n      let return_value = function_call.execute(songIterator);\n      if(return_value instanceof _MIDI_Note_js__WEBPACK_IMPORTED_MODULE_1__[\"NoteSet\"]) {\n        if(beats !== _type_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"Nil\"]) {\n          throw new _errors_js__WEBPACK_IMPORTED_MODULE_2__[\"TooManyBeatsError\"](this);\n        }\n        beats = return_value;\n      }\n    }\n    if(callerIsTrack && this.vars.get('private') === true) {\n      return _type_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"Nil\"]; // if it's private we can give up now\n    }\n    for(let expression of this.non_function_call_expressions) {\n      if(expression.execute) {\n        expression = expression.execute(songIterator);\n      }\n      if(expression instanceof _MIDI_Note_js__WEBPACK_IMPORTED_MODULE_1__[\"NoteSet\"]) {\n        if(beats !== _type_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"Nil\"]) {\n          throw new _errors_js__WEBPACK_IMPORTED_MODULE_2__[\"TooManyBeatsError\"](this);\n        }\n        beats = expression;\n      }\n    }\n    return beats\n  }\n}\n\nclass PatternStatement extends PatternExpressionGroup {\n  constructor(opts) {\n    if(opts.expression instanceof PatternExpressionGroup) {\n      // unroll the redundant expression group\n      super(opts.expression.expressions);\n    } else {\n      super([opts.expression]);\n    }\n    this.identifier = opts.identifier;\n    this.condition = (opts.condition !== undefined) ? opts.condition : null;\n  }\n  getChance() {\n    return this.vars.get('chance');\n  }\n  link(ASTs, parentStyle, parentTrack) {\n    super.link(ASTs, parentStyle, parentTrack);\n    if(this.condition && this.condition.link) {\n      this.condition.link(ASTs, parentStyle, parentTrack);\n    }\n  }\n  init(scope) {\n    super.init(scope);\n    if(this.condition && this.condition.init) this.condition.init(this);\n  }\n  execute(songIterator, callerIsTrack) {\n    if(this.condition) {\n      let condition_value = this.condition.execute();\n      if(Object(_type_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"cast_bool\"])(condition_value) === false) return _type_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"Nil\"];\n    }\n    return super.execute(songIterator, callerIsTrack);\n  }\n}\n\nclass PatternCall {\n  constructor(opts) {\n    this.import = opts.import || null;\n    this.track = opts.track || null;\n    this.pattern = opts.pattern;\n    this.scope = null;\n    this.patternStatement = null;\n    this.prettyprintname = (this.import || 'this') + '.' +\n      (this.track || 'this') + '.' +\n      this.pattern;\n  }\n  getChance() {\n    return this.patternStatement.getChance()();\n  }\n  init(scope) {\n    this.scope = scope;\n  }\n  link(ASTs, parentStyle, parentTrack) {\n    let ast;\n    if(this.import === null) {\n      ast = parentStyle\n    } else {\n      // get path name of style\n      let importPath = parentStyle.importedStyles.get(this.import);\n      ast = ASTs.get(importPath);\n      if(!ast) throw new NoSuchStyleError(this.import, this);\n    }\n    let track;\n    if(this.track === null) {\n      track = parentTrack;\n    } else {\n      track = ast.tracks.get(this.track);\n      if(!track) throw new NoSuchTrackError(\n        this.import || 'this',\n        this.track || 'this',\n        this);\n    }\n    let patternStatement = track.patterns.get(this.pattern);\n    if(!patternStatement) throw new NoSuchPatternError(\n      this.import || 'this',\n      this.track || 'this',\n      this.pattern,\n      this);\n    this.patternStatement = patternStatement;\n  }\n  execute(songIterator) {\n    // called patternStatement ignores private()\n    return this.patternStatement.execute(songIterator);\n  }\n}\n\nclass JoinedPatternExpression {\n  constructor(patterns) {\n    this.patterns = patterns;\n  }\n  init(scope) {\n    this.scope = scope;\n    this.patterns.forEach(pattern => {\n      if(pattern.init) pattern.init(scope);\n    });\n  }\n  link(ASTs, parentStyle, parentTrack) {\n    this.patterns.forEach(pattern => {\n      pattern.link(ASTs, parentStyle, parentTrack);\n    });\n  }\n  execute(songIterator) {\n    let noteSets = [];\n    for(let pattern of this.patterns) {\n      if(pattern.execute) {\n        pattern = pattern.execute(songIterator);\n      }\n      if(pattern instanceof _MIDI_Note_js__WEBPACK_IMPORTED_MODULE_1__[\"NoteSet\"]) {\n        noteSets.push(pattern);\n      }\n    }\n    if(noteSets.length) {\n      return (new _MIDI_Note_js__WEBPACK_IMPORTED_MODULE_1__[\"NoteSet\"]()).concat(...noteSets);\n    } else {\n      return _type_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"Nil\"];\n    }\n  }\n}\n\n\n//# sourceURL=webpack:///./src/ast/Pattern.js?");

/***/ }),

/***/ "./src/ast/Scope.js":
/*!**************************!*\
  !*** ./src/ast/Scope.js ***!
  \**************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Scope; });\n/*\n * In Playback styles, basically any pair of curly brackets defines a scope\n * which inherits settings from its parent scope but can overwrite them.\n */\nclass Scope {\n  constructor() {\n    this.vars = new Map();\n    this.name = null;\n    this.type = null;\n    this.scope = null;\n  }\n  init(scope) { // parent scope, if that's unclear\n    this.scope = scope;\n    \n    // in case this.vars was set in the constructor\n    this.vars = new Map([...this.scope.vars, ...this.vars]);\n  }\n}\n\n\n//# sourceURL=webpack:///./src/ast/Scope.js?");

/***/ }),

/***/ "./src/ast/Track.js":
/*!**************************!*\
  !*** ./src/ast/Track.js ***!
  \**************************/
/*! exports provided: TrackStatement, TrackCall */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TrackStatement\", function() { return TrackStatement; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TrackCall\", function() { return TrackCall; });\n/* harmony import */ var _type_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./type_utils.js */ \"./src/ast/type_utils.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./errors.js */ \"./src/ast/errors.js\");\n/* harmony import */ var _MIDI_Note_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../MIDI/Note.js */ \"./src/MIDI/Note.js\");\n/* harmony import */ var _Scope_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Scope.js */ \"./src/ast/Scope.js\");\n/* harmony import */ var _FunctionCall_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./FunctionCall.js */ \"./src/ast/FunctionCall.js\");\n/* harmony import */ var _Pattern_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Pattern.js */ \"./src/ast/Pattern.js\");\n\n\n\n\n\n\n\nclass TrackStatement extends _Scope_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"] {\n  constructor(opts) {\n    super();\n    this.name = opts.identifier;\n    this.type = '@track';\n    \n    this.instrument = opts.instrument;\n    this.identifier = opts.identifier;\n    this.members = opts.members;\n  }\n  init(scope) {\n    super.init(scope);\n    this.function_calls = [];\n    this.patterns = new Map();\n    this.patternCalls = [];\n    this.members.forEach(member => {\n      // initialize them all now, var inheritence is handled during execution\n      member.init(this);\n      if(member instanceof _FunctionCall_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"]) {\n        this.function_calls.push(member);\n      } else if(member instanceof _Pattern_js__WEBPACK_IMPORTED_MODULE_5__[\"PatternStatement\"]) {\n        this.patterns.set(member.identifier, member);\n      } else if(member instanceof _Pattern_js__WEBPACK_IMPORTED_MODULE_5__[\"PatternCall\"]) {\n        this.patternCalls.push(member);\n      }\n    });\n  }\n  link(ASTs, parentStyle) {\n    for(let patternCall of this.patternCalls) {\n      patternCall.link(ASTs, parentStyle, this);\n      this.patterns.set(patternCall.prettyprintname, patternCall);\n    }\n    \n    for(let [patternname, pattern] of this.patterns) {\n      pattern.link(ASTs, parentStyle, this);\n    }\n  }\n  execute(songIterator) {\n    console.log(`executing TrackStatement \"${this.name}\"`);\n    \n    this.function_calls.forEach(function_call => {\n      function_call.execute(songIterator);\n    });\n    \n    // https://stackoverflow.com/a/4463613/1784306\n    // I don't really understand the above explanation, this is probs wrong\n    let totalWeight = 0;\n    let weightedOptions = [];\n    for(let [patternname, pattern] of this.patterns) {\n      console.log(`- pattern \"${patternname}\":`);\n      // true = I'm the instrument so if you're private return Nil\n      let result = pattern.execute(songIterator, true);\n      console.log('  - Result:', result);\n      // @TODO: handle multi-measure patterns (via locks?)\n      if(result !== _type_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"Nil\"]) {\n        for(let note of result) {\n          if (note.pitch === _MIDI_Note_js__WEBPACK_IMPORTED_MODULE_2__[\"AwaitingDrum\"]) {\n            throw new _errors_js__WEBPACK_IMPORTED_MODULE_1__[\"DrumBeatInMelodicBeatGroupError\"](pattern);\n          }\n        }\n        \n        let chance = pattern.getChance();\n        weightedOptions.push({\n          noteSet: result,\n          lower: totalWeight,\n          upper: totalWeight + chance\n        });\n        totalWeight += chance;\n      }\n    }\n    // binary search would make sense here if I expected more items\n    let goal = Math.random() * totalWeight;\n    for(let option of weightedOptions) {\n      if(option.lower <= goal && goal <= option.upper) {\n        console.log('  - Final result:', option.noteSet);\n        return option.noteSet;\n      }\n    }\n    console.log('  - Final result:', _type_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"Nil\"]);\n    return _type_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"Nil\"];\n  }\n}\nclass TrackCall {\n  constructor(opts) {\n    this.import = opts.import;\n    this.track = opts.track;\n    this.trackStatement = null; // will be set by the loader.\n  }\n  execute(songIterator) {\n    this.trackStatement.execute(songIterator);\n  }\n}\n\n\n//# sourceURL=webpack:///./src/ast/Track.js?");

/***/ }),

/***/ "./src/ast/ast_nodes.js":
/*!******************************!*\
  !*** ./src/ast/ast_nodes.js ***!
  \******************************/
/*! exports provided: GlobalScope, MetaStatement, OptionsStatement, ImportStatement, TrackStatement, TrackCall, PatternStatement, PatternExpressionGroup, PatternCall, JoinedPatternExpression, FunctionCall, AnchorArgument, BooleanNot, BooleanAnd, BooleanOr, BeatGroupLiteral, Measure, DrumBeatGroupLiteral, MelodicBeatLiteral, DrumBeatLiteral */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _GlobalScope_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./GlobalScope.js */ \"./src/ast/GlobalScope.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"GlobalScope\", function() { return _GlobalScope_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]; });\n\n/* harmony import */ var _ConfigStatements_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ConfigStatements.js */ \"./src/ast/ConfigStatements.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"MetaStatement\", function() { return _ConfigStatements_js__WEBPACK_IMPORTED_MODULE_1__[\"MetaStatement\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"OptionsStatement\", function() { return _ConfigStatements_js__WEBPACK_IMPORTED_MODULE_1__[\"OptionsStatement\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"ImportStatement\", function() { return _ConfigStatements_js__WEBPACK_IMPORTED_MODULE_1__[\"ImportStatement\"]; });\n\n/* harmony import */ var _Track_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Track.js */ \"./src/ast/Track.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"TrackStatement\", function() { return _Track_js__WEBPACK_IMPORTED_MODULE_2__[\"TrackStatement\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"TrackCall\", function() { return _Track_js__WEBPACK_IMPORTED_MODULE_2__[\"TrackCall\"]; });\n\n/* harmony import */ var _Pattern_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Pattern.js */ \"./src/ast/Pattern.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"PatternStatement\", function() { return _Pattern_js__WEBPACK_IMPORTED_MODULE_3__[\"PatternStatement\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"PatternExpressionGroup\", function() { return _Pattern_js__WEBPACK_IMPORTED_MODULE_3__[\"PatternExpressionGroup\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"PatternCall\", function() { return _Pattern_js__WEBPACK_IMPORTED_MODULE_3__[\"PatternCall\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"JoinedPatternExpression\", function() { return _Pattern_js__WEBPACK_IMPORTED_MODULE_3__[\"JoinedPatternExpression\"]; });\n\n/* harmony import */ var _FunctionCall_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./FunctionCall.js */ \"./src/ast/FunctionCall.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"FunctionCall\", function() { return _FunctionCall_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"]; });\n\n/* harmony import */ var _ArgumentOperators_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ArgumentOperators.js */ \"./src/ast/ArgumentOperators.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"AnchorArgument\", function() { return _ArgumentOperators_js__WEBPACK_IMPORTED_MODULE_5__[\"AnchorArgument\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"BooleanNot\", function() { return _ArgumentOperators_js__WEBPACK_IMPORTED_MODULE_5__[\"BooleanNot\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"BooleanAnd\", function() { return _ArgumentOperators_js__WEBPACK_IMPORTED_MODULE_5__[\"BooleanAnd\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"BooleanOr\", function() { return _ArgumentOperators_js__WEBPACK_IMPORTED_MODULE_5__[\"BooleanOr\"]; });\n\n/* harmony import */ var _BeatGroups_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./BeatGroups.js */ \"./src/ast/BeatGroups.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"BeatGroupLiteral\", function() { return _BeatGroups_js__WEBPACK_IMPORTED_MODULE_6__[\"BeatGroupLiteral\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Measure\", function() { return _BeatGroups_js__WEBPACK_IMPORTED_MODULE_6__[\"Measure\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"DrumBeatGroupLiteral\", function() { return _BeatGroups_js__WEBPACK_IMPORTED_MODULE_6__[\"DrumBeatGroupLiteral\"]; });\n\n/* harmony import */ var _BeatLiterals_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./BeatLiterals.js */ \"./src/ast/BeatLiterals.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"MelodicBeatLiteral\", function() { return _BeatLiterals_js__WEBPACK_IMPORTED_MODULE_7__[\"MelodicBeatLiteral\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"DrumBeatLiteral\", function() { return _BeatLiterals_js__WEBPACK_IMPORTED_MODULE_7__[\"DrumBeatLiteral\"]; });\n\n/**\n * Constructors for most kinds of nodes in the AST (excuding strings and things\n * that can be represented more easily by their JS value).\n *\n * It's probably bad form/risky to parse directly to the form that's\n * interpreted. Eh.\n */\n\n\n\n\n\n\n\n\n\n\n\n\n\n//# sourceURL=webpack:///./src/ast/ast_nodes.js?");

/***/ }),

/***/ "./src/ast/errors.js":
/*!***************************!*\
  !*** ./src/ast/errors.js ***!
  \***************************/
/*! exports provided: ImportError, NoSuchStyleError, NoSuchTrackError, NoSuchPatternError, FunctionNameError, FunctionScopeError, FunctionArgumentsError, TooManyBeatsError, MelodicBeatInDrumBeatGroupError, DrumBeatInMelodicBeatGroupError */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ImportError\", function() { return ImportError; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NoSuchStyleError\", function() { return NoSuchStyleError; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NoSuchTrackError\", function() { return NoSuchTrackError; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NoSuchPatternError\", function() { return NoSuchPatternError; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FunctionNameError\", function() { return FunctionNameError; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FunctionScopeError\", function() { return FunctionScopeError; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FunctionArgumentsError\", function() { return FunctionArgumentsError; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TooManyBeatsError\", function() { return TooManyBeatsError; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MelodicBeatInDrumBeatGroupError\", function() { return MelodicBeatInDrumBeatGroupError; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DrumBeatInMelodicBeatGroupError\", function() { return DrumBeatInMelodicBeatGroupError; });\n// does this have to be an Error? idc\nclass PlaybackError extends Error {\n  constructor(message, scope) {\n    super(`${message}\\nScope: \"${scope.name}\"`)\n  }\n}\n\n/* Import-related errors */\nclass ImportError extends PlaybackError {\n  constructor() {\n    super(...arguments);\n  }\n}\nclass NoSuchStyleError extends ImportError {\n  constructor(identifier, scope) {\n    super(`No style with the name \"${identifier}\" was imported`, scope);\n  }\n}\nclass NoSuchTrackError extends ImportError {\n  constructor(style, track, scope) {\n    super(\n      `No track with the name \"${track}\" exists in the style \"${style}\"`,\n      scope);\n  }\n}\nclass NoSuchPatternError extends ImportError {\n  constructor(style, track, pattern, scope) {\n    super(\n      `Pattern \"${style}.${track}.${pattern}\" does not exist`,\n      scope);\n  }\n}\n\n/* Function-related errors */\nclass FunctionNameError extends PlaybackError {\n  constructor(identifier, scope) {\n    super(`No function exists with name \"${identifier}\"`, scope);\n  }\n}\nclass FunctionScopeError extends PlaybackError {\n  constructor(message, scope) {\n    super(message, scope);\n  }\n}\nclass FunctionArgumentsError extends PlaybackError {\n  constructor(message, scope) {\n    super(message, scope);\n  }\n}\n\n/* Pattern-related errors */\nclass TooManyBeatsError extends PlaybackError {\n  constructor(scope) {\n    super(\n      'Pattern may only contain 1 BeatGroup. Try the join operator \"&\"',\n      scope);\n  }\n}\n\n/* Beat-related errors*/\nclass MelodicBeatInDrumBeatGroupError extends PlaybackError {\n  constructor(scope) {\n    super('Unexpected Melodic Beat in a Drum Beat Group', scope);\n  }\n}\nclass DrumBeatInMelodicBeatGroupError extends PlaybackError {\n  constructor(scope) {\n    super('Unexpected Drum Beat in a Melodic Beat Group', scope);\n  }\n}\n\n\n//# sourceURL=webpack:///./src/ast/errors.js?");

/***/ }),

/***/ "./src/ast/function_data.js":
/*!**********************************!*\
  !*** ./src/ast/function_data.js ***!
  \**********************************/
/*! exports provided: assertArgTypes, assertScope, definitions */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"assertArgTypes\", function() { return assertArgTypes; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"assertScope\", function() { return assertScope; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"definitions\", function() { return definitions; });\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./errors.js */ \"./src/ast/errors.js\");\n/* harmony import */ var _FunctionCall_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./FunctionCall.js */ \"./src/ast/FunctionCall.js\");\n/* harmony import */ var _type_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./type_utils.js */ \"./src/ast/type_utils.js\");\n\n\n\n\nlet definitions = new Map();\n\n/**\n * Make an assertion about argument count and types.\n * @param {string} identifier The function name.\n * @param {Array} args The arguments passed to the function.\n * @param {Array.<string|Function>} types Array of the types (typeof) or classes\n * (instanceof) to expect.\n * @param {Scope} scope The scope, for error logging.\n */\nfunction assertArgTypes(identifier, args, types, scope) {\n  if(types == '*') return;\n  if(args.length != types.length) {\n    throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__[\"FunctionArgumentsError\"](`\"${identifier}\" requires ${types.length} arguments.`, scope);\n  }\n  for(let i in args) {\n    if(types[i] == '*') continue;\n    let arg = args[i];\n    if(arg instanceof _FunctionCall_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]) {\n      arg = arg.returns;\n      if(arg == '*') {\n        continue; // what's the correct functionality here? cry?\n      } else if(typeof types[i] == 'string') {\n        if(arg != types[i]) {\n          throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__[\"FunctionArgumentsError\"](`Argument ${Number(i)+1} of \"${identifier}\" must be a ${types[i]}.`, scope);\n        }\n      } else {\n        if(arg != types[i]) {\n          throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__[\"FunctionArgumentsError\"](`Argument ${Number(i)+1} of \"${identifier}\" must be a ${types[i].name}.`, scope);\n        }\n      }\n    } else {\n      if(typeof types[i] == 'string') {\n        if(typeof arg != types[i]) {\n          throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__[\"FunctionArgumentsError\"](`Argument ${Number(i)+1} of \"${identifier}\" must be a ${types[i]}.`, scope);\n        }\n      } else {\n        if(!(arg instanceof types[i])) {\n          throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__[\"FunctionArgumentsError\"](`Argument ${Number(i)+1} of \"${identifier}\" must be a ${types[i].name}.`, scope);\n        }\n      }\n    }\n  }\n}\n/**\n * Make an assertion about the scope in which the function is called.\n * @param {string} identifier The function's name.\n * @param {string='no-meta'} goalscope One of 4 string options:\n * - 'meta': the function throws if it's called outside a @meta block.\n * - 'options': the function throws if it's called outside an @options block.\n * - 'no-config': the function throws if it's called inside a @meta or @options\n *   block, but runs anywhere else that the parser will let you call a function.\n * - 'pattern': the function throws if called outside a pattern scope.\n * - 'no-meta' (default): the function throws if it's called inside a @meta\n *   block, but runs anywhere else that the parser will let you call a function.\n * @param {Scope} scope The calling scope.\n */\nfunction assertScope(identifier, goalscope = 'no-meta', scope) {\n  if(goalscope == 'meta') {\n    if(scope.type != '@meta') {\n      throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__[\"FunctionScopeError\"](`Function \"${identifier}\" must only be called within a @meta block.\"`, scope);\n    }\n  } else if(goalscope == 'options') {\n    if(scope.type != '@options') {\n      throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__[\"FunctionScopeError\"](`Function \"${identifier}\" must only be called within an @options block.\"`, scope);\n    }\n  } else if(goalscope == 'no-config') {\n    // ensure that config blocks can be resolved at compile time\n    if(scope.type == '@meta' || scope.type == '@options') {\n      throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__[\"FunctionScopeError\"](`Function \"${identifier}\" must not be called within a @meta or @options block.\"`, scope);\n    }\n  } else if(goalscope == 'pattern') { \n    if(scope.type != 'PatternExpressionGroup') {\n      throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__[\"FunctionScopeError\"](`Function \"${identifier}\" must only be called within a @pattern block.\"`, scope);\n    }\n    // @TODO: what about @pattern foo private() -- makes no sense but yea\n  } else if(goalscope == 'no-meta') { \n    if(scope.type == '@meta') {\n      throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__[\"FunctionScopeError\"](`Function \"${identifier}\" must not be called within a @meta block.\"`, scope);\n    }\n  }\n}\n/**\n * Define a function.\n * @param {string} identifier The name of the function.\n * @param {Object} opts Options passed. See below.\n * @param {Array.<string|Function>|string='*'} opts.types If set, throw error\n * unless the arguments passed to the function map to these. Can be strings\n * (typeof) or classes (instanceof), or the single string '*' to accept\n * anything. See assertArgTypes above.\n * @param {string='no-meta'} opts.scope Throw error unless the calling\n * scope matches. See assertScope above.\n * @param {string|Function|Nil='*'} opts.returns The return type. If set to '*'\n * it may return anything (for example, choose() returns one of whatever's\n * passed to it regardless of type).\n * @param {Function} func The function to run. It's passed 3 arguments:\n * - args: an array of the arguments passed in the Playback function call.\n * - scope: the calling scope. So it can set in scope.vars.\n * - argErr: a function. If the function does further testing on its\n *   arguments and there's an issue, pass this the error message and it throws.\n */\nlet define = function(identifier, opts, func) {\n  let definition = {\n    types: opts.types || '*',\n    returns: opts.returns || '*',\n    scope: opts.scope || 'no-meta',\n    execute: (args, scope) => {\n      let argErr = message => {\n        throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__[\"FunctionArgumentsError\"](message, scope);\n      };\n      return func(args, scope, argErr);\n    }\n  };\n  \n  definitions.set(identifier, definition);\n}\n\n/**\n * Quickly define a single-argument function that simply sets a var of the same\n * name in its parent scope.\n * @param {string} identifier The name of the function.\n * @param {string|Function} type Throw unless the argument is of this type (see\n * assertArgTypes above).\n * @param {?string=null} goalscope Throw error unless the calling scope matches.\n * See assertScope above.\n */\nlet defineVar = function(identifier, type, goalscope = null) {\n  let opts = {\n    types: [type],\n    scope: goalscope,\n    returns: _type_utils_js__WEBPACK_IMPORTED_MODULE_2__[\"Nil\"]\n  };\n  define(identifier, opts, (args, scope, argErr) => {\n    scope.vars.set(identifier, args[0]);\n    return _type_utils_js__WEBPACK_IMPORTED_MODULE_2__[\"Nil\"];\n  })\n}\n\n/**\n * Quickly define a function that sets a a var of the same name in its parent\n * scope. If it has 0 args it sets the var to true, if it has 1 boolean arg\n * it sets the var to that.\n * @param {string} identifier The name of the function.\n * @param {?string=null} goalscope Throw error unless the calling scope matches.\n * See assertScope above.\n */\nlet defineBoolean = function(identifier, goalscope = null) {\n  let opts = {\n    types: '*',\n    scopes: goalscope,\n    returns: _type_utils_js__WEBPACK_IMPORTED_MODULE_2__[\"Nil\"]\n  }\n  define(identifier, opts, (args, scope, argErr) => {\n    if(args.length) {\n      assertArgTypes(identifier, args, ['boolean'], scope);\n      scope.vars.set(identifier, args[0]);\n    } else {\n      scope.vars.set(identifier, true);\n    }\n    return _type_utils_js__WEBPACK_IMPORTED_MODULE_2__[\"Nil\"];\n  })\n}\n\n/*********** ACTUAL FUNCTION DEFINITIONS ***********/\n\n/*** @meta functions ***/\ndefineVar('name', 'string', 'meta');\ndefineVar('author', 'string', 'meta');\ndefineVar('description', 'string', 'meta');\ndefineVar('playback-version', 'number', 'meta');\n\n/*** @options functions ***/\ndefine('time-signature',\n  {\n    types: ['number', 'number'],\n    scope: 'options',\n    returns: _type_utils_js__WEBPACK_IMPORTED_MODULE_2__[\"Nil\"]\n  },\n  (args, scope, argErr) => {\n    if(!Number.isInteger(Math.log2(args[1]))) {\n      argErr('Argument 2 of \"time-signature\" must be a power of 2.');\n    }\n    scope.vars.set('time-signature', [args[0], args[1]]);\n    return _type_utils_js__WEBPACK_IMPORTED_MODULE_2__[\"Nil\"];\n  });\ndefineBoolean('swing', 'options');\n\n/*** anywhere but @meta functions ***/\ndefine('volume',\n  {\n    types: ['number'],\n    scope: 'no-meta',\n    returns: _type_utils_js__WEBPACK_IMPORTED_MODULE_2__[\"Nil\"]\n  },\n  (args, scope, argErr) => {\n    if(args[0] < 0 || args[0] > 1) {\n      argErr('Argument 1 of \"volume\" must be in range 0-1 (inclusive).');\n    }\n    scope.vars.set('volume', args[0]);\n    return _type_utils_js__WEBPACK_IMPORTED_MODULE_2__[\"Nil\"];\n  });\ndefineBoolean('invertible', 'no-meta');\ndefineVar('octave', 'number', 'no-meta');\n\n/*** anywhere but config functions (strictly dynamic functions) ***/\ndefine('choose',\n  {\n    types: '*',\n    scope: 'no-config',\n    returns: '*'\n  },\n  (args, scope, argErr) => {\n    let nonNilArgs = args.filter(arg => arg !== _type_utils_js__WEBPACK_IMPORTED_MODULE_2__[\"Nil\"]);\n    if(nonNilArgs.length) {\n      let index = Math.floor(Math.random() * nonNilArgs.length);\n      return nonNilArgs[index];\n    } else {\n      return _type_utils_js__WEBPACK_IMPORTED_MODULE_2__[\"Nil\"];\n    }\n  });\n\ndefine('progression',\n  {\n    types: '*',\n    scope: 'no-config',\n    returns: 'boolean'\n  },\n  (args, scope, argErr) => {\n    return true; // @TODO\n  });\ndefine('in-scale',\n  {\n    types: '*',\n    scope: 'no-config',\n    returns: 'boolean'\n  },\n  (args, scope, argErr) => {\n    return false; // @TODO\n  });\n\n/*** pattern-only functions ***/\ndefineBoolean('private', 'pattern');\ndefineVar('length', 'number', 'pattern');\ndefine('chance',\n  {\n    types: ['number'],\n    scope: 'pattern',\n    returns: _type_utils_js__WEBPACK_IMPORTED_MODULE_2__[\"Nil\"]\n  },\n  (args, scope, argErr) => {\n    if(args[0] < 0 || args[0] > 1) {\n      argErr('Argument 1 of \"chance\" must be in range 0-1 (inclusive).');\n    }\n    scope.vars.set('chance', args[0]);\n    return _type_utils_js__WEBPACK_IMPORTED_MODULE_2__[\"Nil\"];\n  });\n\n\n\n\n//# sourceURL=webpack:///./src/ast/function_data.js?");

/***/ }),

/***/ "./src/ast/type_utils.js":
/*!*******************************!*\
  !*** ./src/ast/type_utils.js ***!
  \*******************************/
/*! exports provided: Nil, cast_bool */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Nil\", function() { return Nil; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"cast_bool\", function() { return cast_bool; });\nlet Nil = Symbol('Nil');\nlet cast_bool = function(arg) {\n  if(arg === Nil || arg === false) {\n    return false;\n  } else {\n    return true;\n  }\n}\n\n\n\n\n//# sourceURL=webpack:///./src/ast/type_utils.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! exports provided: PlaybackStyle */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _PlaybackStyle_PlaybackStyle_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PlaybackStyle/PlaybackStyle.js */ \"./src/PlaybackStyle/PlaybackStyle.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"PlaybackStyle\", function() { return _PlaybackStyle_PlaybackStyle_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]; });\n\n//import {load} from './loader/loader.js';\n//import {parse} from './parser/parser.js';\n\n\n\n\n\n//# sourceURL=webpack:///./src/index.js?");

/***/ }),

/***/ "./src/lexer/lexer.js":
/*!****************************!*\
  !*** ./src/lexer/lexer.js ***!
  \****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _lib_moo_moo_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/moo/moo.js */ \"./src/lib/moo/moo.js\");\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (_lib_moo_moo_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].states({\n  main: {\n    comment: {\n      match:/\\/\\/.*?(?:\\n|$)/, // consuming newline should be fine since this is _?. Can I do eof anchor here? Guess we'll find out \n      lineBreaks: true\n    },\n    quoted_string: /\"(?:[^\\\\\"\\n]|\\\\.)*\"/, // thanx https://stackoverflow.com/a/249937/1784306\n    ws: {\n      match: /\\s+/,\n      lineBreaks: true\n    },\n    at_rule: ['@meta', '@options', '@import', '@track', '@pattern'],\n    identifier: {\n      // start with alpha, may contain digits and dashes but not end with dash\n      match: /[a-zA-z](?:[a-zA-Z\\-\\d]*[a-zA-Z\\d])?/,\n      keywords: {\n        keyword: ['if', 'as'],\n        boolean: ['true', 'false']\n      }\n    },\n    number: /(?:\\d*\\.)?\\d+/,\n    brackets: ['{', '}', '(', ')'],\n    left_angle: {match: '<', push: 'beat'},\n    operators: ['&', '+', '-', '*', '/', '.']\n  },\n  beat: {\n    beat_ws: / +/,\n    beat_colon: ':',\n    beat_number: /(?:\\d*\\.)?\\d+/,\n    beat_flag: /[a-zA-Z]/,\n    beat_right_angle: {match: '>', pop: true},\n    beat_operators: ['|', '+', '-', '*', '/']\n  }\n}));\n\n\n//# sourceURL=webpack:///./src/lexer/lexer.js?");

/***/ }),

/***/ "./src/lib/moo/moo.js":
/*!****************************!*\
  !*** ./src/lib/moo/moo.js ***!
  \****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = ((function() {\n  'use strict';\n\n  var hasOwnProperty = Object.prototype.hasOwnProperty\n\n  // polyfill assign(), so we support IE9+\n  var assign = typeof Object.assign === 'function' ? Object.assign :\n    // https://tc39.github.io/ecma262/#sec-object.assign\n    function(target, sources) {\n      if (target == null) {\n        throw new TypeError('Target cannot be null or undefined');\n      }\n      target = Object(target)\n\n      for (var i = 1; i < arguments.length; i++) {\n        var source = arguments[i]\n        if (source == null) continue\n\n        for (var key in source) {\n          if (hasOwnProperty.call(source, key)) {\n            target[key] = source[key]\n          }\n        }\n      }\n      return target\n    }\n\n  var hasSticky = typeof new RegExp().sticky === 'boolean'\n\n  /***************************************************************************/\n\n  function isRegExp(o) { return o && o.constructor === RegExp }\n  function isObject(o) { return o && typeof o === 'object' && o.constructor !== RegExp && !Array.isArray(o) }\n\n  function reEscape(s) {\n    return s.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&')\n  }\n  function reGroups(s) {\n    var re = new RegExp('|' + s)\n    return re.exec('').length - 1\n  }\n  function reCapture(s) {\n    return '(' + s + ')'\n  }\n  function reUnion(regexps) {\n    var source =  regexps.map(function(s) {\n      return \"(?:\" + s + \")\"\n    }).join('|')\n    return \"(?:\" + source + \")\"\n  }\n\n  function regexpOrLiteral(obj) {\n    if (typeof obj === 'string') {\n      return '(?:' + reEscape(obj) + ')'\n\n    } else if (isRegExp(obj)) {\n      // TODO: consider /u support\n      if (obj.ignoreCase) { throw new Error('RegExp /i flag not allowed') }\n      if (obj.global) { throw new Error('RegExp /g flag is implied') }\n      if (obj.sticky) { throw new Error('RegExp /y flag is implied') }\n      if (obj.multiline) { throw new Error('RegExp /m flag is implied') }\n      return obj.source\n\n    } else {\n      throw new Error('not a pattern: ' + obj)\n    }\n  }\n\n  function objectToRules(object) {\n    var keys = Object.getOwnPropertyNames(object)\n    var result = []\n    for (var i=0; i<keys.length; i++) {\n      var key = keys[i]\n      var thing = object[key]\n      var rules = Array.isArray(thing) ? thing : [thing]\n      var match = []\n      rules.forEach(function(rule) {\n        if (isObject(rule)) {\n          if (match.length) result.push(ruleOptions(key, match))\n          result.push(ruleOptions(key, rule))\n          match = []\n        } else {\n          match.push(rule)\n        }\n      })\n      if (match.length) result.push(ruleOptions(key, match))\n    }\n    return result\n  }\n\n  function arrayToRules(array) {\n    var result = []\n    for (var i=0; i<array.length; i++) {\n      var obj = array[i]\n      if (!obj.name) {\n        throw new Error('Rule has no name: ' + JSON.stringify(obj))\n      }\n      result.push(ruleOptions(obj.name, obj))\n    }\n    return result\n  }\n\n  function ruleOptions(name, obj) {\n    if (typeof obj !== 'object' || Array.isArray(obj) || isRegExp(obj)) {\n      obj = { match: obj }\n    }\n\n    // nb. error implies lineBreaks\n    var options = assign({\n      tokenType: name,\n      lineBreaks: !!obj.error,\n      pop: false,\n      next: null,\n      push: null,\n      error: false,\n      value: null,\n      getType: null,\n    }, obj)\n\n    // convert to array\n    var match = options.match\n    options.match = Array.isArray(match) ? match : match ? [match] : []\n    options.match.sort(function(a, b) {\n      return isRegExp(a) && isRegExp(b) ? 0\n           : isRegExp(b) ? -1 : isRegExp(a) ? +1 : b.length - a.length\n    })\n    if (options.keywords) {\n      options.getType = keywordTransform(options.keywords)\n    }\n    return options\n  }\n\n  function compileRules(rules, hasStates) {\n    rules = Array.isArray(rules) ? arrayToRules(rules) : objectToRules(rules)\n\n    var errorRule = null\n    var groups = []\n    var parts = []\n    for (var i=0; i<rules.length; i++) {\n      var options = rules[i]\n\n      if (options.error) {\n        if (errorRule) {\n          throw new Error(\"Multiple error rules not allowed: (for token '\" + options.tokenType + \"')\")\n        }\n        errorRule = options\n      }\n\n      // skip rules with no match\n      if (options.match.length === 0) {\n        continue\n      }\n      groups.push(options)\n\n      // convert to RegExp\n      var pat = reUnion(options.match.map(regexpOrLiteral))\n\n      // validate\n      var regexp = new RegExp(pat)\n      if (regexp.test(\"\")) {\n        throw new Error(\"RegExp matches empty string: \" + regexp)\n      }\n      var groupCount = reGroups(pat)\n      if (groupCount > 0) {\n        throw new Error(\"RegExp has capture groups: \" + regexp + \"\\nUse (?:  ) instead\")\n      }\n      if (!hasStates && (options.pop || options.push || options.next)) {\n        throw new Error(\"State-switching options are not allowed in stateless lexers (for token '\" + options.tokenType + \"')\")\n      }\n\n      // try and detect rules matching newlines\n      if (!options.lineBreaks && regexp.test('\\n')) {\n        throw new Error('Rule should declare lineBreaks: ' + regexp)\n      }\n\n      // store regex\n      parts.push(reCapture(pat))\n    }\n\n    var suffix = hasSticky ? '' : '|(?:)'\n    var flags = hasSticky ? 'ym' : 'gm'\n    var combined = new RegExp(reUnion(parts) + suffix, flags)\n\n    return {regexp: combined, groups: groups, error: errorRule}\n  }\n\n  function compile(rules) {\n    var result = compileRules(rules)\n    return new Lexer({start: result}, 'start')\n  }\n\n  function compileStates(states, start) {\n    var keys = Object.getOwnPropertyNames(states)\n    if (!start) start = keys[0]\n\n    var map = Object.create(null)\n    for (var i=0; i<keys.length; i++) {\n      var key = keys[i]\n      map[key] = compileRules(states[key], true)\n    }\n\n    for (var i=0; i<keys.length; i++) {\n      var groups = map[keys[i]].groups\n      for (var j=0; j<groups.length; j++) {\n        var g = groups[j]\n        var state = g && (g.push || g.next)\n        if (state && !map[state]) {\n          throw new Error(\"Missing state '\" + state + \"' (in token '\" + g.tokenType + \"' of state '\" + keys[i] + \"')\")\n        }\n        if (g && g.pop && +g.pop !== 1) {\n          throw new Error(\"pop must be 1 (in token '\" + g.tokenType + \"' of state '\" + keys[i] + \"')\")\n        }\n      }\n    }\n\n    return new Lexer(map, start)\n  }\n\n  function keywordTransform(map) {\n    var reverseMap = Object.create(null)\n    var byLength = Object.create(null)\n    var types = Object.getOwnPropertyNames(map)\n    for (var i=0; i<types.length; i++) {\n      var tokenType = types[i]\n      var item = map[tokenType]\n      var keywordList = Array.isArray(item) ? item : [item]\n      keywordList.forEach(function(keyword) {\n        (byLength[keyword.length] = byLength[keyword.length] || []).push(keyword)\n        if (typeof keyword !== 'string') {\n          throw new Error(\"keyword must be string (in keyword '\" + tokenType + \"')\")\n        }\n        reverseMap[keyword] = tokenType\n      })\n    }\n\n    // fast string lookup\n    // https://jsperf.com/string-lookups\n    function str(x) { return JSON.stringify(x) }\n    var source = ''\n    source += '(function(value) {\\n'\n    source += 'switch (value.length) {\\n'\n    for (var length in byLength) {\n      var keywords = byLength[length]\n      source += 'case ' + length + ':\\n'\n      source += 'switch (value) {\\n'\n      keywords.forEach(function(keyword) {\n        var tokenType = reverseMap[keyword]\n        source += 'case ' + str(keyword) + ': return ' + str(tokenType) + '\\n'\n      })\n      source += '}\\n'\n    }\n    source += '}\\n'\n    source += '})'\n    return eval(source) // getType\n  }\n\n  /***************************************************************************/\n\n  var Lexer = function(states, state) {\n    this.startState = state\n    this.states = states\n    this.buffer = ''\n    this.stack = []\n    this.reset()\n  }\n\n  Lexer.prototype.reset = function(data, info) {\n    this.buffer = data || ''\n    this.index = 0\n    this.line = info ? info.line : 1\n    this.col = info ? info.col : 1\n    this.setState(info ? info.state : this.startState)\n    return this\n  }\n\n  Lexer.prototype.save = function() {\n    return {\n      line: this.line,\n      col: this.col,\n      state: this.state,\n    }\n  }\n\n  Lexer.prototype.setState = function(state) {\n    if (!state || this.state === state) return\n    this.state = state\n    var info = this.states[state]\n    this.groups = info.groups\n    this.error = info.error || {lineBreaks: true, shouldThrow: true}\n    this.re = info.regexp\n  }\n\n  Lexer.prototype.popState = function() {\n    this.setState(this.stack.pop())\n  }\n\n  Lexer.prototype.pushState = function(state) {\n    this.stack.push(this.state)\n    this.setState(state)\n  }\n\n  Lexer.prototype._eat = hasSticky ? function(re) { // assume re is /y\n    return re.exec(this.buffer)\n  } : function(re) { // assume re is /g\n    var match = re.exec(this.buffer)\n    // will always match, since we used the |(?:) trick\n    if (match[0].length === 0) {\n      return null\n    }\n    return match\n  }\n\n  Lexer.prototype._getGroup = function(match) {\n    if (match === null) {\n      return -1\n    }\n\n    var groupCount = this.groups.length\n    for (var i = 0; i < groupCount; i++) {\n      if (match[i + 1] !== undefined) {\n        return i\n      }\n    }\n    throw new Error('oops')\n  }\n\n  function tokenToString() {\n    return this.value\n  }\n\n  Lexer.prototype.next = function() {\n    var re = this.re\n    var buffer = this.buffer\n\n    var index = re.lastIndex = this.index\n    if (index === buffer.length) {\n      return // EOF\n    }\n\n    var match = this._eat(re)\n    var i = this._getGroup(match)\n\n    var group, text\n    if (i === -1) {\n      group = this.error\n\n      // consume rest of buffer\n      text = buffer.slice(index)\n\n    } else {\n      text = match[0]\n      group = this.groups[i]\n    }\n\n    // count line breaks\n    var lineBreaks = 0\n    if (group.lineBreaks) {\n      var matchNL = /\\n/g\n      var nl = 1\n      if (text === '\\n') {\n        lineBreaks = 1\n      } else {\n        while (matchNL.exec(text)) { lineBreaks++; nl = matchNL.lastIndex }\n      }\n    }\n\n    var token = {\n      type: (group.getType && group.getType(text)) || group.tokenType,\n      value: group.value ? group.value(text) : text,\n      text: text,\n      toString: tokenToString,\n      offset: index,\n      lineBreaks: lineBreaks,\n      line: this.line,\n      col: this.col,\n    }\n    // nb. adding more props to token object will make V8 sad!\n\n    var size = text.length\n    this.index += size\n    this.line += lineBreaks\n    if (lineBreaks !== 0) {\n      this.col = size - nl + 1\n    } else {\n      this.col += size\n    }\n    // throw, if no rule with {error: true}\n    if (group.shouldThrow) {\n      throw new Error(this.formatError(token, \"invalid syntax\"))\n    }\n\n    if (group.pop) this.popState()\n    else if (group.push) this.pushState(group.push)\n    else if (group.next) this.setState(group.next)\n    return token\n  }\n\n  if (typeof Symbol !== 'undefined' && Symbol.iterator) {\n    var LexerIterator = function(lexer) {\n      this.lexer = lexer\n    }\n\n    LexerIterator.prototype.next = function() {\n      var token = this.lexer.next()\n      return {value: token, done: !token}\n    }\n\n    LexerIterator.prototype[Symbol.iterator] = function() {\n      return this\n    }\n\n    Lexer.prototype[Symbol.iterator] = function() {\n      return new LexerIterator(this)\n    }\n  }\n\n  Lexer.prototype.formatError = function(token, message) {\n    var value = token.value\n    var index = token.offset\n    var eol = token.lineBreaks ? value.indexOf('\\n') : value.length\n    var start = Math.max(0, index - token.col + 1)\n    var firstLine = this.buffer.substring(start, index + eol)\n    message += \" at line \" + token.line + \" col \" + token.col + \":\\n\\n\"\n    message += \"  \" + firstLine + \"\\n\"\n    message += \"  \" + Array(token.col).join(\" \") + \"^\"\n    return message\n  }\n\n  Lexer.prototype.clone = function() {\n    return new Lexer(this.states, this.state)\n  }\n\n  Lexer.prototype.has = function(tokenType) {\n    for (var s in this.states) {\n      var groups = this.states[s].groups\n      for (var i=0; i<groups.length; i++) {\n        var group = groups[i]\n        if (group.tokenType === tokenType) return true\n        if (group.keywords && hasOwnProperty.call(group.keywords, tokenType)) {\n          return true\n        }\n      }\n    }\n    return false\n  }\n\n\n  return {\n    compile: compile,\n    states: compileStates,\n    error: Object.freeze({error: true}),\n  }\n\n})());\n\n\n//# sourceURL=webpack:///./src/lib/moo/moo.js?");

/***/ }),

/***/ "./src/lib/nearley/nearley.js":
/*!************************************!*\
  !*** ./src/lib/nearley/nearley.js ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = ((function() {\n\n    function Rule(name, symbols, postprocess) {\n        this.id = ++Rule.highestId;\n        this.name = name;\n        this.symbols = symbols;        // a list of literal | regex class | nonterminal\n        this.postprocess = postprocess;\n        return this;\n    }\n    Rule.highestId = 0;\n\n    Rule.prototype.toString = function(withCursorAt) {\n        function stringifySymbolSequence (e) {\n            return e.literal ? JSON.stringify(e.literal) :\n                   e.type ? '%' + e.type : e.toString();\n        }\n        var symbolSequence = (typeof withCursorAt === \"undefined\")\n                             ? this.symbols.map(stringifySymbolSequence).join(' ')\n                             : (   this.symbols.slice(0, withCursorAt).map(stringifySymbolSequence).join(' ')\n                                 + \"  \"\n                                 + this.symbols.slice(withCursorAt).map(stringifySymbolSequence).join(' ')     );\n        return this.name + \"  \" + symbolSequence;\n    }\n\n\n    // a State is a rule at a position from a given starting point in the input stream (reference)\n    function State(rule, dot, reference, wantedBy) {\n        this.rule = rule;\n        this.dot = dot;\n        this.reference = reference;\n        this.data = [];\n        this.wantedBy = wantedBy;\n        this.isComplete = this.dot === rule.symbols.length;\n    }\n\n    State.prototype.toString = function() {\n        return \"{\" + this.rule.toString(this.dot) + \"}, from: \" + (this.reference || 0);\n    };\n\n    State.prototype.nextState = function(child) {\n        var state = new State(this.rule, this.dot + 1, this.reference, this.wantedBy);\n        state.left = this;\n        state.right = child;\n        if (state.isComplete) {\n            state.data = state.build();\n        }\n        return state;\n    };\n\n    State.prototype.build = function() {\n        var children = [];\n        var node = this;\n        do {\n            children.push(node.right.data);\n            node = node.left;\n        } while (node.left);\n        children.reverse();\n        return children;\n    };\n\n    State.prototype.finish = function() {\n        if (this.rule.postprocess) {\n            this.data = this.rule.postprocess(this.data, this.reference, Parser.fail);\n        }\n    };\n\n\n    function Column(grammar, index) {\n        this.grammar = grammar;\n        this.index = index;\n        this.states = [];\n        this.wants = {}; // states indexed by the non-terminal they expect\n        this.scannable = []; // list of states that expect a token\n        this.completed = {}; // states that are nullable\n    }\n\n\n    Column.prototype.process = function(nextColumn) {\n        var states = this.states;\n        var wants = this.wants;\n        var completed = this.completed;\n\n        for (var w = 0; w < states.length; w++) { // nb. we push() during iteration\n            var state = states[w];\n\n            if (state.isComplete) {\n                state.finish();\n                if (state.data !== Parser.fail) {\n                    // complete\n                    var wantedBy = state.wantedBy;\n                    for (var i = wantedBy.length; i--; ) { // this line is hot\n                        var left = wantedBy[i];\n                        this.complete(left, state);\n                    }\n\n                    // special-case nullables\n                    if (state.reference === this.index) {\n                        // make sure future predictors of this rule get completed.\n                        var exp = state.rule.name;\n                        (this.completed[exp] = this.completed[exp] || []).push(state);\n                    }\n                }\n\n            } else {\n                // queue scannable states\n                var exp = state.rule.symbols[state.dot];\n                if (typeof exp !== 'string') {\n                    this.scannable.push(state);\n                    continue;\n                }\n\n                // predict\n                if (wants[exp]) {\n                    wants[exp].push(state);\n\n                    if (completed.hasOwnProperty(exp)) {\n                        var nulls = completed[exp];\n                        for (var i = 0; i < nulls.length; i++) {\n                            var right = nulls[i];\n                            this.complete(state, right);\n                        }\n                    }\n                } else {\n                    wants[exp] = [state];\n                    this.predict(exp);\n                }\n            }\n        }\n    }\n\n    Column.prototype.predict = function(exp) {\n        var rules = this.grammar.byName[exp] || [];\n\n        for (var i = 0; i < rules.length; i++) {\n            var r = rules[i];\n            var wantedBy = this.wants[exp];\n            var s = new State(r, 0, this.index, wantedBy);\n            this.states.push(s);\n        }\n    }\n\n    Column.prototype.complete = function(left, right) {\n        var copy = left.nextState(right);\n        this.states.push(copy);\n    }\n\n\n    function Grammar(rules, start) {\n        this.rules = rules;\n        this.start = start || this.rules[0].name;\n        var byName = this.byName = {};\n        this.rules.forEach(function(rule) {\n            if (!byName.hasOwnProperty(rule.name)) {\n                byName[rule.name] = [];\n            }\n            byName[rule.name].push(rule);\n        });\n    }\n\n    // So we can allow passing (rules, start) directly to Parser for backwards compatibility\n    Grammar.fromCompiled = function(rules, start) {\n        var lexer = rules.Lexer;\n        if (rules.ParserStart) {\n          start = rules.ParserStart;\n          rules = rules.ParserRules;\n        }\n        var rules = rules.map(function (r) { return (new Rule(r.name, r.symbols, r.postprocess)); });\n        var g = new Grammar(rules, start);\n        g.lexer = lexer; // nb. storing lexer on Grammar is iffy, but unavoidable\n        return g;\n    }\n\n\n    function StreamLexer() {\n      this.reset(\"\");\n    }\n\n    StreamLexer.prototype.reset = function(data, state) {\n        this.buffer = data;\n        this.index = 0;\n        this.line = state ? state.line : 1;\n        this.lastLineBreak = state ? -state.col : 0;\n    }\n\n    StreamLexer.prototype.next = function() {\n        if (this.index < this.buffer.length) {\n            var ch = this.buffer[this.index++];\n            if (ch === '\\n') {\n              this.line += 1;\n              this.lastLineBreak = this.index;\n            }\n            return {value: ch};\n        }\n    }\n\n    StreamLexer.prototype.save = function() {\n      return {\n        line: this.line,\n        col: this.index - this.lastLineBreak,\n      }\n    }\n\n    StreamLexer.prototype.formatError = function(token, message) {\n        // nb. this gets called after consuming the offending token,\n        // so the culprit is index-1\n        var buffer = this.buffer;\n        if (typeof buffer === 'string') {\n            var nextLineBreak = buffer.indexOf('\\n', this.index);\n            if (nextLineBreak === -1) nextLineBreak = buffer.length;\n            var line = buffer.substring(this.lastLineBreak, nextLineBreak)\n            var col = this.index - this.lastLineBreak;\n            message += \" at line \" + this.line + \" col \" + col + \":\\n\\n\";\n            message += \"  \" + line + \"\\n\"\n            message += \"  \" + Array(col).join(\" \") + \"^\"\n            return message;\n        } else {\n            return message + \" at index \" + (this.index - 1);\n        }\n    }\n\n\n    function Parser(rules, start, options) {\n        if (rules instanceof Grammar) {\n            var grammar = rules;\n            var options = start;\n        } else {\n            var grammar = Grammar.fromCompiled(rules, start);\n        }\n        this.grammar = grammar;\n\n        // Read options\n        this.options = {\n            keepHistory: false,\n            lexer: grammar.lexer || new StreamLexer,\n        };\n        for (var key in (options || {})) {\n            this.options[key] = options[key];\n        }\n\n        // Setup lexer\n        this.lexer = this.options.lexer;\n        this.lexerState = undefined;\n\n        // Setup a table\n        var column = new Column(grammar, 0);\n        var table = this.table = [column];\n\n        // I could be expecting anything.\n        column.wants[grammar.start] = [];\n        column.predict(grammar.start);\n        // TODO what if start rule is nullable?\n        column.process();\n        this.current = 0; // token index\n    }\n\n    // create a reserved token for indicating a parse fail\n    Parser.fail = {};\n\n    Parser.prototype.feed = function(chunk) {\n        var lexer = this.lexer;\n        lexer.reset(chunk, this.lexerState);\n\n        var token;\n        while (token = lexer.next()) {\n            // We add new states to table[current+1]\n            var column = this.table[this.current];\n\n            // GC unused states\n            if (!this.options.keepHistory) {\n                delete this.table[this.current - 1];\n            }\n\n            var n = this.current + 1;\n            var nextColumn = new Column(this.grammar, n);\n            this.table.push(nextColumn);\n\n            // Advance all tokens that expect the symbol\n            var literal = token.value;\n            var value = lexer.constructor === StreamLexer ? token.value : token;\n            var scannable = column.scannable;\n            for (var w = scannable.length; w--; ) {\n                var state = scannable[w];\n                var expect = state.rule.symbols[state.dot];\n                // Try to consume the token\n                // either regex or literal\n                if (expect.test ? expect.test(value) :\n                    expect.type ? expect.type === token.type\n                                : expect.literal === literal) {\n                    // Add it\n                    var next = state.nextState({data: value, token: token, isToken: true, reference: n - 1});\n                    nextColumn.states.push(next);\n                }\n            }\n\n            // Next, for each of the rules, we either\n            // (a) complete it, and try to see if the reference row expected that\n            //     rule\n            // (b) predict the next nonterminal it expects by adding that\n            //     nonterminal's start state\n            // To prevent duplication, we also keep track of rules we have already\n            // added\n\n            nextColumn.process();\n\n            // If needed, throw an error:\n            if (nextColumn.states.length === 0) {\n                // No states at all! This is not good.\n                var message = this.lexer.formatError(token, \"invalid syntax\") + \"\\n\";\n                message += \"Unexpected \" + (token.type ? token.type + \" token: \" : \"\");\n                message += JSON.stringify(token.value !== undefined ? token.value : token) + \"\\n\";\n                var err = new Error(message);\n                err.offset = this.current;\n                err.token = token;\n                throw err;\n            }\n\n            // maybe save lexer state\n            if (this.options.keepHistory) {\n              column.lexerState = lexer.save()\n            }\n\n            this.current++;\n        }\n        if (column) {\n          this.lexerState = lexer.save()\n        }\n\n        // Incrementally keep track of results\n        this.results = this.finish();\n\n        // Allow chaining, for whatever it's worth\n        return this;\n    };\n\n    Parser.prototype.save = function() {\n        var column = this.table[this.current];\n        column.lexerState = this.lexerState;\n        return column;\n    };\n\n    Parser.prototype.restore = function(column) {\n        var index = column.index;\n        this.current = index;\n        this.table[index] = column;\n        this.table.splice(index + 1);\n        this.lexerState = column.lexerState;\n\n        // Incrementally keep track of results\n        this.results = this.finish();\n    };\n\n    // nb. deprecated: use save/restore instead!\n    Parser.prototype.rewind = function(index) {\n        if (!this.options.keepHistory) {\n            throw new Error('set option `keepHistory` to enable rewinding')\n        }\n        // nb. recall column (table) indicies fall between token indicies.\n        //        col 0   --   token 0   --   col 1\n        this.restore(this.table[index]);\n    };\n\n    Parser.prototype.finish = function() {\n        // Return the possible parsings\n        var considerations = [];\n        var start = this.grammar.start;\n        var column = this.table[this.table.length - 1]\n        column.states.forEach(function (t) {\n            if (t.rule.name === start\n                    && t.dot === t.rule.symbols.length\n                    && t.reference === 0\n                    && t.data !== Parser.fail) {\n                considerations.push(t);\n            }\n        });\n        return considerations.map(function(c) {return c.data; });\n    };\n\n    return {\n        Parser: Parser,\n        Grammar: Grammar,\n        Rule: Rule,\n    };\n\n})());\n\n\n//# sourceURL=webpack:///./src/lib/nearley/nearley.js?");

/***/ }),

/***/ "./src/lib/tonal.min.js":
/*!******************************!*\
  !*** ./src/lib/tonal.min.js ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\nlet tonal = {};\n(function(n){\"use strict\";function t(n){\"string\"!=typeof n&&(n=\"\");var t=T.exec(n);return t?[t[1].toUpperCase(),t[2].replace(/x/g,\"##\"),t[3],t[4]]:null}function r(n,t){return n=Math.round(n),(!0===t?G:I)[n%12]+(Math.floor(n/12)-1)}function e(n,t){for(var r=[];t--;r[t]=t+n);return r}function m(n,t){for(var r=[];t--;r[t]=n-t);return r}function i(n,t){return null===n||null===t?[]:n<t?e(n,t-n+1):m(n,n-t+1)}function u(n,t){var r=t.length,e=(n%r+r)%r;return t.slice(e,r).concat(t.slice(0,e))}function o(n){return Mn(n.map(R)).sort(function(n,t){return an(n)>an(t)})}function P(n){return o(n).filter(function(n,t,r){return 0===t||n!==r[t-1]})}function M(n){return\"string\"!=typeof n?An:_n[n]||(_n[n]=xn(n))}function a(n){var t=(n+1)%7;return t<0?7+t:t}function l(n,t){if(1===arguments.length)return function(t){return l(n,t)};var r=Kn(n),e=Qn(t);if(null===r||null===e)return null;var m=1===r.length?[r[0]+e[0]]:[r[0]+e[0],r[1]+e[1]];return mn(Un(m[0],m[1]))}function c(n,t){if(1===arguments.length)return function(t){return c(n,t)};var r=Kn(n);return null===r?null:mn(Un(r[0]+t))}function s(n,t){if(1===arguments.length)return function(t){return s(n,t)};var r=Kn(n),e=Kn(t);return null===e||null===r?null:e[0]-r[0]}function f(n,t){return 1===arguments.length?function(t){return l(t,n)}:l(t,n)}function d(n,t,r){var e=Qn(n),m=Qn(t);if(null===e||null===m)return null;var i=[e[0]+r*m[0],e[1]+r*m[1]];return Dn(Wn(i))}function p(n,t){return 1===arguments.length?function(t){return p(n,t)}:d(n,t,1)}function b(n,t){return 1===arguments.length?function(t){return p(n,t)}:d(n,t,-1)}function h(n,t){if(1===arguments.length)return function(t){return h(n,t)};var r=Kn(n),e=Kn(t);if(null===r||null===e||r.length!==e.length)return null;var m=1===r.length?[e[0]-r[0],-Math.floor(7*(e[0]-r[0])/12)]:[e[0]-r[0],e[1]-r[1]];return Dn(Wn(m))}function v(n,t){if(1===arguments.length)return function(t){return v(n,t)};var r=L(n),e=L(t);return null!==r.midi&&null!==e.midi?e.midi-r.midi:null!==r.chroma&&null!==e.chroma?(e.chroma-r.chroma+12)%12:null}function A(n){if(y(n))return n;if(!Array.isArray(n))return\"\";var t=[0,0,0,0,0,0,0,0,0,0,0,0];return n.map(nt).forEach(function(n){t[n]=1}),t.join(\"\")}function g(n){return et=et||i(2048,4095).map(function(n){return n.toString(2)}),\"number\"==typeof n?et.filter(function(t){return rt(t)===n}):et.slice()}function j(n,t){t=!1!==t;var r=A(n).split(\"\");return Mn(r.map(function(n,e){var m=u(e,r);return t&&\"0\"===m[0]?null:m.join(\"\")}))}function y(n){return mt.test(n)}function O(n){return y(n)?Mn(n.split(\"\").map(function(n,t){return\"1\"===n?it[t]:null})):[]}function x(n,t){return 1===arguments.length?function(t){return x(n,t)}:A(n)===A(t)}function _(n,t){return arguments.length>1?_(n)(t):(n=tt(n),function(t){return(t=tt(t))!==n&&(t&n)===t})}function z(n,t){return arguments.length>1?z(n)(t):(n=tt(n),function(t){return(t=tt(t))!==n&&(t|n)===t})}function q(n,t){return arguments.length>1?q(n)(t):(n=A(n),function(t){return\"1\"===n[nt(t)]})}function k(n,t){return 1===arguments.length?function(t){return k(n,t)}:t.filter(q(n))}function S(n,t){var r=D(n);return t=t||r[1],pt(t).map(l(r[0]))}function w(n){var t=D(n);return void 0!==Mt(t[1])}function D(n){if(\"string\"!=typeof n)return[\"\",\"\"];var t=n.indexOf(\" \"),r=R(n.substring(0,t))||R(n)||\"\",e=\"\"!==r?n.substring(r.length+1):n;return[r,e.length?e:\"\"]}function E(n,t){var r=C(n);return t=t||r[1],xt(t).intervals.map(l(r[0]))}function C(n){var r=t(n);return\"\"===r[0]?[\"\",n]:\"A\"===r[0]&&\"ug\"===r[3]?[\"\",\"aug\"]:St.test(r[2])?[r[0]+r[1],r[2]+r[3]]:[r[0]+r[1]+r[2],r[3]]}var $=\"C C# Db D D# Eb E F F# Gb G G# Ab A A# Bb B\".split(\" \"),F=function(n){return\"string\"!=typeof n?$.slice():$.filter(function(t){var r=t[1]||\" \";return-1!==n.indexOf(r)})},G=F(\" #\"),I=F(\" b\"),T=/^([a-gA-G]?)(#{1,}|b{1,}|x{1,}|)(-?\\d*)\\s*(.*)$/,B=Object.freeze({pc:null,name:null,step:null,alt:null,oct:null,octStr:null,chroma:null,midi:null,freq:null}),N=[0,2,4,5,7,9,11],L=function(n,t){return void 0===t&&(t={}),function(r){return t[r]||(t[r]=n(r))}}(function(n){var r=t(n);if(\"\"===r[0]||\"\"!==r[3])return B;var e=r[0],m=r[1],i=r[2],u={letter:e,acc:m,octStr:i};return u.pc=u.letter+u.acc,u.name=u.pc+i,u.step=(u.letter.charCodeAt(0)+3)%7,u.alt=\"b\"===u.acc[0]?-u.acc.length:u.acc.length,u.oct=i.length?+i:null,u.chroma=(N[u.step]+u.alt+120)%12,u.midi=null!==u.oct?N[u.step]+u.alt+12*(u.oct+1):null,u.freq=J(u.midi),Object.freeze(u)}),R=function(n){return L(n).name},U=function(n){return L(n).pc},H=function(n){return L(n).midi||+n||null},J=function(n,t){return void 0===t&&(t=440),\"number\"==typeof n?Math.pow(2,(n-69)/12)*t:null},K=function(n){return L(n).freq||J(n)},Q=Math.log(2),V=Math.log(440),W=function(n){var t=12*(Math.log(n)-V)/Q+69;return Math.round(100*t)/100},X=function(n){return L(n).chroma},Y=function(n){return L(n).oct},Z=function(n){return\"CDEFGAB\"[n]},nn=function(n,t){return Array(t+1).join(n)},tn=function(n,t){return\"number\"!=typeof n?\"\":t(n)},rn=function(n){return tn(n,function(n){return n<0?nn(\"b\",-n):nn(\"#\",n)})},en=function(n,t){void 0===n&&(n={}),void 0===t&&(t=null);var r=t?Object.assign({},L(t),n):n,e=r.step,m=r.alt,i=r.oct,u=Z(e);if(!u)return null;var o=u+rn(m);return i||0===i?o+i:o},mn=en,un=function(n,t){var e=L(n),m=e.alt,i=e.chroma,u=e.midi;if(null===i)return null;var o=!1===t?m<0:m>0;return null===u?U(r(i,o)):r(u,o)},on=function(n){return un(n,!1)},Pn=Object.freeze({names:F,tokenize:t,props:L,name:R,pc:U,midi:H,midiToFreq:J,freq:K,freqToMidi:W,chroma:X,oct:Y,stepToLetter:Z,altToAcc:rn,from:en,build:mn,fromMidi:r,simplify:un,enharmonic:on}),Mn=function(n){return n.filter(function(n){return 0===n||n})},an=function(n){var t=H(n);return null!==t?t:H(n+\"-100\")},ln=function(n,t){void 0===t&&(t=Math.random);for(var r,e,m=n.length;m;)r=t()*m--|0,e=n[m],n[m]=n[r],n[r]=e;return n},cn=function(n){return 0===n.length?[[]]:cn(n.slice(1)).reduce(function(t,r){return t.concat(n.map(function(t,e){var m=r.slice();return m.splice(e,0,n[0]),m}))},[])},sn=Object.freeze({range:i,rotate:u,compact:Mn,sort:o,unique:P,shuffle:ln,permutations:cn}),fn=new RegExp(\"^([-+]?\\\\d+)(d{1,4}|m|M|P|A{1,4})|(AA|A|P|M|m|d|dd)([-+]?\\\\d+)$\"),dn=[0,2,4,5,7,9,11],pn=[0,1,2,3,4,5,6,5,4,3,2,1],bn=\"1P 2m 2M 3m 3M 4P 5P 6m 6M 7m 7M 8P\".split(\" \"),hn=function(n){return\"string\"!=typeof n?bn.slice():bn.filter(function(t){return-1!==n.indexOf(t[1])})},vn=function(n){var t=fn.exec(n);return null===t?null:t[1]?[t[1],t[2]]:[t[4],t[3]]},An=Object.freeze({name:null,num:null,q:null,step:null,alt:null,dir:null,type:null,simple:null,semitones:null,chroma:null}),gn=function(n,t){return Array(Math.abs(t)+1).join(n)},jn=function(n,t){return\"M\"===t&&\"M\"===n?0:\"P\"===t&&\"P\"===n?0:\"m\"===t&&\"M\"===n?-1:/^A+$/.test(t)?t.length:/^d+$/.test(t)?\"P\"===n?-t.length:-t.length-1:null},yn=function(n,t){return 0===t?\"M\"===n?\"M\":\"P\":-1===t&&\"M\"===n?\"m\":t>0?gn(\"A\",t):t<0?gn(\"d\",\"P\"===n?t:t+1):null},On=function(n){return(Math.abs(n)-1)%7},xn=function(n){var t=vn(n);if(null===t)return An;var r={num:+t[0],q:t[1]};return r.step=On(r.num),r.type=\"PMMPPMM\"[r.step],\"M\"===r.type&&\"P\"===r.q?An:(r.name=\"\"+r.num+r.q,r.dir=r.num<0?-1:1,r.simple=8===r.num||-8===r.num?r.num:r.dir*(r.step+1),r.alt=jn(r.type,r.q),r.oct=Math.floor((Math.abs(r.num)-1)/7),r.semitones=r.dir*(dn[r.step]+r.alt+12*r.oct),r.chroma=(r.dir*(dn[r.step]+r.alt)%12+12)%12,Object.freeze(r))},_n={},zn=function(n){return M(n).num},qn=function(n){return M(n).name},kn=function(n){return M(n).semitones},Sn=function(n){return M(n).chroma},wn=function(n){return\"string\"==typeof n&&(n=M(n).chroma),\"number\"==typeof n?pn[n%12]:null},Dn=function(n){void 0===n&&(n={});var t=n.num,r=n.step,e=n.alt,m=n.oct;void 0===m&&(m=1);var i=n.dir;if(void 0!==r&&(t=r+1+7*m),void 0===t)return null;var u=i<0?\"-\":\"\",o=\"PMMPPMM\"[On(t)];return u+t+yn(o,e)},En=function(n){var t=M(n);return t===An?null:t.simple+t.q},Cn=function(n){var t=M(n);if(t===An)return null;var r=(7-t.step)%7,e=\"P\"===t.type?-t.alt:-(t.alt+1);return Dn({step:r,alt:e,oct:t.oct,dir:t.dir})},$n=[1,2,2,3,3,4,5,5,6,6,7,7],Fn=\"P m M m M P d P m M m M\".split(\" \"),Gn=function(n){var t=n<0?-1:1,r=Math.abs(n),e=r%12,m=Math.floor(r/12);return t*($n[e]+7*m)+Fn[e]},In=Object.freeze({names:hn,tokenize:vn,props:M,num:zn,name:qn,semitones:kn,chroma:Sn,ic:wn,build:Dn,simplify:En,invert:Cn,fromSemitones:Gn}),Tn=[0,2,4,-1,1,3,5],Bn=function(n){return Math.floor(7*n/12)},Nn=Tn.map(Bn),Ln=function(n){var t=n.step,r=n.alt,e=n.oct,m=n.dir;void 0===m&&(m=1);var i=Tn[t]+7*r;return null===e?[m*i]:[m*i,m*(e-Nn[t]-4*r)]},Rn=[3,0,4,1,5,2,6],Un=function(n,t,r){var e=Rn[a(n)],m=Math.floor((n+1)/7);return void 0===t?{step:e,alt:m,dir:r}:{step:e,alt:m,oct:t+4*m+Nn[e],dir:r}},Hn=function(n,t){return void 0===t&&(t={}),function(r){return t[r]||(t[r]=n(r))}},Jn=function(n){return Hn(function(t){var r=n(t);return null===r.name?null:Ln(r)})},Kn=Jn(L),Qn=Jn(M),Vn=function(n){return 7*n[0]+12*n[1]<0},Wn=function(n){return Vn(n)?Un(-n[0],-n[1],-1):Un(n[0],n[1],1)},Xn=Object.freeze({transpose:l,trFifths:c,fifths:s,transposeBy:f,addIntervals:d,add:p,subtract:b,interval:h,semitones:v}),Yn={chromatic:[\"1P 2m 2M 3m 3M 4P 4A 5P 6m 6M 7m 7M\"],lydian:[\"1P 2M 3M 4A 5P 6M 7M\"],major:[\"1P 2M 3M 4P 5P 6M 7M\",[\"ionian\"]],mixolydian:[\"1P 2M 3M 4P 5P 6M 7m\",[\"dominant\"]],dorian:[\"1P 2M 3m 4P 5P 6M 7m\"],aeolian:[\"1P 2M 3m 4P 5P 6m 7m\",[\"minor\"]],phrygian:[\"1P 2m 3m 4P 5P 6m 7m\"],locrian:[\"1P 2m 3m 4P 5d 6m 7m\"],altered:[\"1P 2m 3m 3M 5d 6m 7m\",[\"super locrian\",\"diminished whole tone\",\"pomeroy\"]],iwato:[\"1P 2m 4P 5d 7m\"],hirajoshi:[\"1P 2M 3m 5P 6m\"],kumoijoshi:[\"1P 2m 4P 5P 6m\"],pelog:[\"1P 2m 3m 5P 6m\"],prometheus:[\"1P 2M 3M 4A 6M 7m\"],ritusen:[\"1P 2M 4P 5P 6M\"],scriabin:[\"1P 2m 3M 5P 6M\"],piongio:[\"1P 2M 4P 5P 6M 7m\"],augmented:[\"1P 2A 3M 5P 5A 7M\"],neopolitan:[\"1P 2m 3m 4P 5P 6m 7M\"],diminished:[\"1P 2M 3m 4P 5d 6m 6M 7M\"],egyptian:[\"1P 2M 4P 5P 7m\"],oriental:[\"1P 2m 3M 4P 5d 6M 7m\"],spanish:[\"1P 2m 3M 4P 5P 6m 7m\",[\"phrygian major\"]],flamenco:[\"1P 2m 3m 3M 4A 5P 7m\"],balinese:[\"1P 2m 3m 4P 5P 6m 7M\"],persian:[\"1P 2m 3M 4P 5d 6m 7M\"],bebop:[\"1P 2M 3M 4P 5P 6M 7m 7M\"],enigmatic:[\"1P 2m 3M 5d 6m 7m 7M\"],ichikosucho:[\"1P 2M 3M 4P 5d 5P 6M 7M\"],\"melodic minor\":[\"1P 2M 3m 4P 5P 6M 7M\"],\"melodic minor second mode\":[\"1P 2m 3m 4P 5P 6M 7m\"],\"lydian augmented\":[\"1P 2M 3M 4A 5A 6M 7M\"],\"lydian dominant\":[\"1P 2M 3M 4A 5P 6M 7m\",[\"lydian b7\"]],\"melodic minor fifth mode\":[\"1P 2M 3M 4P 5P 6m 7m\",[\"hindu\",\"mixolydian b6M\"]],\"locrian #2\":[\"1P 2M 3m 4P 5d 6m 7m\"],\"locrian major\":[\"1P 2M 3M 4P 5d 6m 7m\",[\"arabian\"]],\"major pentatonic\":[\"1P 2M 3M 5P 6M\",[\"pentatonic\"]],\"lydian pentatonic\":[\"1P 3M 4A 5P 7M\",[\"chinese\"]],\"mixolydian pentatonic\":[\"1P 3M 4P 5P 7m\",[\"indian\"]],\"locrian pentatonic\":[\"1P 3m 4P 5d 7m\",[\"minor seven flat five pentatonic\"]],\"minor pentatonic\":[\"1P 3m 4P 5P 7m\"],\"minor six pentatonic\":[\"1P 3m 4P 5P 6M\"],\"minor hexatonic\":[\"1P 2M 3m 4P 5P 7M\"],\"flat three pentatonic\":[\"1P 2M 3m 5P 6M\",[\"kumoi\"]],\"flat six pentatonic\":[\"1P 2M 3M 5P 6m\"],\"major flat two pentatonic\":[\"1P 2m 3M 5P 6M\"],\"whole tone pentatonic\":[\"1P 3M 5d 6m 7m\"],\"ionian pentatonic\":[\"1P 3M 4P 5P 7M\"],\"lydian #5P pentatonic\":[\"1P 3M 4A 5A 7M\"],\"lydian dominant pentatonic\":[\"1P 3M 4A 5P 7m\"],\"minor #7M pentatonic\":[\"1P 3m 4P 5P 7M\"],\"super locrian pentatonic\":[\"1P 3m 4d 5d 7m\"],\"in-sen\":[\"1P 2m 4P 5P 7m\"],\"vietnamese 1\":[\"1P 3m 4P 5P 6m\"],\"vietnamese 2\":[\"1P 3m 4P 5P 7m\"],\"prometheus neopolitan\":[\"1P 2m 3M 4A 6M 7m\"],\"major blues\":[\"1P 2M 3m 3M 5P 6M\"],\"minor blues\":[\"1P 3m 4P 5d 5P 7m\",[\"blues\"]],\"composite blues\":[\"1P 2M 3m 3M 4P 5d 5P 6M 7m\"],\"augmented heptatonic\":[\"1P 2A 3M 4P 5P 5A 7M\"],\"dorian #4\":[\"1P 2M 3m 4A 5P 6M 7m\"],\"lydian diminished\":[\"1P 2M 3m 4A 5P 6M 7M\"],\"whole tone\":[\"1P 2M 3M 4A 5A 7m\"],\"leading whole tone\":[\"1P 2M 3M 4A 5A 7m 7M\"],\"harmonic minor\":[\"1P 2M 3m 4P 5P 6m 7M\"],\"lydian minor\":[\"1P 2M 3M 4A 5P 6m 7m\"],\"neopolitan minor\":[\"1P 2m 3m 4P 5P 6m 7M\"],\"neopolitan major\":[\"1P 2m 3m 4P 5P 6M 7M\",[\"dorian b2\"]],\"neopolitan major pentatonic\":[\"1P 3M 4P 5d 7m\"],\"romanian minor\":[\"1P 2M 3m 5d 5P 6M 7m\"],\"double harmonic lydian\":[\"1P 2m 3M 4A 5P 6m 7M\"],\"harmonic major\":[\"1P 2M 3M 4P 5P 6m 7M\"],\"double harmonic major\":[\"1P 2m 3M 4P 5P 6m 7M\",[\"gypsy\"]],\"hungarian minor\":[\"1P 2M 3m 4A 5P 6m 7M\"],\"hungarian major\":[\"1P 2A 3M 4A 5P 6M 7m\"],\"spanish heptatonic\":[\"1P 2m 3m 3M 4P 5P 6m 7m\"],\"todi raga\":[\"1P 2m 3m 4A 5P 6m 7M\"],\"malkos raga\":[\"1P 3m 4P 6m 7m\"],\"kafi raga\":[\"1P 3m 3M 4P 5P 6M 7m 7M\"],\"purvi raga\":[\"1P 2m 3M 4P 4A 5P 6m 7M\"],\"bebop dominant\":[\"1P 2M 3M 4P 5P 6M 7m 7M\"],\"bebop minor\":[\"1P 2M 3m 3M 4P 5P 6M 7m\"],\"bebop major\":[\"1P 2M 3M 4P 5P 5A 6M 7M\"],\"bebop locrian\":[\"1P 2m 3m 4P 5d 5P 6m 7m\"],\"minor bebop\":[\"1P 2M 3m 4P 5P 6m 7m 7M\"],\"mystery #1\":[\"1P 2m 3M 5d 6m 7m\"],\"minor six diminished\":[\"1P 2M 3m 4P 5P 6m 6M 7M\"],\"ionian augmented\":[\"1P 2M 3M 4P 5A 6M 7M\"],\"lydian #9\":[\"1P 2m 3M 4A 5P 6M 7M\"],\"six tone symmetric\":[\"1P 2m 3M 4P 5A 6M\"]},Zn={M:[\"1P 3M 5P\",[\"Major\",\"\"]],M13:[\"1P 3M 5P 7M 9M 13M\",[\"maj13\",\"Maj13\"]],M6:[\"1P 3M 5P 13M\",[\"6\"]],M69:[\"1P 3M 5P 6M 9M\",[\"69\"]],M7add13:[\"1P 3M 5P 6M 7M 9M\"],M7b5:[\"1P 3M 5d 7M\"],M7b6:[\"1P 3M 6m 7M\"],M7b9:[\"1P 3M 5P 7M 9m\"],M7sus4:[\"1P 4P 5P 7M\"],M9:[\"1P 3M 5P 7M 9M\",[\"maj9\",\"Maj9\"]],M9b5:[\"1P 3M 5d 7M 9M\"],M9sus4:[\"1P 4P 5P 7M 9M\"],Madd9:[\"1P 3M 5P 9M\",[\"2\",\"add9\",\"add2\"]],Maj7:[\"1P 3M 5P 7M\",[\"maj7\",\"M7\"]],Mb5:[\"1P 3M 5d\"],Mb6:[\"1P 3M 13m\"],Msus2:[\"1P 2M 5P\",[\"add9no3\",\"sus2\"]],Msus4:[\"1P 4P 5P\",[\"sus\",\"sus4\"]],Maddb9:[\"1P 3M 5P 9m\"],m:[\"1P 3m 5P\"],m11:[\"1P 3m 5P 7m 9M 11P\",[\"_11\"]],m11b5:[\"1P 3m 7m 12d 2M 4P\",[\"h11\",\"_11b5\"]],m13:[\"1P 3m 5P 7m 9M 11P 13M\",[\"_13\"]],m6:[\"1P 3m 4P 5P 13M\",[\"_6\"]],m69:[\"1P 3m 5P 6M 9M\",[\"_69\"]],m7:[\"1P 3m 5P 7m\",[\"minor7\",\"_\",\"_7\"]],m7add11:[\"1P 3m 5P 7m 11P\",[\"m7add4\"]],m7b5:[\"1P 3m 5d 7m\",[\"half-diminished\",\"h7\",\"_7b5\"]],m9:[\"1P 3m 5P 7m 9M\",[\"_9\"]],m9b5:[\"1P 3m 7m 12d 2M\",[\"h9\",\"-9b5\"]],mMaj7:[\"1P 3m 5P 7M\",[\"mM7\",\"_M7\"]],mMaj7b6:[\"1P 3m 5P 6m 7M\",[\"mM7b6\"]],mM9:[\"1P 3m 5P 7M 9M\",[\"mMaj9\",\"-M9\"]],mM9b6:[\"1P 3m 5P 6m 7M 9M\",[\"mMaj9b6\"]],mb6M7:[\"1P 3m 6m 7M\"],mb6b9:[\"1P 3m 6m 9m\"],o:[\"1P 3m 5d\",[\"mb5\",\"dim\"]],o7:[\"1P 3m 5d 13M\",[\"diminished\",\"m6b5\",\"dim7\"]],o7M7:[\"1P 3m 5d 6M 7M\"],oM7:[\"1P 3m 5d 7M\"],sus24:[\"1P 2M 4P 5P\",[\"sus4add9\"]],madd4:[\"1P 3m 4P 5P\"],madd9:[\"1P 3m 5P 9M\"],4:[\"1P 4P 7m 10m\",[\"quartal\"]],5:[\"1P 5P\"],7:[\"1P 3M 5P 7m\",[\"Dominant\",\"Dom\"]],9:[\"1P 3M 5P 7m 9M\",[\"79\"]],11:[\"1P 5P 7m 9M 11P\"],13:[\"1P 3M 5P 7m 9M 13M\",[\"13_\"]],64:[\"5P 8P 10M\"],\"M#5\":[\"1P 3M 5A\",[\"augmented\",\"maj#5\",\"Maj#5\",\"+\",\"aug\"]],\"M#5add9\":[\"1P 3M 5A 9M\",[\"+add9\"]],\"M13#11\":[\"1P 3M 5P 7M 9M 11A 13M\",[\"maj13#11\",\"Maj13#11\",\"M13+4\",\"M13#4\"]],\"M6#11\":[\"1P 3M 5P 6M 11A\",[\"M6b5\",\"6#11\",\"6b5\"]],\"M69#11\":[\"1P 3M 5P 6M 9M 11A\"],\"M7#11\":[\"1P 3M 5P 7M 11A\",[\"maj7#11\",\"Maj7#11\",\"M7+4\",\"M7#4\"]],\"M7#5\":[\"1P 3M 5A 7M\",[\"maj7#5\",\"Maj7#5\",\"maj9#5\",\"M7+\"]],\"M7#5sus4\":[\"1P 4P 5A 7M\"],\"M7#9#11\":[\"1P 3M 5P 7M 9A 11A\"],\"M9#11\":[\"1P 3M 5P 7M 9M 11A\",[\"maj9#11\",\"Maj9#11\",\"M9+4\",\"M9#4\"]],\"M9#5\":[\"1P 3M 5A 7M 9M\",[\"Maj9#5\"]],\"M9#5sus4\":[\"1P 4P 5A 7M 9M\"],\"11b9\":[\"1P 5P 7m 9m 11P\"],\"13#11\":[\"1P 3M 5P 7m 9M 11A 13M\",[\"13+4\",\"13#4\"]],\"13#9\":[\"1P 3M 5P 7m 9A 13M\",[\"13#9_\"]],\"13#9#11\":[\"1P 3M 5P 7m 9A 11A 13M\"],\"13b5\":[\"1P 3M 5d 6M 7m 9M\"],\"13b9\":[\"1P 3M 5P 7m 9m 13M\"],\"13b9#11\":[\"1P 3M 5P 7m 9m 11A 13M\"],\"13no5\":[\"1P 3M 7m 9M 13M\"],\"13sus4\":[\"1P 4P 5P 7m 9M 13M\",[\"13sus\"]],\"69#11\":[\"1P 3M 5P 6M 9M 11A\"],\"7#11\":[\"1P 3M 5P 7m 11A\",[\"7+4\",\"7#4\",\"7#11_\",\"7#4_\"]],\"7#11b13\":[\"1P 3M 5P 7m 11A 13m\",[\"7b5b13\"]],\"7#5\":[\"1P 3M 5A 7m\",[\"+7\",\"7aug\",\"aug7\"]],\"7#5#9\":[\"1P 3M 5A 7m 9A\",[\"7alt\",\"7#5#9_\",\"7#9b13_\"]],\"7#5b9\":[\"1P 3M 5A 7m 9m\"],\"7#5b9#11\":[\"1P 3M 5A 7m 9m 11A\"],\"7#5sus4\":[\"1P 4P 5A 7m\"],\"7#9\":[\"1P 3M 5P 7m 9A\",[\"7#9_\"]],\"7#9#11\":[\"1P 3M 5P 7m 9A 11A\",[\"7b5#9\"]],\"7#9#11b13\":[\"1P 3M 5P 7m 9A 11A 13m\"],\"7#9b13\":[\"1P 3M 5P 7m 9A 13m\"],\"7add6\":[\"1P 3M 5P 7m 13M\",[\"67\",\"7add13\"]],\"7b13\":[\"1P 3M 7m 13m\"],\"7b5\":[\"1P 3M 5d 7m\"],\"7b6\":[\"1P 3M 5P 6m 7m\"],\"7b9\":[\"1P 3M 5P 7m 9m\"],\"7b9#11\":[\"1P 3M 5P 7m 9m 11A\",[\"7b5b9\"]],\"7b9#9\":[\"1P 3M 5P 7m 9m 9A\"],\"7b9b13\":[\"1P 3M 5P 7m 9m 13m\"],\"7b9b13#11\":[\"1P 3M 5P 7m 9m 11A 13m\",[\"7b9#11b13\",\"7b5b9b13\"]],\"7no5\":[\"1P 3M 7m\"],\"7sus4\":[\"1P 4P 5P 7m\",[\"7sus\"]],\"7sus4b9\":[\"1P 4P 5P 7m 9m\",[\"susb9\",\"7susb9\",\"7b9sus\",\"7b9sus4\",\"phryg\"]],\"7sus4b9b13\":[\"1P 4P 5P 7m 9m 13m\",[\"7b9b13sus4\"]],\"9#11\":[\"1P 3M 5P 7m 9M 11A\",[\"9+4\",\"9#4\",\"9#11_\",\"9#4_\"]],\"9#11b13\":[\"1P 3M 5P 7m 9M 11A 13m\",[\"9b5b13\"]],\"9#5\":[\"1P 3M 5A 7m 9M\",[\"9+\"]],\"9#5#11\":[\"1P 3M 5A 7m 9M 11A\"],\"9b13\":[\"1P 3M 7m 9M 13m\"],\"9b5\":[\"1P 3M 5d 7m 9M\"],\"9no5\":[\"1P 3M 7m 9M\"],\"9sus4\":[\"1P 4P 5P 7m 9M\",[\"9sus\"]],\"m#5\":[\"1P 3m 5A\",[\"m+\",\"mb6\"]],\"m11A 5\":[\"1P 3m 6m 7m 9M 11P\"],\"m7#5\":[\"1P 3m 6m 7m\"],\"m9#5\":[\"1P 3m 6m 7m 9M\"],\"+add#9\":[\"1P 3M 5A 9A\"]},nt=function(n){return X(n)||Sn(n)||0},tt=function(n){return parseInt(A(n),2)},rt=function(n){return n.replace(/0/g,\"\").length},et=null,mt=/^[01]{12}$/,it=\"1P 2m 2M 3m 3M 4P 5d 5P 6m 6M 7m 7M\".split(\" \"),ut=Object.freeze({chroma:A,chromas:g,modes:j,isChroma:y,intervals:O,isEqual:x,isSubsetOf:_,isSupersetOf:z,includes:q,filter:k}),ot=function(n){var t=Object.keys(n).sort(),r=[],e=[],m=function(n,t,m){r[n]=t,e[m]=e[m]||[],e[m].push(n)};t.forEach(function(t){var r=n[t][0].split(\" \"),e=n[t][1],i=A(r);m(t,r,i),e&&e.forEach(function(n){return m(n,r,i)})});var i=Object.keys(r).sort(),u=function(n){return r[n]};return u.names=function(n){return\"string\"==typeof n?(e[n]||[]).slice():(!0===n?i:t).slice()},u},Pt=function(n,t){var r=function(r){return n(r)||t(r)};return r.names=function(r){return n.names(r).concat(t.names(r))},r},Mt=ot(Yn),at=ot(Zn),lt=Pt(Mt,at),ct=Object.freeze({dictionary:ot,combine:Pt,scale:Mt,chord:at,pcset:lt}),st=Object.freeze({name:null,intervals:[],names:[],chroma:null,setnum:null}),ft=function(n,t){return function(r){return t[r]||(t[r]=n(r))}}(function(n){var t=Mt(n);if(!t)return st;var r={intervals:t,name:n};return r.chroma=A(t),r.setnum=parseInt(r.chroma,2),r.names=Mt.names(r.chroma),Object.freeze(r)},{}),dt=Mt.names,pt=function(n){var t=D(n);return ft(t[1]).intervals},bt=function(n){var t=pt(n),r=S(n);return j(t).map(function(n,e){var m=Mt.names(n)[0];if(m)return[r[e]||t[e],m]}).filter(function(n){return n})},ht=function(n){var t=_(pt(n));return at.names().filter(function(n){return t(at(n))})},vt=function(n){var t=Mn(n.map(U));if(!t.length)return t;var r=t[0],e=P(t);return u(e.indexOf(r),e)},At=function(n){if(!pt(n).length)return[];var t=z(pt(n));return Mt.names().filter(function(n){return t(Mt(n))})},gt=function(n){var t=_(pt(n));return Mt.names().filter(function(n){return t(Mt(n))})},jt=Object.freeze({props:ft,names:dt,intervals:pt,notes:S,exists:w,tokenize:D,modeNames:bt,chords:ht,toScale:vt,supersets:At,subsets:gt}),yt=at.names,Ot=Object.freeze({name:null,names:[],intervals:[],chroma:null,setnum:null}),xt=function(n,t){return void 0===t&&(t={}),function(r){return t[r]||(t[r]=n(r))}}(function(n){var t=at(n);if(!t)return Ot;var r={intervals:t,name:n};return r.chroma=A(t),r.setnum=parseInt(r.chroma,2),r.names=at.names(r.chroma),r}),_t=function(n){return xt(C(n)[1]).intervals},zt=function(n){return void 0!==at(C(n)[1])},qt=function(n){if(!_t(n).length)return[];var t=z(_t(n));return at.names().filter(function(n){return t(at(n))})},kt=function(n){var t=_(_t(n));return at.names().filter(function(n){return t(at(n))})},St=/^(6|64|7|9|11|13)$/,wt=Object.freeze({names:yt,props:xt,intervals:_t,notes:E,exists:zt,supersets:qt,subsets:kt,tokenize:C}),Dt=l,Et=h,Ct=L,$t=H,Ft=K,Gt=at,It=Mt;n.Array=sn,n.Note=Pn,n.Interval=In,n.Distance=Xn,n.Scale=jt,n.Chord=wt,n.PcSet=ut,n.Dictionary=ct,n.transpose=Dt,n.interval=Et,n.note=Ct,n.midi=$t,n.freq=Ft,n.chord=Gt,n.scale=It,Object.defineProperty(n,\"__esModule\",{value:!0})})(tonal);\n/* harmony default export */ __webpack_exports__[\"default\"] = (tonal);\n//# sourceMappingURL=tonal.min.js.map\n\n//# sourceURL=webpack:///./src/lib/tonal.min.js?");

/***/ }),

/***/ "./src/loader/loader-node.js":
/*!***********************************!*\
  !*** ./src/loader/loader-node.js ***!
  \***********************************/
/*! exports provided: load */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(__dirname) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"load\", function() { return load; });\n/**\n * Load a file.\n * \n * * Style locator algorithm:\n * 1. If the path begins with http:// or https://, look at that URL\n * 2. If the path begins with . or / look in the filesystem or at a relative URL\n * 3. Otherwise, look in the styles folder in this repo (which will move to its\n *    own repo eventually). For these built-in styles, the .play file extension\n *    is not required.\n * \n * @param {string} path The path to the file to load.\n * @return {string} The content of the file.\n */\nasync function load(stylePath) {\n  let isHTTP = stylePath.startsWith('http://') || stylePath.startsWith('https://');\n  if (isHTTP) {\n    console.log('TODO');\n    return '';\n  } else {\n    let isRelative = stylePath.startsWith('.') || stylePath.startsWith('/');\n    if (!isRelative) {\n      let path = await Promise.resolve(/*! import() */).then(__webpack_require__.t.bind(null, /*! path */ \"path\", 7));\n      stylePath = path.join(__dirname, '../../styles/', stylePath);\n      if (!stylePath.endsWith('.play')) stylePath += '.play';\n    }\n    let fs = await Promise.resolve(/*! import() */).then(__webpack_require__.t.bind(null, /*! fs */ \"fs\", 7));\n    return await (new Promise((resolve, reject) => {\n      fs.readFile(stylePath, 'utf8', (err, data) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(data);\n        }\n      });\n    }));\n  }\n}\n/* WEBPACK VAR INJECTION */}.call(this, \"src/loader\"))\n\n//# sourceURL=webpack:///./src/loader/loader-node.js?");

/***/ }),

/***/ "./src/parser/grammar.js":
/*!*******************************!*\
  !*** ./src/parser/grammar.js ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _lexer_lexer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lexer/lexer.js */ \"./src/lexer/lexer.js\");\n/* harmony import */ var _ast_ast_nodes_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ast/ast_nodes.js */ \"./src/ast/ast_nodes.js\");\n// Generated automatically by nearley, version 2.13.0\n// http://github.com/Hardmath123/nearley\nfunction id(x) { return x[0]; }\n\n\n\nlet Lexer = _lexer_lexer_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\nlet ParserRules = [\n    {\"name\": \"main$macrocall$2\", \"symbols\": [\"TopLevelStatement\"]},\n    {\"name\": \"main$macrocall$1$ebnf$1\", \"symbols\": []},\n    {\"name\": \"main$macrocall$1$ebnf$1$subexpression$1\", \"symbols\": [\"_\", \"main$macrocall$2\"], \"postprocess\": d => d[1][0]},\n    {\"name\": \"main$macrocall$1$ebnf$1\", \"symbols\": [\"main$macrocall$1$ebnf$1\", \"main$macrocall$1$ebnf$1$subexpression$1\"], \"postprocess\": function arrpush(d) {return d[0].concat([d[1]]);}},\n    {\"name\": \"main$macrocall$1\", \"symbols\": [\"main$macrocall$2\", \"main$macrocall$1$ebnf$1\"], \"postprocess\": d => d[0].concat(d[1])},\n    {\"name\": \"main\", \"symbols\": [\"_?\", \"main$macrocall$1\", \"_?\"], \"postprocess\": d => new _ast_ast_nodes_js__WEBPACK_IMPORTED_MODULE_1__[\"GlobalScope\"](d[1])},\n    {\"name\": \"TopLevelStatement\", \"symbols\": [\"ConfigurationStatement\"], \"postprocess\": id},\n    {\"name\": \"TopLevelStatement\", \"symbols\": [\"ImportStatement\"], \"postprocess\": id},\n    {\"name\": \"TopLevelStatement\", \"symbols\": [\"TrackStatement\"], \"postprocess\": id},\n    {\"name\": \"TopLevelStatement\", \"symbols\": [\"TrackCallStatement\"], \"postprocess\": id},\n    {\"name\": \"ConfigurationStatement\", \"symbols\": [{\"literal\":\"@meta\"}, \"_?\", {\"literal\":\"{\"}, \"_?\", \"ConfigurationList\", \"_?\", {\"literal\":\"}\"}], \"postprocess\": d => new _ast_ast_nodes_js__WEBPACK_IMPORTED_MODULE_1__[\"MetaStatement\"](d[4])},\n    {\"name\": \"ConfigurationStatement\", \"symbols\": [{\"literal\":\"@options\"}, \"_?\", {\"literal\":\"{\"}, \"_?\", \"ConfigurationList\", \"_?\", {\"literal\":\"}\"}], \"postprocess\": d => new _ast_ast_nodes_js__WEBPACK_IMPORTED_MODULE_1__[\"OptionsStatement\"](d[4])},\n    {\"name\": \"ConfigurationList$macrocall$2\", \"symbols\": [\"FunctionCallExpression\"]},\n    {\"name\": \"ConfigurationList$macrocall$1$ebnf$1\", \"symbols\": []},\n    {\"name\": \"ConfigurationList$macrocall$1$ebnf$1$subexpression$1\", \"symbols\": [\"_\", \"ConfigurationList$macrocall$2\"], \"postprocess\": d => d[1][0]},\n    {\"name\": \"ConfigurationList$macrocall$1$ebnf$1\", \"symbols\": [\"ConfigurationList$macrocall$1$ebnf$1\", \"ConfigurationList$macrocall$1$ebnf$1$subexpression$1\"], \"postprocess\": function arrpush(d) {return d[0].concat([d[1]]);}},\n    {\"name\": \"ConfigurationList$macrocall$1\", \"symbols\": [\"ConfigurationList$macrocall$2\", \"ConfigurationList$macrocall$1$ebnf$1\"], \"postprocess\": d => d[0].concat(d[1])},\n    {\"name\": \"ConfigurationList\", \"symbols\": [\"ConfigurationList$macrocall$1\"], \"postprocess\": id},\n    {\"name\": \"ImportStatement\", \"symbols\": [{\"literal\":\"@import\"}, \"_\", \"StringLiteral\", \"_\", {\"literal\":\"as\"}, \"_\", \"Identifier\"], \"postprocess\": d => new _ast_ast_nodes_js__WEBPACK_IMPORTED_MODULE_1__[\"ImportStatement\"](d[2], d[6])},\n    {\"name\": \"TrackStatement$macrocall$2\", \"symbols\": [\"TrackMember\"]},\n    {\"name\": \"TrackStatement$macrocall$1$ebnf$1\", \"symbols\": []},\n    {\"name\": \"TrackStatement$macrocall$1$ebnf$1$subexpression$1\", \"symbols\": [\"_\", \"TrackStatement$macrocall$2\"], \"postprocess\": d => d[1][0]},\n    {\"name\": \"TrackStatement$macrocall$1$ebnf$1\", \"symbols\": [\"TrackStatement$macrocall$1$ebnf$1\", \"TrackStatement$macrocall$1$ebnf$1$subexpression$1\"], \"postprocess\": function arrpush(d) {return d[0].concat([d[1]]);}},\n    {\"name\": \"TrackStatement$macrocall$1\", \"symbols\": [\"TrackStatement$macrocall$2\", \"TrackStatement$macrocall$1$ebnf$1\"], \"postprocess\": d => d[0].concat(d[1])},\n    {\"name\": \"TrackStatement\", \"symbols\": [{\"literal\":\"@track\"}, \"_\", \"StringLiteral\", \"_\", {\"literal\":\"as\"}, \"_\", \"Identifier\", \"_?\", {\"literal\":\"{\"}, \"_?\", \"TrackStatement$macrocall$1\", \"_?\", {\"literal\":\"}\"}], \"postprocess\": d => new _ast_ast_nodes_js__WEBPACK_IMPORTED_MODULE_1__[\"TrackStatement\"]({instrument: d[2], identifier: d[6], members: d[10]})},\n    {\"name\": \"TrackMember\", \"symbols\": [\"FunctionCallExpression\"], \"postprocess\": id},\n    {\"name\": \"TrackMember\", \"symbols\": [\"PatternStatement\"], \"postprocess\": id},\n    {\"name\": \"TrackMember\", \"symbols\": [\"PatternCallExpression\"], \"postprocess\": id},\n    {\"name\": \"TrackCallStatement\", \"symbols\": [{\"literal\":\"@track\"}, \"_?\", {\"literal\":\"(\"}, \"_?\", \"Identifier\", {\"literal\":\".\"}, \"Identifier\", \"_?\", {\"literal\":\")\"}], \"postprocess\": d => new _ast_ast_nodes_js__WEBPACK_IMPORTED_MODULE_1__[\"TrackCall\"]({import: d[4], track: d[6]})},\n    {\"name\": \"PatternStatement\", \"symbols\": [{\"literal\":\"@pattern\"}, \"_\", \"Identifier\", \"_\", \"PatternConditional\", \"_?\", \"PatternExpression\"], \"postprocess\": d => new _ast_ast_nodes_js__WEBPACK_IMPORTED_MODULE_1__[\"PatternStatement\"]({identifier: d[2], expression: d[6], condition: d[4]})},\n    {\"name\": \"PatternStatement\", \"symbols\": [{\"literal\":\"@pattern\"}, \"_\", \"Identifier\", \"_\", \"PatternExpression\"], \"postprocess\": d => new _ast_ast_nodes_js__WEBPACK_IMPORTED_MODULE_1__[\"PatternStatement\"]({identifier: d[2], expression: d[4]})},\n    {\"name\": \"PatternConditional\", \"symbols\": [{\"literal\":\"if\"}, \"_?\", {\"literal\":\"(\"}, \"_?\", \"FunctionCallArgument\", \"_?\", {\"literal\":\")\"}], \"postprocess\": d => d[4]},\n    {\"name\": \"PatternExpression\", \"symbols\": [\"PatternExpression_NoJoin\"], \"postprocess\": id},\n    {\"name\": \"PatternExpression\", \"symbols\": [\"JoinedPatternExpression\"], \"postprocess\": id},\n    {\"name\": \"PatternExpression_NoJoin\", \"symbols\": [\"PatternExpressionGroup\"], \"postprocess\": id},\n    {\"name\": \"PatternExpression_NoJoin\", \"symbols\": [\"BeatGroupLiteral\"], \"postprocess\": id},\n    {\"name\": \"PatternExpression_NoJoin\", \"symbols\": [\"DrumBeatGroupLiteral\"], \"postprocess\": id},\n    {\"name\": \"PatternExpression_NoJoin\", \"symbols\": [\"FunctionCallExpression\"], \"postprocess\": id},\n    {\"name\": \"PatternExpression_NoJoin\", \"symbols\": [\"PatternCallExpression\"], \"postprocess\": id},\n    {\"name\": \"PatternExpressionGroup$macrocall$2\", \"symbols\": [\"PatternExpression\"]},\n    {\"name\": \"PatternExpressionGroup$macrocall$1$ebnf$1\", \"symbols\": []},\n    {\"name\": \"PatternExpressionGroup$macrocall$1$ebnf$1$subexpression$1\", \"symbols\": [\"_\", \"PatternExpressionGroup$macrocall$2\"], \"postprocess\": d => d[1][0]},\n    {\"name\": \"PatternExpressionGroup$macrocall$1$ebnf$1\", \"symbols\": [\"PatternExpressionGroup$macrocall$1$ebnf$1\", \"PatternExpressionGroup$macrocall$1$ebnf$1$subexpression$1\"], \"postprocess\": function arrpush(d) {return d[0].concat([d[1]]);}},\n    {\"name\": \"PatternExpressionGroup$macrocall$1\", \"symbols\": [\"PatternExpressionGroup$macrocall$2\", \"PatternExpressionGroup$macrocall$1$ebnf$1\"], \"postprocess\": d => d[0].concat(d[1])},\n    {\"name\": \"PatternExpressionGroup\", \"symbols\": [{\"literal\":\"{\"}, \"_?\", \"PatternExpressionGroup$macrocall$1\", \"_?\", {\"literal\":\"}\"}], \"postprocess\": d => new _ast_ast_nodes_js__WEBPACK_IMPORTED_MODULE_1__[\"PatternExpressionGroup\"](d[2])},\n    {\"name\": \"PatternCallExpression\", \"symbols\": [{\"literal\":\"@pattern\"}, \"_?\", {\"literal\":\"(\"}, \"_?\", \"Identifier\", \"_?\", {\"literal\":\")\"}], \"postprocess\": d => new _ast_ast_nodes_js__WEBPACK_IMPORTED_MODULE_1__[\"PatternCall\"]({pattern: d[4]})},\n    {\"name\": \"PatternCallExpression\", \"symbols\": [{\"literal\":\"@pattern\"}, \"_?\", {\"literal\":\"(\"}, \"_?\", \"Identifier\", {\"literal\":\".\"}, \"Identifier\", \"_?\", {\"literal\":\")\"}], \"postprocess\": d => new _ast_ast_nodes_js__WEBPACK_IMPORTED_MODULE_1__[\"PatternCall\"]({track: d[4], pattern: d[6]})},\n    {\"name\": \"PatternCallExpression\", \"symbols\": [{\"literal\":\"@pattern\"}, \"_?\", {\"literal\":\"(\"}, \"_?\", \"Identifier\", {\"literal\":\".\"}, \"Identifier\", {\"literal\":\".\"}, \"Identifier\", \"_?\", {\"literal\":\")\"}], \"postprocess\": d => new _ast_ast_nodes_js__WEBPACK_IMPORTED_MODULE_1__[\"PatternCall\"]({import: d[4], track: d[6], pattern: d[8]})},\n    {\"name\": \"JoinedPatternExpression$macrocall$2\", \"symbols\": [\"PatternExpression_NoJoin\"]},\n    {\"name\": \"JoinedPatternExpression$macrocall$3\", \"symbols\": [{\"literal\":\"&\"}]},\n    {\"name\": \"JoinedPatternExpression$macrocall$1$ebnf$1$subexpression$1\", \"symbols\": [\"_?\", \"JoinedPatternExpression$macrocall$3\", \"_?\", \"JoinedPatternExpression$macrocall$2\"], \"postprocess\": d => d[3][0]},\n    {\"name\": \"JoinedPatternExpression$macrocall$1$ebnf$1\", \"symbols\": [\"JoinedPatternExpression$macrocall$1$ebnf$1$subexpression$1\"]},\n    {\"name\": \"JoinedPatternExpression$macrocall$1$ebnf$1$subexpression$2\", \"symbols\": [\"_?\", \"JoinedPatternExpression$macrocall$3\", \"_?\", \"JoinedPatternExpression$macrocall$2\"], \"postprocess\": d => d[3][0]},\n    {\"name\": \"JoinedPatternExpression$macrocall$1$ebnf$1\", \"symbols\": [\"JoinedPatternExpression$macrocall$1$ebnf$1\", \"JoinedPatternExpression$macrocall$1$ebnf$1$subexpression$2\"], \"postprocess\": function arrpush(d) {return d[0].concat([d[1]]);}},\n    {\"name\": \"JoinedPatternExpression$macrocall$1\", \"symbols\": [\"JoinedPatternExpression$macrocall$2\", \"JoinedPatternExpression$macrocall$1$ebnf$1\"], \"postprocess\": d => d[0].concat(d[1])},\n    {\"name\": \"JoinedPatternExpression\", \"symbols\": [\"JoinedPatternExpression$macrocall$1\"], \"postprocess\": d => new _ast_ast_nodes_js__WEBPACK_IMPORTED_MODULE_1__[\"JoinedPatternExpression\"](d[0])},\n    {\"name\": \"FunctionCallExpression$macrocall$2\", \"symbols\": [\"FunctionCallArgument\"]},\n    {\"name\": \"FunctionCallExpression$macrocall$1$ebnf$1\", \"symbols\": []},\n    {\"name\": \"FunctionCallExpression$macrocall$1$ebnf$1$subexpression$1\", \"symbols\": [\"_\", \"FunctionCallExpression$macrocall$2\"], \"postprocess\": d => d[1][0]},\n    {\"name\": \"FunctionCallExpression$macrocall$1$ebnf$1\", \"symbols\": [\"FunctionCallExpression$macrocall$1$ebnf$1\", \"FunctionCallExpression$macrocall$1$ebnf$1$subexpression$1\"], \"postprocess\": function arrpush(d) {return d[0].concat([d[1]]);}},\n    {\"name\": \"FunctionCallExpression$macrocall$1\", \"symbols\": [\"FunctionCallExpression$macrocall$2\", \"FunctionCallExpression$macrocall$1$ebnf$1\"], \"postprocess\": d => d[0].concat(d[1])},\n    {\"name\": \"FunctionCallExpression\", \"symbols\": [\"Identifier\", \"_?\", {\"literal\":\"(\"}, \"_?\", \"FunctionCallExpression$macrocall$1\", \"_?\", {\"literal\":\")\"}], \"postprocess\": d => new _ast_ast_nodes_js__WEBPACK_IMPORTED_MODULE_1__[\"FunctionCall\"](d[0], d[4])},\n    {\"name\": \"FunctionCallExpression\", \"symbols\": [\"Identifier\", \"_?\", {\"literal\":\"(\"}, {\"literal\":\")\"}], \"postprocess\": d => new _ast_ast_nodes_js__WEBPACK_IMPORTED_MODULE_1__[\"FunctionCall\"](d[0], [])},\n    {\"name\": \"FunctionCallArgument\", \"symbols\": [\"NumericExpression\"], \"postprocess\": id},\n    {\"name\": \"FunctionCallArgument\", \"symbols\": [\"StringLiteral\"], \"postprocess\": id},\n    {\"name\": \"FunctionCallArgument\", \"symbols\": [\"BooleanLiteral\"], \"postprocess\": id},\n    {\"name\": \"FunctionCallArgument\", \"symbols\": [\"PatternExpression\"], \"postprocess\": id},\n    {\"name\": \"FunctionCallArgument\", \"symbols\": [\"BL_PP_Anchor\"], \"postprocess\": d => new _ast_ast_nodes_js__WEBPACK_IMPORTED_MODULE_1__[\"AnchorArgument\"](d[0])},\n    {\"name\": \"FunctionCallArgument\", \"symbols\": [{\"literal\":\"not\"}, \"_\", \"FunctionCallArgument\"], \"postprocess\": d => new _ast_ast_nodes_js__WEBPACK_IMPORTED_MODULE_1__[\"BooleanNot\"](d[2])},\n    {\"name\": \"FunctionCallArgument\", \"symbols\": [\"FunctionCallArgument\", \"_\", {\"literal\":\"and\"}, \"_\", \"FunctionCallArgument\"], \"postprocess\": d => new _ast_ast_nodes_js__WEBPACK_IMPORTED_MODULE_1__[\"BooleanAnd\"](d[0], d[4])},\n    {\"name\": \"FunctionCallArgument\", \"symbols\": [\"FunctionCallArgument\", \"_\", {\"literal\":\"or\"}, \"_\", \"FunctionCallArgument\"], \"postprocess\": d => new _ast_ast_nodes_js__WEBPACK_IMPORTED_MODULE_1__[\"BooleanOr\"](d[0], d[4])},\n    {\"name\": \"BeatGroupLiteral\", \"symbols\": [{\"literal\":\"<\"}, \"_?\", \"MeasureGroup\", \"_?\", {\"literal\":\">\"}], \"postprocess\": d => new _ast_ast_nodes_js__WEBPACK_IMPORTED_MODULE_1__[\"BeatGroupLiteral\"](d[2])},\n    {\"name\": \"MeasureGroup$macrocall$2\", \"symbols\": [\"Measure\"]},\n    {\"name\": \"MeasureGroup$macrocall$3\", \"symbols\": [{\"literal\":\"|\"}]},\n    {\"name\": \"MeasureGroup$macrocall$1$ebnf$1\", \"symbols\": []},\n    {\"name\": \"MeasureGroup$macrocall$1$ebnf$1$subexpression$1\", \"symbols\": [\"_?\", \"MeasureGroup$macrocall$3\", \"_?\", \"MeasureGroup$macrocall$2\"], \"postprocess\": d => d[3][0]},\n    {\"name\": \"MeasureGroup$macrocall$1$ebnf$1\", \"symbols\": [\"MeasureGroup$macrocall$1$ebnf$1\", \"MeasureGroup$macrocall$1$ebnf$1$subexpression$1\"], \"postprocess\": function arrpush(d) {return d[0].concat([d[1]]);}},\n    {\"name\": \"MeasureGroup$macrocall$1\", \"symbols\": [\"MeasureGroup$macrocall$2\", \"MeasureGroup$macrocall$1$ebnf$1\"], \"postprocess\": d => d[0].concat(d[1])},\n    {\"name\": \"MeasureGroup\", \"symbols\": [\"MeasureGroup$macrocall$1\"], \"postprocess\": id},\n    {\"name\": \"Measure$macrocall$2\", \"symbols\": [\"MelodicBeatLiteral\"]},\n    {\"name\": \"Measure$macrocall$1$ebnf$1\", \"symbols\": []},\n    {\"name\": \"Measure$macrocall$1$ebnf$1$subexpression$1\", \"symbols\": [\"_\", \"Measure$macrocall$2\"], \"postprocess\": d => d[1][0]},\n    {\"name\": \"Measure$macrocall$1$ebnf$1\", \"symbols\": [\"Measure$macrocall$1$ebnf$1\", \"Measure$macrocall$1$ebnf$1$subexpression$1\"], \"postprocess\": function arrpush(d) {return d[0].concat([d[1]]);}},\n    {\"name\": \"Measure$macrocall$1\", \"symbols\": [\"Measure$macrocall$2\", \"Measure$macrocall$1$ebnf$1\"], \"postprocess\": d => d[0].concat(d[1])},\n    {\"name\": \"Measure\", \"symbols\": [\"Measure$macrocall$1\"], \"postprocess\": d => new _ast_ast_nodes_js__WEBPACK_IMPORTED_MODULE_1__[\"Measure\"](d[0])},\n    {\"name\": \"MelodicBeatLiteral\", \"symbols\": [\"BL_TimePart\", {\"literal\":\":\"}, \"BL_PitchPart\", {\"literal\":\":\"}, \"BL_OctavePart\"], \"postprocess\": d => new _ast_ast_nodes_js__WEBPACK_IMPORTED_MODULE_1__[\"MelodicBeatLiteral\"]({time: d[0], pitch: d[2], octave: d[4]})},\n    {\"name\": \"MelodicBeatLiteral\", \"symbols\": [{\"literal\":\":\"}, \"BL_PitchPart\", {\"literal\":\":\"}, \"BL_OctavePart\"], \"postprocess\": d => new _ast_ast_nodes_js__WEBPACK_IMPORTED_MODULE_1__[\"MelodicBeatLiteral\"]({pitch: d[1], octave: d[3]})},\n    {\"name\": \"MelodicBeatLiteral\", \"symbols\": [\"BL_TimePart\", {\"literal\":\":\"}, \"BL_PitchPart\"], \"postprocess\": d => new _ast_ast_nodes_js__WEBPACK_IMPORTED_MODULE_1__[\"MelodicBeatLiteral\"]({time: d[0], pitch: d[2]})},\n    {\"name\": \"MelodicBeatLiteral\", \"symbols\": [{\"literal\":\":\"}, \"BL_PitchPart\"], \"postprocess\": d => new _ast_ast_nodes_js__WEBPACK_IMPORTED_MODULE_1__[\"MelodicBeatLiteral\"]({pitch: d[1]})},\n    {\"name\": \"MelodicBeatLiteral\", \"symbols\": [\"DrumBeatLiteral\"], \"postprocess\": id},\n    {\"name\": \"BL_TimePart\", \"symbols\": [\"NumericExpression\"], \"postprocess\": d => ({time: d[0]})},\n    {\"name\": \"BL_TimePart\", \"symbols\": [\"BL_TP_Flag\"], \"postprocess\": d => ({time: 'auto', flag: d[0]})},\n    {\"name\": \"BL_TimePart\", \"symbols\": [\"NumericExpression\", \"BL_TP_Flag\"], \"postprocess\": d => ({time: d[0], flag: d[1]})},\n    {\"name\": \"BL_TP_Flag\", \"symbols\": [{\"literal\":\"s\"}], \"postprocess\": d => 'STACCATO'},\n    {\"name\": \"BL_TP_Flag\", \"symbols\": [{\"literal\":\"a\"}], \"postprocess\": d => 'ACCENTED'},\n    {\"name\": \"BL_PitchPart\", \"symbols\": [\"BL_PP_Degree\"], \"postprocess\": id},\n    {\"name\": \"BL_PitchPart\", \"symbols\": [\"BL_PP_Chord\"], \"postprocess\": id},\n    {\"name\": \"BL_PP_Degree\", \"symbols\": [\"NumberLiteral\"], \"postprocess\": d => ({degree: d[0]})},\n    {\"name\": \"BL_PP_Degree\", \"symbols\": [\"BL_PP_Anchor\"], \"postprocess\": d => ({anchor: d[0], degree: 1})},\n    {\"name\": \"BL_PP_Degree\", \"symbols\": [\"BL_PP_Anchor\", \"NumberLiteral\"], \"postprocess\": d => ({anchor: d[0], degree: d[1]})},\n    {\"name\": \"BL_PP_Chord\", \"symbols\": [{\"literal\":\"c\"}], \"postprocess\": d => ({chord: true, degree: 1})},\n    {\"name\": \"BL_PP_Chord\", \"symbols\": [\"BL_PP_Degree\", {\"literal\":\"c\"}], \"postprocess\": d => ({chord: true, anchor: d[0].anchor, degree: d[0].degree})},\n    {\"name\": \"BL_PP_Chord\", \"symbols\": [{\"literal\":\"c\"}, \"BL_PP_Roll\"], \"postprocess\": d => ({chord: true, roll: d[1], degree: 1})},\n    {\"name\": \"BL_PP_Chord\", \"symbols\": [\"BL_PP_Degree\", {\"literal\":\"c\"}, \"BL_PP_Roll\"], \"postprocess\": d => ({chord: true, roll: d[2], anchor: d[0].anchor, degree: d[0].degree})},\n    {\"name\": \"BL_PP_Anchor\", \"symbols\": [{\"literal\":\"k\"}], \"postprocess\": d => 'KEY'},\n    {\"name\": \"BL_PP_Anchor\", \"symbols\": [{\"literal\":\"n\"}], \"postprocess\": d => 'NEXT'},\n    {\"name\": \"BL_PP_Anchor\", \"symbols\": [{\"literal\":\"s\"}], \"postprocess\": d => 'STEP'},\n    {\"name\": \"BL_PP_Anchor\", \"symbols\": [{\"literal\":\"a\"}], \"postprocess\": d => 'ARPEGGIATE'},\n    {\"name\": \"BL_PP_Roll\", \"symbols\": [{\"literal\":\"r\"}], \"postprocess\": d => 'ROLL_UP'},\n    {\"name\": \"BL_PP_Roll\", \"symbols\": [{\"literal\":\"r\"}, {\"literal\":\"d\"}], \"postprocess\": d => 'ROLL_DOWN'},\n    {\"name\": \"BL_OctavePart\", \"symbols\": [\"NumberLiteral\"], \"postprocess\": id},\n    {\"name\": \"DrumBeatGroupLiteral\", \"symbols\": [\"StringLiteral\", \"_?\", \"BeatGroupLiteral\"], \"postprocess\": d => new _ast_ast_nodes_js__WEBPACK_IMPORTED_MODULE_1__[\"DrumBeatGroupLiteral\"](d[0], d[2])},\n    {\"name\": \"DrumBeatGroupLiteral\", \"symbols\": [\"StringLiteral\", \"_?\", \"FunctionCallExpression\"], \"postprocess\": d => new _ast_ast_nodes_js__WEBPACK_IMPORTED_MODULE_1__[\"DrumBeatGroupLiteral\"](d[0], d[2])},\n    {\"name\": \"DrumBeatLiteral\", \"symbols\": [\"NumberLiteral\"], \"postprocess\": d => new _ast_ast_nodes_js__WEBPACK_IMPORTED_MODULE_1__[\"DrumBeatLiteral\"]({time: d[0]})},\n    {\"name\": \"DrumBeatLiteral\", \"symbols\": [\"NumberLiteral\", {\"literal\":\"a\"}], \"postprocess\": d => new _ast_ast_nodes_js__WEBPACK_IMPORTED_MODULE_1__[\"DrumBeatLiteral\"]({time: d[0], accented: true})},\n    {\"name\": \"NumericExpression\", \"symbols\": [\"NE_addsub\"], \"postprocess\": id},\n    {\"name\": \"NE_parens\", \"symbols\": [{\"literal\":\"(\"}, \"NE_addsub\", {\"literal\":\")\"}], \"postprocess\": d => d[1]},\n    {\"name\": \"NE_parens\", \"symbols\": [\"NumberLiteral\"], \"postprocess\": id},\n    {\"name\": \"NE_muldiv\", \"symbols\": [\"NE_muldiv\", {\"literal\":\"*\"}, \"NE_parens\"], \"postprocess\": d => (d[0] * d[2])},\n    {\"name\": \"NE_muldiv\", \"symbols\": [\"NE_muldiv\", {\"literal\":\"/\"}, \"NE_parens\"], \"postprocess\": d => (d[0] / d[2])},\n    {\"name\": \"NE_muldiv\", \"symbols\": [\"NE_parens\"], \"postprocess\": id},\n    {\"name\": \"NE_addsub\", \"symbols\": [\"NE_addsub\", {\"literal\":\"+\"}, \"NE_muldiv\"], \"postprocess\": d => (d[0] + d[2])},\n    {\"name\": \"NE_addsub\", \"symbols\": [\"NE_addsub\", {\"literal\":\"-\"}, \"NE_muldiv\"], \"postprocess\": d => (d[0] - d[2])},\n    {\"name\": \"NE_addsub\", \"symbols\": [\"NE_muldiv\"], \"postprocess\": id},\n    {\"name\": \"Identifier\", \"symbols\": [(_lexer_lexer_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].has(\"identifier\") ? {type: \"identifier\"} : identifier)], \"postprocess\": d => d[0].value},\n    {\"name\": \"NumberLiteral\", \"symbols\": [(_lexer_lexer_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].has(\"number\") ? {type: \"number\"} : number)], \"postprocess\": d => Number(d[0].value)},\n    {\"name\": \"NumberLiteral\", \"symbols\": [(_lexer_lexer_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].has(\"beat_number\") ? {type: \"beat_number\"} : beat_number)], \"postprocess\": d => Number(d[0].value)},\n    {\"name\": \"BooleanLiteral\", \"symbols\": [(_lexer_lexer_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].has(\"boolean\") ? {type: \"boolean\"} : boolean)], \"postprocess\": d => Boolean(d[0].value)},\n    {\"name\": \"StringLiteral\", \"symbols\": [(_lexer_lexer_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].has(\"quoted_string\") ? {type: \"quoted_string\"} : quoted_string)], \"postprocess\": d => d[0].value.slice(1, -1)},\n    {\"name\": \"_?$ebnf$1\", \"symbols\": [\"_\"], \"postprocess\": id},\n    {\"name\": \"_?$ebnf$1\", \"symbols\": [], \"postprocess\": function(d) {return null;}},\n    {\"name\": \"_?\", \"symbols\": [\"_?$ebnf$1\"], \"postprocess\": () => null},\n    {\"name\": \"_\", \"symbols\": [(_lexer_lexer_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].has(\"ws\") ? {type: \"ws\"} : ws)], \"postprocess\": () => null},\n    {\"name\": \"_\", \"symbols\": [(_lexer_lexer_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].has(\"beat_ws\") ? {type: \"beat_ws\"} : beat_ws)], \"postprocess\": () => null},\n    {\"name\": \"_$ebnf$1\", \"symbols\": [(_lexer_lexer_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].has(\"ws\") ? {type: \"ws\"} : ws)], \"postprocess\": id},\n    {\"name\": \"_$ebnf$1\", \"symbols\": [], \"postprocess\": function(d) {return null;}},\n    {\"name\": \"_$ebnf$2$subexpression$1$ebnf$1\", \"symbols\": [(_lexer_lexer_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].has(\"ws\") ? {type: \"ws\"} : ws)], \"postprocess\": id},\n    {\"name\": \"_$ebnf$2$subexpression$1$ebnf$1\", \"symbols\": [], \"postprocess\": function(d) {return null;}},\n    {\"name\": \"_$ebnf$2$subexpression$1\", \"symbols\": [(_lexer_lexer_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].has(\"comment\") ? {type: \"comment\"} : comment), \"_$ebnf$2$subexpression$1$ebnf$1\"]},\n    {\"name\": \"_$ebnf$2\", \"symbols\": [\"_$ebnf$2$subexpression$1\"]},\n    {\"name\": \"_$ebnf$2$subexpression$2$ebnf$1\", \"symbols\": [(_lexer_lexer_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].has(\"ws\") ? {type: \"ws\"} : ws)], \"postprocess\": id},\n    {\"name\": \"_$ebnf$2$subexpression$2$ebnf$1\", \"symbols\": [], \"postprocess\": function(d) {return null;}},\n    {\"name\": \"_$ebnf$2$subexpression$2\", \"symbols\": [(_lexer_lexer_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].has(\"comment\") ? {type: \"comment\"} : comment), \"_$ebnf$2$subexpression$2$ebnf$1\"]},\n    {\"name\": \"_$ebnf$2\", \"symbols\": [\"_$ebnf$2\", \"_$ebnf$2$subexpression$2\"], \"postprocess\": function arrpush(d) {return d[0].concat([d[1]]);}},\n    {\"name\": \"_\", \"symbols\": [\"_$ebnf$1\", \"_$ebnf$2\"], \"postprocess\": () => null},\n    {\"name\": \"_$ebnf$3\", \"symbols\": [(_lexer_lexer_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].has(\"beat_ws\") ? {type: \"beat_ws\"} : beat_ws)], \"postprocess\": id},\n    {\"name\": \"_$ebnf$3\", \"symbols\": [], \"postprocess\": function(d) {return null;}},\n    {\"name\": \"_$ebnf$4$subexpression$1$ebnf$1\", \"symbols\": [(_lexer_lexer_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].has(\"beat_ws\") ? {type: \"beat_ws\"} : beat_ws)], \"postprocess\": id},\n    {\"name\": \"_$ebnf$4$subexpression$1$ebnf$1\", \"symbols\": [], \"postprocess\": function(d) {return null;}},\n    {\"name\": \"_$ebnf$4$subexpression$1\", \"symbols\": [(_lexer_lexer_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].has(\"comment\") ? {type: \"comment\"} : comment), \"_$ebnf$4$subexpression$1$ebnf$1\"]},\n    {\"name\": \"_$ebnf$4\", \"symbols\": [\"_$ebnf$4$subexpression$1\"]},\n    {\"name\": \"_$ebnf$4$subexpression$2$ebnf$1\", \"symbols\": [(_lexer_lexer_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].has(\"beat_ws\") ? {type: \"beat_ws\"} : beat_ws)], \"postprocess\": id},\n    {\"name\": \"_$ebnf$4$subexpression$2$ebnf$1\", \"symbols\": [], \"postprocess\": function(d) {return null;}},\n    {\"name\": \"_$ebnf$4$subexpression$2\", \"symbols\": [(_lexer_lexer_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].has(\"comment\") ? {type: \"comment\"} : comment), \"_$ebnf$4$subexpression$2$ebnf$1\"]},\n    {\"name\": \"_$ebnf$4\", \"symbols\": [\"_$ebnf$4\", \"_$ebnf$4$subexpression$2\"], \"postprocess\": function arrpush(d) {return d[0].concat([d[1]]);}},\n    {\"name\": \"_\", \"symbols\": [\"_$ebnf$3\", \"_$ebnf$4\"], \"postprocess\": () => null}\n];\nlet ParserStart = \"main\";\n/* harmony default export */ __webpack_exports__[\"default\"] = ({ Lexer, ParserRules, ParserStart });\n\n\n//# sourceURL=webpack:///./src/parser/grammar.js?");

/***/ }),

/***/ "./src/parser/parser.js":
/*!******************************!*\
  !*** ./src/parser/parser.js ***!
  \******************************/
/*! exports provided: string_to_ast, parse */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"string_to_ast\", function() { return string_to_ast; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"parse\", function() { return parse; });\n/* harmony import */ var _lib_nearley_nearley_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/nearley/nearley.js */ \"./src/lib/nearley/nearley.js\");\n/* harmony import */ var _grammar_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./grammar.js */ \"./src/parser/grammar.js\");\n\n\n/**\n * Parses a string into a set of possible abstract systax trees (ASTs) trees of\n * objects representing the syntax of the file.\n * @param {string} data The string to parse\n * @return {Promise.<Array>.<GlobalScope>} A promise that resolves to an array\n * of parsings, each of which is an AST. (Ideally there should be 1 parsing.)\n *\n * See ast_nodes.js or the grammar itself for an idea of what the nodes in the\n * tree might look like.\n * @private\n */\nlet string_to_ast = function string_to_ast(data) {\n  // Create a Parser object from our grammar.\n  // (I don't think you can reset the parser so make a new one each time)\n  const parser = new _lib_nearley_nearley_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Parser(_lib_nearley_nearley_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Grammar.fromCompiled(_grammar_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]));\n  \n  return new Promise(function(resolve, reject) {\n    try {\n      parser.feed(data);\n    } catch(err) {\n      // Because tabs screw up the formatting of SyntaxError messages.\n      err.message = err.message.replace(/\\t/g, ' ');\n      reject(err);\n    }\n    resolve(parser.results);\n  });\n};\n\n/**\n * Parse a string into an Abstract Syntax Tree (AST) -- a tree of objects\n * representing the syntax of the file.\n * @param {string}  data The string to parse\n * @return {Promise.<GlobalScope>} The Abstract Systax Tree (AST).\n */\n let parse = function parse(data) {\n   return new Promise(function(resolve, reject) {\n     string_to_ast(data)\n       .then(parses => {\n         if(!parses.length) {\n           throw new SyntaxError('Something went wrong, input not parseable.');\n         }\n         resolve(parses[0]);\n       });\n   });\n };\n\n\n//# sourceURL=webpack:///./src/parser/parser.js?");

/***/ }),

/***/ "./src/parser/test/test.js":
/*!*********************************!*\
  !*** ./src/parser/test/test.js ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _loader_loader_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../loader/loader.js */ \"./src/loader/loader-node.js\");\n/* harmony import */ var _parser_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../parser.js */ \"./src/parser/parser.js\");\n/* harmony import */ var assert__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! assert */ \"assert\");\n/* harmony import */ var assert__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(assert__WEBPACK_IMPORTED_MODULE_2__);\n\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function() {\n  \n  // load a couple test files\n  // yes one promise can have multiple thens, I checked in chrome console\n  let styles_dir = './src/parser/test/styles/';\n  let file_ambig = Object(_loader_loader_js__WEBPACK_IMPORTED_MODULE_0__[\"load\"])(styles_dir + 'ambig.play');\n  let file_example = Object(_loader_loader_js__WEBPACK_IMPORTED_MODULE_0__[\"load\"])(styles_dir + 'example.play');\n  \n  /**\n   * Parser smoketest: try parsing an old/modified version of the swing style\n   * (this is the file I add new features to when I'm modifying the grammar)\n   */\n  file_example.then(_parser_js__WEBPACK_IMPORTED_MODULE_1__[\"parse\"]).then(ast => {\n    ast.init()\n    // assert.ok(ast.tracks[0] typeof Track);\n  });\n  \n  /** test for grammar ambiguities with:\n   *  - \"|\" and \"&\"-separated lists\n   *  - whitespace-separated lists\n   *  - multiple lines of // comments\n   */\n  file_ambig\n    .then(_parser_js__WEBPACK_IMPORTED_MODULE_1__[\"string_to_ast\"])\n    .then(results => {\n      assert__WEBPACK_IMPORTED_MODULE_2___default.a.equal(results.length, 1, 'expected 1 parse (grammar ambiguous)');\n    });\n});;\n\n\n//# sourceURL=webpack:///./src/parser/test/test.js?");

/***/ }),

/***/ "./test/song.js":
/*!**********************!*\
  !*** ./test/song.js ***!
  \**********************/
/*! exports provided: Song */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Song\", function() { return Song; });\n/*\n* Everything in this file will move soon, this is just for testing rn\n*/\n\n/**\n * An array-like object that represents a song\n */\nclass Song extends Array {\n  constructor(measures) {\n    super(...measures);\n    this._idx = -1;\n  }\n  getKey() {\n    return this[0][0];\n  }\n  [Symbol.iterator]() {\n    return new SongIterator(this);\n  }\n}\n\n/**\n * An extension to the Iterator protocol with some extra bits for our enjoyment\n */\nclass SongIterator {\n  constructor(song) {\n    this.song = song;\n    this.index = -1;\n  }\n  next() {\n    if(++this.index < this.song.length) {\n      return {value: this.song[this.index], done: false};\n    } else {\n      return {value: undefined, done: true};\n    }\n  }\n  get(idx) {\n    return this.song[idx];\n  }\n  getRelative(dist = 0) {\n    return this.song[this.index + dist];\n  }\n}\n\n//# sourceURL=webpack:///./test/song.js?");

/***/ }),

/***/ "./test/test.js":
/*!**********************!*\
  !*** ./test/test.js ***!
  \**********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _src_parser_test_test_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../src/parser/test/test.js */ \"./src/parser/test/test.js\");\n/* harmony import */ var _song_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./song.js */ \"./test/song.js\");\n/* harmony import */ var _src_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../src/index.js */ \"./src/index.js\");\n\n\n\n\n//const verbose = process.argv.includes('--verbose');\n\n// run parser tests\nObject(_src_parser_test_test_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])();\n\n// @TODO: have a set of tests directly on playback.js to make sure the apis\n// export correctly cuz webpack is being iffy about that\n\n(async function() {\n  let song = new _song_js__WEBPACK_IMPORTED_MODULE_1__[\"Song\"]([\n    // Each array is a measure, and each item in an array is a beat.\n    // null inside a measure means there's no chord set for that beat.\n    ['A-', null, null, null], ['E', null, null, null], ['A-7', null, null, null], ['A-6', null, null, null],\n    ['CM7', null, 'A7', null], ['D-7', null, 'G7', null], ['C6', null, null, null], ['Bdim7', null, 'E7', null],\n    ['A-', null, null, null], ['E', null, null, null], ['A-7', null, null, null], ['A-6', null, null, null],\n    ['CM7', null, 'A7', null], ['D-7', null, 'G7', null], ['C6', null, null, null], ['C6', null, null, null]\n  ]);\n\n  let style = new _src_index_js__WEBPACK_IMPORTED_MODULE_2__[\"PlaybackStyle\"]('./test/styles/example.play');\n  await style.init();\n  style.play(song);\n})();\n\n//# sourceURL=webpack:///./test/test.js?");

/***/ }),

/***/ "assert":
/*!*************************!*\
  !*** external "assert" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"assert\");\n\n//# sourceURL=webpack:///external_%22assert%22?");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"fs\");\n\n//# sourceURL=webpack:///external_%22fs%22?");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"path\");\n\n//# sourceURL=webpack:///external_%22path%22?");

/***/ })

/******/ });