// Generated automatically by nearley, version 2.13.0
// http://github.com/Hardmath123/nearley
function id(x) { return x[0]; }

import lexer from '../lexer/lexer' ;
import * as ast from '../ast/ast_nodes';
import * as values from '../values/values';
let Lexer = lexer;
let ParserRules = [
    {"name": "main$macrocall$2", "symbols": ["TopLevelStatement"]},
    {"name": "main$macrocall$1$ebnf$1", "symbols": []},
    {"name": "main$macrocall$1$ebnf$1$subexpression$1", "symbols": ["_", "main$macrocall$2"], "postprocess": d => d[1][0]},
    {"name": "main$macrocall$1$ebnf$1", "symbols": ["main$macrocall$1$ebnf$1", "main$macrocall$1$ebnf$1$subexpression$1"], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "main$macrocall$1", "symbols": ["main$macrocall$2", "main$macrocall$1$ebnf$1"], "postprocess": d => d[0].concat(d[1])},
    {"name": "main", "symbols": ["_?", "main$macrocall$1", "_?"], "postprocess": d => new ast.GlobalScope(d[1])},
    {"name": "TopLevelStatement", "symbols": ["ConfigurationStatement"], "postprocess": id},
    {"name": "TopLevelStatement", "symbols": ["ImportStatement"], "postprocess": id},
    {"name": "TopLevelStatement", "symbols": ["TrackStatement"], "postprocess": id},
    {"name": "TopLevelStatement", "symbols": ["TrackCallStatement"], "postprocess": id},
    {"name": "ConfigurationStatement", "symbols": [{"literal":"@meta"}, "_?", {"literal":"{"}, "_?", "ConfigurationList", "_?", {"literal":"}"}], "postprocess": d => new ast.MetaStatement(d[4])},
    {"name": "ConfigurationStatement", "symbols": [{"literal":"@options"}, "_?", {"literal":"{"}, "_?", "ConfigurationList", "_?", {"literal":"}"}], "postprocess": d => new ast.OptionsStatement(d[4])},
    {"name": "ConfigurationList$macrocall$2", "symbols": ["FunctionCallExpression"]},
    {"name": "ConfigurationList$macrocall$1$ebnf$1", "symbols": []},
    {"name": "ConfigurationList$macrocall$1$ebnf$1$subexpression$1", "symbols": ["_", "ConfigurationList$macrocall$2"], "postprocess": d => d[1][0]},
    {"name": "ConfigurationList$macrocall$1$ebnf$1", "symbols": ["ConfigurationList$macrocall$1$ebnf$1", "ConfigurationList$macrocall$1$ebnf$1$subexpression$1"], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "ConfigurationList$macrocall$1", "symbols": ["ConfigurationList$macrocall$2", "ConfigurationList$macrocall$1$ebnf$1"], "postprocess": d => d[0].concat(d[1])},
    {"name": "ConfigurationList", "symbols": ["ConfigurationList$macrocall$1"], "postprocess": id},
    {"name": "ImportStatement", "symbols": [{"literal":"@import"}, "_", "StringLiteral", "_", {"literal":"as"}, "_", "Identifier"], "postprocess": d => new ast.ImportStatement(d[2], d[6])},
    {"name": "TrackStatement$macrocall$2", "symbols": ["TrackMember"]},
    {"name": "TrackStatement$macrocall$1$ebnf$1", "symbols": []},
    {"name": "TrackStatement$macrocall$1$ebnf$1$subexpression$1", "symbols": ["_", "TrackStatement$macrocall$2"], "postprocess": d => d[1][0]},
    {"name": "TrackStatement$macrocall$1$ebnf$1", "symbols": ["TrackStatement$macrocall$1$ebnf$1", "TrackStatement$macrocall$1$ebnf$1$subexpression$1"], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "TrackStatement$macrocall$1", "symbols": ["TrackStatement$macrocall$2", "TrackStatement$macrocall$1$ebnf$1"], "postprocess": d => d[0].concat(d[1])},
    {"name": "TrackStatement", "symbols": [{"literal":"@track"}, "_", "StringLiteral", "_", {"literal":"as"}, "_", "Identifier", "_?", {"literal":"{"}, "_?", "TrackStatement$macrocall$1", "_?", {"literal":"}"}], "postprocess": d => new ast.TrackStatement({instrument: d[2], identifier: d[6], members: d[10]})},
    {"name": "TrackMember", "symbols": ["FunctionCallExpression"], "postprocess": id},
    {"name": "TrackMember", "symbols": ["PatternStatement"], "postprocess": id},
    {"name": "TrackMember", "symbols": ["PatternCallExpression"], "postprocess": id},
    {"name": "TrackCallStatement", "symbols": [{"literal":"@track"}, "_?", {"literal":"("}, "_?", "Identifier", {"literal":"."}, "Identifier", "_?", {"literal":")"}], "postprocess": d => new ast.TrackCall({import: d[4], track: d[6]})},
    {"name": "PatternStatement", "symbols": [{"literal":"@pattern"}, "_", "Identifier", "_", "PatternConditional", "_?", "PatternExpression"], "postprocess": d => new ast.PatternStatement({identifier: d[2], expression: d[6], condition: d[4]})},
    {"name": "PatternStatement", "symbols": [{"literal":"@pattern"}, "_", "Identifier", "_", "PatternExpression"], "postprocess": d => new ast.PatternStatement({identifier: d[2], expression: d[4]})},
    {"name": "PatternConditional", "symbols": [{"literal":"if"}, "_?", {"literal":"("}, "_?", "FunctionCallArgument", "_?", {"literal":")"}], "postprocess": d => d[4]},
    {"name": "PatternExpression", "symbols": ["PatternExpression_NoJoin"], "postprocess": id},
    {"name": "PatternExpression", "symbols": ["JoinedPatternExpression"], "postprocess": id},
    {"name": "PatternExpression_NoJoin", "symbols": ["PatternExpressionGroup"], "postprocess": id},
    {"name": "PatternExpression_NoJoin", "symbols": ["BeatGroupLiteral"], "postprocess": id},
    {"name": "PatternExpression_NoJoin", "symbols": ["DrumBeatGroupLiteral"], "postprocess": id},
    {"name": "PatternExpression_NoJoin", "symbols": ["FunctionCallExpression"], "postprocess": id},
    {"name": "PatternExpression_NoJoin", "symbols": ["PatternCallExpression"], "postprocess": id},
    {"name": "PatternExpressionGroup$macrocall$2", "symbols": ["PatternExpression"]},
    {"name": "PatternExpressionGroup$macrocall$1$ebnf$1", "symbols": []},
    {"name": "PatternExpressionGroup$macrocall$1$ebnf$1$subexpression$1", "symbols": ["_", "PatternExpressionGroup$macrocall$2"], "postprocess": d => d[1][0]},
    {"name": "PatternExpressionGroup$macrocall$1$ebnf$1", "symbols": ["PatternExpressionGroup$macrocall$1$ebnf$1", "PatternExpressionGroup$macrocall$1$ebnf$1$subexpression$1"], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "PatternExpressionGroup$macrocall$1", "symbols": ["PatternExpressionGroup$macrocall$2", "PatternExpressionGroup$macrocall$1$ebnf$1"], "postprocess": d => d[0].concat(d[1])},
    {"name": "PatternExpressionGroup", "symbols": [{"literal":"{"}, "_?", "PatternExpressionGroup$macrocall$1", "_?", {"literal":"}"}], "postprocess": d => new ast.PatternExpressionGroup(d[2])},
    {"name": "PatternCallExpression", "symbols": [{"literal":"@pattern"}, "_?", {"literal":"("}, "_?", "Identifier", "_?", {"literal":")"}], "postprocess": d => new ast.PatternCall({pattern: d[4]})},
    {"name": "PatternCallExpression", "symbols": [{"literal":"@pattern"}, "_?", {"literal":"("}, "_?", "Identifier", {"literal":"."}, "Identifier", "_?", {"literal":")"}], "postprocess": d => new ast.PatternCall({track: d[4], pattern: d[6]})},
    {"name": "PatternCallExpression", "symbols": [{"literal":"@pattern"}, "_?", {"literal":"("}, "_?", "Identifier", {"literal":"."}, "Identifier", {"literal":"."}, "Identifier", "_?", {"literal":")"}], "postprocess": d => new ast.PatternCall({import: d[4], track: d[6], pattern: d[8]})},
    {"name": "JoinedPatternExpression$macrocall$2", "symbols": ["PatternExpression_NoJoin"]},
    {"name": "JoinedPatternExpression$macrocall$3", "symbols": [{"literal":"&"}]},
    {"name": "JoinedPatternExpression$macrocall$1$ebnf$1$subexpression$1", "symbols": ["_?", "JoinedPatternExpression$macrocall$3", "_?", "JoinedPatternExpression$macrocall$2"], "postprocess": d => d[3][0]},
    {"name": "JoinedPatternExpression$macrocall$1$ebnf$1", "symbols": ["JoinedPatternExpression$macrocall$1$ebnf$1$subexpression$1"]},
    {"name": "JoinedPatternExpression$macrocall$1$ebnf$1$subexpression$2", "symbols": ["_?", "JoinedPatternExpression$macrocall$3", "_?", "JoinedPatternExpression$macrocall$2"], "postprocess": d => d[3][0]},
    {"name": "JoinedPatternExpression$macrocall$1$ebnf$1", "symbols": ["JoinedPatternExpression$macrocall$1$ebnf$1", "JoinedPatternExpression$macrocall$1$ebnf$1$subexpression$2"], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "JoinedPatternExpression$macrocall$1", "symbols": ["JoinedPatternExpression$macrocall$2", "JoinedPatternExpression$macrocall$1$ebnf$1"], "postprocess": d => d[0].concat(d[1])},
    {"name": "JoinedPatternExpression", "symbols": ["JoinedPatternExpression$macrocall$1"], "postprocess": d => new ast.JoinedPatternExpression(d[0])},
    {"name": "FunctionCallExpression$macrocall$2", "symbols": ["FunctionCallArgument"]},
    {"name": "FunctionCallExpression$macrocall$1$ebnf$1", "symbols": []},
    {"name": "FunctionCallExpression$macrocall$1$ebnf$1$subexpression$1", "symbols": ["_", "FunctionCallExpression$macrocall$2"], "postprocess": d => d[1][0]},
    {"name": "FunctionCallExpression$macrocall$1$ebnf$1", "symbols": ["FunctionCallExpression$macrocall$1$ebnf$1", "FunctionCallExpression$macrocall$1$ebnf$1$subexpression$1"], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "FunctionCallExpression$macrocall$1", "symbols": ["FunctionCallExpression$macrocall$2", "FunctionCallExpression$macrocall$1$ebnf$1"], "postprocess": d => d[0].concat(d[1])},
    {"name": "FunctionCallExpression", "symbols": ["Identifier", "_?", {"literal":"("}, "_?", "FunctionCallExpression$macrocall$1", "_?", {"literal":")"}], "postprocess": d => new ast.FunctionCall(d[0], d[4])},
    {"name": "FunctionCallExpression", "symbols": ["Identifier", "_?", {"literal":"("}, {"literal":")"}], "postprocess": d => new ast.FunctionCall(d[0], [])},
    {"name": "FunctionCallArgument", "symbols": ["NumericExpression"], "postprocess": d => new values.PlaybackNumberValue(d[0])},
    {"name": "FunctionCallArgument", "symbols": ["StringLiteral"], "postprocess": d => new values.PlaybackStringValue(d[0])},
    {"name": "FunctionCallArgument", "symbols": ["BooleanLiteral"], "postprocess": d => new values.PlaybackBooleanValue(d[0])},
    {"name": "FunctionCallArgument", "symbols": ["PatternExpression"], "postprocess": id},
    {"name": "FunctionCallArgument", "symbols": ["BL_PP_Anchor"], "postprocess": d => new values.PlaybackAnchorValue(d[0])},
    {"name": "FunctionCallArgument", "symbols": [{"literal":"not"}, "_", "FunctionCallArgument"], "postprocess": d => new ast.BooleanNot(d[2])},
    {"name": "FunctionCallArgument", "symbols": ["FunctionCallArgument", "_", {"literal":"and"}, "_", "FunctionCallArgument"], "postprocess": d => new ast.BooleanAnd(d[0], d[4])},
    {"name": "FunctionCallArgument", "symbols": ["FunctionCallArgument", "_", {"literal":"or"}, "_", "FunctionCallArgument"], "postprocess": d => new ast.BooleanOr(d[0], d[4])},
    {"name": "BeatGroupLiteral", "symbols": [{"literal":"<"}, "_?", "MeasureGroup", "_?", {"literal":">"}], "postprocess": d => new ast.BeatGroupLiteral(d[2])},
    {"name": "MeasureGroup$macrocall$2", "symbols": ["Measure"]},
    {"name": "MeasureGroup$macrocall$3", "symbols": [{"literal":"|"}]},
    {"name": "MeasureGroup$macrocall$1$ebnf$1", "symbols": []},
    {"name": "MeasureGroup$macrocall$1$ebnf$1$subexpression$1", "symbols": ["_?", "MeasureGroup$macrocall$3", "_?", "MeasureGroup$macrocall$2"], "postprocess": d => d[3][0]},
    {"name": "MeasureGroup$macrocall$1$ebnf$1", "symbols": ["MeasureGroup$macrocall$1$ebnf$1", "MeasureGroup$macrocall$1$ebnf$1$subexpression$1"], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "MeasureGroup$macrocall$1", "symbols": ["MeasureGroup$macrocall$2", "MeasureGroup$macrocall$1$ebnf$1"], "postprocess": d => d[0].concat(d[1])},
    {"name": "MeasureGroup", "symbols": ["MeasureGroup$macrocall$1"], "postprocess": id},
    {"name": "Measure$macrocall$2", "symbols": ["MelodicBeatLiteral"]},
    {"name": "Measure$macrocall$1$ebnf$1", "symbols": []},
    {"name": "Measure$macrocall$1$ebnf$1$subexpression$1", "symbols": ["_", "Measure$macrocall$2"], "postprocess": d => d[1][0]},
    {"name": "Measure$macrocall$1$ebnf$1", "symbols": ["Measure$macrocall$1$ebnf$1", "Measure$macrocall$1$ebnf$1$subexpression$1"], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "Measure$macrocall$1", "symbols": ["Measure$macrocall$2", "Measure$macrocall$1$ebnf$1"], "postprocess": d => d[0].concat(d[1])},
    {"name": "Measure", "symbols": ["Measure$macrocall$1"], "postprocess": d => new ast.Measure(d[0])},
    {"name": "MelodicBeatLiteral", "symbols": ["BL_TimePart", {"literal":":"}, "BL_PitchPart", {"literal":":"}, "BL_OctavePart"], "postprocess": d => new ast.MelodicBeatLiteral({time: d[0], pitch: d[2], octave: d[4]})},
    {"name": "MelodicBeatLiteral", "symbols": [{"literal":":"}, "BL_PitchPart", {"literal":":"}, "BL_OctavePart"], "postprocess": d => new ast.MelodicBeatLiteral({pitch: d[1], octave: d[3]})},
    {"name": "MelodicBeatLiteral", "symbols": ["BL_TimePart", {"literal":":"}, "BL_PitchPart"], "postprocess": d => new ast.MelodicBeatLiteral({time: d[0], pitch: d[2]})},
    {"name": "MelodicBeatLiteral", "symbols": [{"literal":":"}, "BL_PitchPart"], "postprocess": d => new ast.MelodicBeatLiteral({pitch: d[1]})},
    {"name": "MelodicBeatLiteral", "symbols": ["DrumBeatLiteral"], "postprocess": id},
    {"name": "BL_TimePart", "symbols": ["NumericExpression"], "postprocess": d => ({time: d[0]})},
    {"name": "BL_TimePart", "symbols": ["BL_TP_Flag"], "postprocess": d => ({time: 'auto', flag: d[0]})},
    {"name": "BL_TimePart", "symbols": ["NumericExpression", "BL_TP_Flag"], "postprocess": d => ({time: d[0], flag: d[1]})},
    {"name": "BL_TP_Flag", "symbols": [{"literal":"s"}], "postprocess": d => 'STACCATO'},
    {"name": "BL_TP_Flag", "symbols": [{"literal":"a"}], "postprocess": d => 'ACCENTED'},
    {"name": "BL_PitchPart", "symbols": ["BL_PP_Degree"], "postprocess": id},
    {"name": "BL_PitchPart", "symbols": ["BL_PP_Chord"], "postprocess": id},
    {"name": "BL_PP_Degree", "symbols": ["NumberLiteral"], "postprocess": d => ({degree: d[0]})},
    {"name": "BL_PP_Degree", "symbols": ["BL_PP_Anchor"], "postprocess": d => ({anchor: d[0], degree: 1})},
    {"name": "BL_PP_Degree", "symbols": ["BL_PP_Anchor", "NumberLiteral"], "postprocess": d => ({anchor: d[0], degree: d[1]})},
    {"name": "BL_PP_Chord", "symbols": [{"literal":"c"}], "postprocess": d => ({chord: true, degree: 1})},
    {"name": "BL_PP_Chord", "symbols": ["BL_PP_Degree", {"literal":"c"}], "postprocess": d => ({chord: true, anchor: d[0].anchor, degree: d[0].degree})},
    {"name": "BL_PP_Chord", "symbols": [{"literal":"c"}, "BL_PP_Roll"], "postprocess": d => ({chord: true, roll: d[1], degree: 1})},
    {"name": "BL_PP_Chord", "symbols": ["BL_PP_Degree", {"literal":"c"}, "BL_PP_Roll"], "postprocess": d => ({chord: true, roll: d[2], anchor: d[0].anchor, degree: d[0].degree})},
    {"name": "BL_PP_Anchor", "symbols": [{"literal":"k"}], "postprocess": d => 'KEY'},
    {"name": "BL_PP_Anchor", "symbols": [{"literal":"n"}], "postprocess": d => 'NEXT'},
    {"name": "BL_PP_Anchor", "symbols": [{"literal":"s"}], "postprocess": d => 'STEP'},
    {"name": "BL_PP_Anchor", "symbols": [{"literal":"a"}], "postprocess": d => 'ARPEGGIATE'},
    {"name": "BL_PP_Roll", "symbols": [{"literal":"r"}], "postprocess": d => 'ROLL_UP'},
    {"name": "BL_PP_Roll", "symbols": [{"literal":"r"}, {"literal":"d"}], "postprocess": d => 'ROLL_DOWN'},
    {"name": "BL_OctavePart", "symbols": ["NumberLiteral"], "postprocess": id},
    {"name": "DrumBeatGroupLiteral", "symbols": ["StringLiteral", "_?", "BeatGroupLiteral"], "postprocess": d => new ast.DrumBeatGroupLiteral(d[0], d[2])},
    {"name": "DrumBeatGroupLiteral", "symbols": ["StringLiteral", "_?", "FunctionCallExpression"], "postprocess": d => new ast.DrumBeatGroupLiteral(d[0], d[2])},
    {"name": "DrumBeatLiteral", "symbols": ["NumberLiteral"], "postprocess": d => new ast.DrumBeatLiteral({time: d[0]})},
    {"name": "DrumBeatLiteral", "symbols": ["NumberLiteral", {"literal":"a"}], "postprocess": d => new ast.DrumBeatLiteral({time: d[0], accented: true})},
    {"name": "NumericExpression", "symbols": ["NE_addsub"], "postprocess": id},
    {"name": "NE_parens", "symbols": [{"literal":"("}, "NE_addsub", {"literal":")"}], "postprocess": d => d[1]},
    {"name": "NE_parens", "symbols": ["NumberLiteral"], "postprocess": id},
    {"name": "NE_muldiv", "symbols": ["NE_muldiv", {"literal":"*"}, "NE_parens"], "postprocess": d => (d[0] * d[2])},
    {"name": "NE_muldiv", "symbols": ["NE_muldiv", {"literal":"/"}, "NE_parens"], "postprocess": d => (d[0] / d[2])},
    {"name": "NE_muldiv", "symbols": ["NE_parens"], "postprocess": id},
    {"name": "NE_addsub", "symbols": ["NE_addsub", {"literal":"+"}, "NE_muldiv"], "postprocess": d => (d[0] + d[2])},
    {"name": "NE_addsub", "symbols": ["NE_addsub", {"literal":"-"}, "NE_muldiv"], "postprocess": d => (d[0] - d[2])},
    {"name": "NE_addsub", "symbols": ["NE_muldiv"], "postprocess": id},
    {"name": "Identifier", "symbols": [(lexer.has("identifier") ? {type: "identifier"} : identifier)], "postprocess": d => d[0].value},
    {"name": "NumberLiteral", "symbols": [(lexer.has("number") ? {type: "number"} : number)], "postprocess": d => Number(d[0].value)},
    {"name": "NumberLiteral", "symbols": [(lexer.has("beat_number") ? {type: "beat_number"} : beat_number)], "postprocess": d => Number(d[0].value)},
    {"name": "BooleanLiteral", "symbols": [(lexer.has("boolean") ? {type: "boolean"} : boolean)], "postprocess": d => Boolean(d[0].value)},
    {"name": "StringLiteral", "symbols": [(lexer.has("quoted_string") ? {type: "quoted_string"} : quoted_string)], "postprocess": d => d[0].value.slice(1, -1)},
    {"name": "_?$ebnf$1", "symbols": ["_"], "postprocess": id},
    {"name": "_?$ebnf$1", "symbols": [], "postprocess": function(d) {return null;}},
    {"name": "_?", "symbols": ["_?$ebnf$1"], "postprocess": () => null},
    {"name": "_", "symbols": [(lexer.has("ws") ? {type: "ws"} : ws)], "postprocess": () => null},
    {"name": "_", "symbols": [(lexer.has("beat_ws") ? {type: "beat_ws"} : beat_ws)], "postprocess": () => null},
    {"name": "_$ebnf$1", "symbols": [(lexer.has("ws") ? {type: "ws"} : ws)], "postprocess": id},
    {"name": "_$ebnf$1", "symbols": [], "postprocess": function(d) {return null;}},
    {"name": "_$ebnf$2$subexpression$1$ebnf$1", "symbols": [(lexer.has("ws") ? {type: "ws"} : ws)], "postprocess": id},
    {"name": "_$ebnf$2$subexpression$1$ebnf$1", "symbols": [], "postprocess": function(d) {return null;}},
    {"name": "_$ebnf$2$subexpression$1", "symbols": [(lexer.has("comment") ? {type: "comment"} : comment), "_$ebnf$2$subexpression$1$ebnf$1"]},
    {"name": "_$ebnf$2", "symbols": ["_$ebnf$2$subexpression$1"]},
    {"name": "_$ebnf$2$subexpression$2$ebnf$1", "symbols": [(lexer.has("ws") ? {type: "ws"} : ws)], "postprocess": id},
    {"name": "_$ebnf$2$subexpression$2$ebnf$1", "symbols": [], "postprocess": function(d) {return null;}},
    {"name": "_$ebnf$2$subexpression$2", "symbols": [(lexer.has("comment") ? {type: "comment"} : comment), "_$ebnf$2$subexpression$2$ebnf$1"]},
    {"name": "_$ebnf$2", "symbols": ["_$ebnf$2", "_$ebnf$2$subexpression$2"], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "_", "symbols": ["_$ebnf$1", "_$ebnf$2"], "postprocess": () => null},
    {"name": "_$ebnf$3", "symbols": [(lexer.has("beat_ws") ? {type: "beat_ws"} : beat_ws)], "postprocess": id},
    {"name": "_$ebnf$3", "symbols": [], "postprocess": function(d) {return null;}},
    {"name": "_$ebnf$4$subexpression$1$ebnf$1", "symbols": [(lexer.has("beat_ws") ? {type: "beat_ws"} : beat_ws)], "postprocess": id},
    {"name": "_$ebnf$4$subexpression$1$ebnf$1", "symbols": [], "postprocess": function(d) {return null;}},
    {"name": "_$ebnf$4$subexpression$1", "symbols": [(lexer.has("comment") ? {type: "comment"} : comment), "_$ebnf$4$subexpression$1$ebnf$1"]},
    {"name": "_$ebnf$4", "symbols": ["_$ebnf$4$subexpression$1"]},
    {"name": "_$ebnf$4$subexpression$2$ebnf$1", "symbols": [(lexer.has("beat_ws") ? {type: "beat_ws"} : beat_ws)], "postprocess": id},
    {"name": "_$ebnf$4$subexpression$2$ebnf$1", "symbols": [], "postprocess": function(d) {return null;}},
    {"name": "_$ebnf$4$subexpression$2", "symbols": [(lexer.has("comment") ? {type: "comment"} : comment), "_$ebnf$4$subexpression$2$ebnf$1"]},
    {"name": "_$ebnf$4", "symbols": ["_$ebnf$4", "_$ebnf$4$subexpression$2"], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "_", "symbols": ["_$ebnf$3", "_$ebnf$4"], "postprocess": () => null}
];
let ParserStart = "main";
export default { Lexer, ParserRules, ParserStart };
