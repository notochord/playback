// Generated automatically by nearley, version 2.13.0
// http://github.com/Hardmath123/nearley
(function () {
function id(x) { return x[0]; }

const moo = require('moo');
const ast = require('./ast_nodes.js'); // TODO: rename this

const lexer = moo.states({
  main: {
    comment: {
      match:/\/\/.*?(?:\n|$)/, // consuming newline should be fine since this is _?. Can I do eof anchor here? Guess we'll find out 
      lineBreaks: true
    },
    quoted_string: /"(?:[^\\"\n]|\\.)*"/, // thanx https://stackoverflow.com/a/249937/1784306
    ws: {
      match: /\s+/,
      lineBreaks: true
    },
    at_rule: ['@meta', '@options', '@import', '@track', '@pattern'],
    identifier: {
      // start with alpha, may contain digits and dashes but not end with dash
      match: /[a-zA-z](?:[a-zA-Z\-\d]*[a-zA-Z\d])?/,
      keywords: {
        keyword: ['if', 'as'],
        boolean: ['true', 'false']
      }
    },
    number: /(?:\d*\.)?\d+/,
    brackets: ['{', '}', '(', ')'],
    left_angle: {match: '<', push: 'beat'},
    operators: ['&', '+', '-', '*', '/', '.']
  },
  beat: {
    beat_ws: / +/,
    beat_colon: ':',
    beat_number: /(?:\d*\.)?\d+/,
    beat_flag: /[a-zA-Z]/,
    beat_right_angle: {match: '>', pop: true},
    beat_operators: ['|', '+', '-', '*', '/']
  }
});
var grammar = {
    Lexer: lexer,
    ParserRules: [
    {"name": "main$macrocall$2", "symbols": ["TopLevelStatement"]},
    {"name": "main$macrocall$1$ebnf$1", "symbols": []},
    {"name": "main$macrocall$1$ebnf$1$subexpression$1", "symbols": ["_", "main$macrocall$2"], "postprocess": d => d[1][0]},
    {"name": "main$macrocall$1$ebnf$1", "symbols": ["main$macrocall$1$ebnf$1", "main$macrocall$1$ebnf$1$subexpression$1"], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "main$macrocall$1", "symbols": ["main$macrocall$2", "main$macrocall$1$ebnf$1"], "postprocess": d => d[0].concat(d[1])},
    {"name": "main", "symbols": ["_?", "main$macrocall$1", "_?"], "postprocess": d => d[1]},
    {"name": "TopLevelStatement", "symbols": ["ConfigurationStatement"], "postprocess": id},
    {"name": "TopLevelStatement", "symbols": ["TrackStatement"], "postprocess": id},
    {"name": "TopLevelStatement", "symbols": ["ImportStatement"], "postprocess": id},
    {"name": "ConfigurationStatement", "symbols": [{"literal":"@meta"}, "_?", {"literal":"{"}, "_?", "ConfigurationList", "_?", {"literal":"}"}], "postprocess": d => new ast.ConfigurationStatement({identifier: 'META', members: d[4]})},
    {"name": "ConfigurationStatement", "symbols": [{"literal":"@options"}, "_?", {"literal":"{"}, "_?", "ConfigurationList", "_?", {"literal":"}"}], "postprocess": d => new ast.ConfigurationStatement({identifier: 'OPTIONS', members: d[4]})},
    {"name": "ConfigurationList$macrocall$2", "symbols": ["FunctionCallExpression"]},
    {"name": "ConfigurationList$macrocall$1$ebnf$1", "symbols": []},
    {"name": "ConfigurationList$macrocall$1$ebnf$1$subexpression$1", "symbols": ["_", "ConfigurationList$macrocall$2"], "postprocess": d => d[1][0]},
    {"name": "ConfigurationList$macrocall$1$ebnf$1", "symbols": ["ConfigurationList$macrocall$1$ebnf$1", "ConfigurationList$macrocall$1$ebnf$1$subexpression$1"], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "ConfigurationList$macrocall$1", "symbols": ["ConfigurationList$macrocall$2", "ConfigurationList$macrocall$1$ebnf$1"], "postprocess": d => d[0].concat(d[1])},
    {"name": "ConfigurationList", "symbols": ["ConfigurationList$macrocall$1"], "postprocess": id},
    {"name": "ImportStatement", "symbols": [{"literal":"@import"}, "_", "StringLiteral", "_", {"literal":"as"}, "_", "Identifier"], "postprocess": d => new ast.ImportStatement({path: d[2], identifier: d[6]})},
    {"name": "TrackStatement$macrocall$2", "symbols": ["TrackMember"]},
    {"name": "TrackStatement$macrocall$1$ebnf$1", "symbols": []},
    {"name": "TrackStatement$macrocall$1$ebnf$1$subexpression$1", "symbols": ["_", "TrackStatement$macrocall$2"], "postprocess": d => d[1][0]},
    {"name": "TrackStatement$macrocall$1$ebnf$1", "symbols": ["TrackStatement$macrocall$1$ebnf$1", "TrackStatement$macrocall$1$ebnf$1$subexpression$1"], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "TrackStatement$macrocall$1", "symbols": ["TrackStatement$macrocall$2", "TrackStatement$macrocall$1$ebnf$1"], "postprocess": d => d[0].concat(d[1])},
    {"name": "TrackStatement", "symbols": [{"literal":"@track"}, "_", "StringLiteral", "_", {"literal":"as"}, "_", "Identifier", "_?", {"literal":"{"}, "_?", "TrackStatement$macrocall$1", "_?", {"literal":"}"}], "postprocess": d => new ast.TrackStatement({instrument: d[2], identifier: d[6], members: d[10]})},
    {"name": "TrackMember", "symbols": ["FunctionCallExpression"], "postprocess": id},
    {"name": "TrackMember", "symbols": ["PatternStatement"], "postprocess": id},
    {"name": "PatternStatement", "symbols": [{"literal":"@pattern"}, "_", "Identifier", "_", "PatternConditional", "_?", "PatternExpression"], "postprocess": d => new ast.PatternStatement({identifier: d[2], expression: d[6], condition: d[4]})},
    {"name": "PatternStatement", "symbols": [{"literal":"@pattern"}, "_", "Identifier", "_", "PatternExpression"], "postprocess": d => new ast.PatternStatement({identifier: d[2], expression: d[4]})},
    {"name": "PatternConditional", "symbols": [{"literal":"if"}, "_?", {"literal":"("}, "_?", "FunctionCallArgument", "_?", {"literal":")"}], "postprocess": d => d[4]},
    {"name": "PatternExpression", "symbols": ["PatternExpression_NoJoin"], "postprocess": id},
    {"name": "PatternExpression", "symbols": ["JoinedPatternExpression"], "postprocess": id},
    {"name": "PatternExpression_NoJoin", "symbols": ["PatternExpressionGroup"], "postprocess": id},
    {"name": "PatternExpression_NoJoin", "symbols": ["BeatGroupLiteral"], "postprocess": id},
    {"name": "PatternExpression_NoJoin", "symbols": ["DrumBeatGroupLiteral"], "postprocess": id},
    {"name": "PatternExpression_NoJoin", "symbols": ["FunctionCallExpression"], "postprocess": id},
    {"name": "PatternExpression_NoJoin", "symbols": ["PatternCallExpression"], "postprocess": id},
    {"name": "PatternExpressionGroup$macrocall$2", "symbols": ["PatternExpression"]},
    {"name": "PatternExpressionGroup$macrocall$1$ebnf$1", "symbols": []},
    {"name": "PatternExpressionGroup$macrocall$1$ebnf$1$subexpression$1", "symbols": ["_", "PatternExpressionGroup$macrocall$2"], "postprocess": d => d[1][0]},
    {"name": "PatternExpressionGroup$macrocall$1$ebnf$1", "symbols": ["PatternExpressionGroup$macrocall$1$ebnf$1", "PatternExpressionGroup$macrocall$1$ebnf$1$subexpression$1"], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "PatternExpressionGroup$macrocall$1", "symbols": ["PatternExpressionGroup$macrocall$2", "PatternExpressionGroup$macrocall$1$ebnf$1"], "postprocess": d => d[0].concat(d[1])},
    {"name": "PatternExpressionGroup", "symbols": [{"literal":"{"}, "_?", "PatternExpressionGroup$macrocall$1", "_?", {"literal":"}"}], "postprocess": d => new ast.PatternExpressionGroup(d[2])},
    {"name": "PatternCallExpression", "symbols": [{"literal":"@pattern"}, "_?", {"literal":"("}, "_?", "Identifier", "_?", {"literal":")"}], "postprocess": d => new ast.PatternCall({pattern: d[4], local: true})},
    {"name": "PatternCallExpression", "symbols": [{"literal":"@pattern"}, "_?", {"literal":"("}, "_?", "Identifier", {"literal":"."}, "Identifier", "_?", {"literal":")"}], "postprocess": d => new ast.PatternCall({instrument: d[4], pattern: d[6], local: false})},
    {"name": "JoinedPatternExpression$macrocall$2", "symbols": ["PatternExpression_NoJoin"]},
    {"name": "JoinedPatternExpression$macrocall$3", "symbols": [{"literal":"&"}]},
    {"name": "JoinedPatternExpression$macrocall$1$ebnf$1$subexpression$1", "symbols": ["_?", "JoinedPatternExpression$macrocall$3", "_?", "JoinedPatternExpression$macrocall$2"], "postprocess": d => d[3][0]},
    {"name": "JoinedPatternExpression$macrocall$1$ebnf$1", "symbols": ["JoinedPatternExpression$macrocall$1$ebnf$1$subexpression$1"]},
    {"name": "JoinedPatternExpression$macrocall$1$ebnf$1$subexpression$2", "symbols": ["_?", "JoinedPatternExpression$macrocall$3", "_?", "JoinedPatternExpression$macrocall$2"], "postprocess": d => d[3][0]},
    {"name": "JoinedPatternExpression$macrocall$1$ebnf$1", "symbols": ["JoinedPatternExpression$macrocall$1$ebnf$1", "JoinedPatternExpression$macrocall$1$ebnf$1$subexpression$2"], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "JoinedPatternExpression$macrocall$1", "symbols": ["JoinedPatternExpression$macrocall$2", "JoinedPatternExpression$macrocall$1$ebnf$1"], "postprocess": d => d[0].concat(d[1])},
    {"name": "JoinedPatternExpression", "symbols": ["JoinedPatternExpression$macrocall$1"], "postprocess": d => new ast.JoinedPatternExpression(d[0])},
    {"name": "FunctionCallExpression$macrocall$2", "symbols": ["FunctionCallArgument"]},
    {"name": "FunctionCallExpression$macrocall$1$ebnf$1", "symbols": []},
    {"name": "FunctionCallExpression$macrocall$1$ebnf$1$subexpression$1", "symbols": ["_", "FunctionCallExpression$macrocall$2"], "postprocess": d => d[1][0]},
    {"name": "FunctionCallExpression$macrocall$1$ebnf$1", "symbols": ["FunctionCallExpression$macrocall$1$ebnf$1", "FunctionCallExpression$macrocall$1$ebnf$1$subexpression$1"], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "FunctionCallExpression$macrocall$1", "symbols": ["FunctionCallExpression$macrocall$2", "FunctionCallExpression$macrocall$1$ebnf$1"], "postprocess": d => d[0].concat(d[1])},
    {"name": "FunctionCallExpression", "symbols": ["Identifier", "_?", {"literal":"("}, "_?", "FunctionCallExpression$macrocall$1", "_?", {"literal":")"}], "postprocess": d => new ast.FunctionCall(d[0], d[4])},
    {"name": "FunctionCallExpression", "symbols": ["Identifier", "_?", {"literal":"("}, {"literal":")"}], "postprocess": d => new ast.FunctionCall(d[0])},
    {"name": "FunctionCallArgument", "symbols": ["NumericExpression"], "postprocess": id},
    {"name": "FunctionCallArgument", "symbols": ["StringLiteral"], "postprocess": id},
    {"name": "FunctionCallArgument", "symbols": ["BooleanLiteral"], "postprocess": id},
    {"name": "FunctionCallArgument", "symbols": ["PatternExpression"], "postprocess": id},
    {"name": "FunctionCallArgument", "symbols": ["BL_PP_Anchor"], "postprocess": d => new ast.AnchorAsArgument(d[0])},
    {"name": "FunctionCallArgument", "symbols": [{"literal":"not"}, "_", "FunctionCallArgument"], "postprocess": d => new ast.BooleanNot(d[2])},
    {"name": "FunctionCallArgument", "symbols": ["FunctionCallArgument", "_", {"literal":"and"}, "_", "FunctionCallArgument"], "postprocess": d => new ast.BooleanAnd(d[0], d[4])},
    {"name": "FunctionCallArgument", "symbols": ["FunctionCallArgument", "_", {"literal":"or"}, "_", "FunctionCallArgument"], "postprocess": d => new ast.BooleanOr(d[0], d[4])},
    {"name": "BeatGroupLiteral", "symbols": [{"literal":"<"}, "_?", "MeasureGroup", "_?", {"literal":">"}], "postprocess": d => new ast.BeatGroupLiteral(d[2])},
    {"name": "MeasureGroup$macrocall$2", "symbols": ["Measure"]},
    {"name": "MeasureGroup$macrocall$3", "symbols": [{"literal":"|"}]},
    {"name": "MeasureGroup$macrocall$1$ebnf$1", "symbols": []},
    {"name": "MeasureGroup$macrocall$1$ebnf$1$subexpression$1", "symbols": ["_?", "MeasureGroup$macrocall$3", "_?", "MeasureGroup$macrocall$2"], "postprocess": d => d[3][0]},
    {"name": "MeasureGroup$macrocall$1$ebnf$1", "symbols": ["MeasureGroup$macrocall$1$ebnf$1", "MeasureGroup$macrocall$1$ebnf$1$subexpression$1"], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "MeasureGroup$macrocall$1", "symbols": ["MeasureGroup$macrocall$2", "MeasureGroup$macrocall$1$ebnf$1"], "postprocess": d => d[0].concat(d[1])},
    {"name": "MeasureGroup", "symbols": ["MeasureGroup$macrocall$1"], "postprocess": id},
    {"name": "Measure$macrocall$2", "symbols": ["BeatLiteral"]},
    {"name": "Measure$macrocall$1$ebnf$1", "symbols": []},
    {"name": "Measure$macrocall$1$ebnf$1$subexpression$1", "symbols": ["_", "Measure$macrocall$2"], "postprocess": d => d[1][0]},
    {"name": "Measure$macrocall$1$ebnf$1", "symbols": ["Measure$macrocall$1$ebnf$1", "Measure$macrocall$1$ebnf$1$subexpression$1"], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "Measure$macrocall$1", "symbols": ["Measure$macrocall$2", "Measure$macrocall$1$ebnf$1"], "postprocess": d => d[0].concat(d[1])},
    {"name": "Measure", "symbols": ["Measure$macrocall$1"], "postprocess": d => new ast.Measure(d[0])},
    {"name": "BeatLiteral", "symbols": ["BL_TimePart", {"literal":":"}, "BL_PitchPart", {"literal":":"}, "BL_OctavePart"], "postprocess": d => new ast.BeatLiteral({time: d[0], pitch: d[2], octave: d[4]})},
    {"name": "BeatLiteral", "symbols": [{"literal":":"}, "BL_PitchPart", {"literal":":"}, "BL_OctavePart"], "postprocess": d => new ast.BeatLiteral({pitch: d[1], octave: d[3]})},
    {"name": "BeatLiteral", "symbols": ["BL_TimePart", {"literal":":"}, "BL_PitchPart"], "postprocess": d => new ast.BeatLiteral({time: d[0], pitch: d[2]})},
    {"name": "BeatLiteral", "symbols": [{"literal":":"}, "BL_PitchPart"], "postprocess": d => new ast.BeatLiteral({pitch: d[1]})},
    {"name": "BeatLiteral", "symbols": ["DrumBeatLiteral"], "postprocess": id},
    {"name": "BL_TimePart", "symbols": ["NumericExpression"], "postprocess": d => ({time: d[0]})},
    {"name": "BL_TimePart", "symbols": ["BL_TP_Flag"], "postprocess": d => ({time: 'auto', flag: d[0]})},
    {"name": "BL_TimePart", "symbols": ["NumericExpression", "BL_TP_Flag"], "postprocess": d => ({time: d[0], flag: d[1]})},
    {"name": "BL_TP_Flag", "symbols": [{"literal":"s"}], "postprocess": d => 'STACCATO'},
    {"name": "BL_TP_Flag", "symbols": [{"literal":"a"}], "postprocess": d => 'ACCENTED'},
    {"name": "BL_PitchPart", "symbols": ["BL_PP_Degree"], "postprocess": id},
    {"name": "BL_PitchPart", "symbols": ["BL_PP_Chord"], "postprocess": id},
    {"name": "BL_PP_Degree", "symbols": ["NumberLiteral"], "postprocess": d => ({degree: d[0]})},
    {"name": "BL_PP_Degree", "symbols": ["BL_PP_Anchor"], "postprocess": d => ({anchor: d[0], degree: 1})},
    {"name": "BL_PP_Degree", "symbols": ["BL_PP_Anchor", "NumberLiteral"], "postprocess": d => ({anchor: d[0], degree: d[1]})},
    {"name": "BL_PP_Chord", "symbols": [{"literal":"c"}], "postprocess": d => ({chord: true, degree: 1})},
    {"name": "BL_PP_Chord", "symbols": ["BL_PP_Degree", {"literal":"c"}], "postprocess": d => ({chord: true, anchor: d[0].anchor, degree: d[0].degree})},
    {"name": "BL_PP_Chord", "symbols": [{"literal":"c"}, "BL_PP_Roll"], "postprocess": d => ({chord: true, roll: d[1], degree: 1})},
    {"name": "BL_PP_Chord", "symbols": ["BL_PP_Degree", {"literal":"c"}, "BL_PP_Roll"], "postprocess": d => ({chord: true, roll: d[2], anchor: d[0].anchor, degree: d[0].degree})},
    {"name": "BL_PP_Anchor", "symbols": [{"literal":"k"}], "postprocess": d => 'KEY'},
    {"name": "BL_PP_Anchor", "symbols": [{"literal":"n"}], "postprocess": d => 'NEXT'},
    {"name": "BL_PP_Anchor", "symbols": [{"literal":"s"}], "postprocess": d => 'STEP'},
    {"name": "BL_PP_Anchor", "symbols": [{"literal":"a"}], "postprocess": d => 'ARPEGGIATE'},
    {"name": "BL_PP_Roll", "symbols": [{"literal":"r"}], "postprocess": d => 'ROLL_UP'},
    {"name": "BL_PP_Roll", "symbols": [{"literal":"r"}, {"literal":"d"}], "postprocess": d => 'ROLL_DOWN'},
    {"name": "BL_OctavePart", "symbols": ["NumberLiteral"], "postprocess": id},
    {"name": "DrumBeatGroupLiteral", "symbols": ["StringLiteral", "_?", "BeatGroupLiteral"], "postprocess": d => new ast.DrumBeatGroupLiteral(d[0], d[2])},
    {"name": "DrumBeatGroupLiteral", "symbols": ["StringLiteral", "_?", "FunctionCallExpression"], "postprocess": d => new ast.DrumBeatGroupLiteral(d[0], d[2])},
    {"name": "DrumBeatLiteral", "symbols": ["NumberLiteral"], "postprocess": d => new ast.DrumBeatLiteral({time: d[0]})},
    {"name": "DrumBeatLiteral", "symbols": ["NumberLiteral", {"literal":"a"}], "postprocess": d => new ast.DrumBeatLiteral({time: d[0], accented: true})},
    {"name": "NumericExpression", "symbols": ["NE_addsub"], "postprocess": id},
    {"name": "NE_parens", "symbols": [{"literal":"("}, "NE_addsub", {"literal":")"}], "postprocess": d => d[1]},
    {"name": "NE_parens", "symbols": ["NumberLiteral"], "postprocess": id},
    {"name": "NE_muldiv", "symbols": ["NE_muldiv", {"literal":"*"}, "NE_parens"], "postprocess": d => (d[0] * d[2])},
    {"name": "NE_muldiv", "symbols": ["NE_muldiv", {"literal":"/"}, "NE_parens"], "postprocess": d => (d[0] / d[2])},
    {"name": "NE_muldiv", "symbols": ["NE_parens"], "postprocess": id},
    {"name": "NE_addsub", "symbols": ["NE_addsub", {"literal":"+"}, "NE_muldiv"], "postprocess": d => (d[0] + d[2])},
    {"name": "NE_addsub", "symbols": ["NE_addsub", {"literal":"-"}, "NE_muldiv"], "postprocess": d => (d[0] - d[2])},
    {"name": "NE_addsub", "symbols": ["NE_muldiv"], "postprocess": id},
    {"name": "Identifier", "symbols": [(lexer.has("identifier") ? {type: "identifier"} : identifier)], "postprocess": d => d[0].value},
    {"name": "NumberLiteral", "symbols": [(lexer.has("number") ? {type: "number"} : number)], "postprocess": d => Number(d[0].value)},
    {"name": "NumberLiteral", "symbols": [(lexer.has("beat_number") ? {type: "beat_number"} : beat_number)], "postprocess": d => Number(d[0].value)},
    {"name": "BooleanLiteral", "symbols": [(lexer.has("boolean") ? {type: "boolean"} : boolean)], "postprocess": d => Boolean(d[0].value)},
    {"name": "StringLiteral", "symbols": [(lexer.has("quoted_string") ? {type: "quoted_string"} : quoted_string)], "postprocess": d => d[0].value.slice(1, -1)},
    {"name": "_?$ebnf$1", "symbols": ["_"], "postprocess": id},
    {"name": "_?$ebnf$1", "symbols": [], "postprocess": function(d) {return null;}},
    {"name": "_?", "symbols": ["_?$ebnf$1"], "postprocess": () => null},
    {"name": "_", "symbols": [(lexer.has("ws") ? {type: "ws"} : ws)], "postprocess": () => null},
    {"name": "_", "symbols": [(lexer.has("beat_ws") ? {type: "beat_ws"} : beat_ws)], "postprocess": () => null},
    {"name": "_$ebnf$1", "symbols": [(lexer.has("ws") ? {type: "ws"} : ws)], "postprocess": id},
    {"name": "_$ebnf$1", "symbols": [], "postprocess": function(d) {return null;}},
    {"name": "_$ebnf$2$subexpression$1$ebnf$1", "symbols": [(lexer.has("ws") ? {type: "ws"} : ws)], "postprocess": id},
    {"name": "_$ebnf$2$subexpression$1$ebnf$1", "symbols": [], "postprocess": function(d) {return null;}},
    {"name": "_$ebnf$2$subexpression$1", "symbols": [(lexer.has("comment") ? {type: "comment"} : comment), "_$ebnf$2$subexpression$1$ebnf$1"]},
    {"name": "_$ebnf$2", "symbols": ["_$ebnf$2$subexpression$1"]},
    {"name": "_$ebnf$2$subexpression$2$ebnf$1", "symbols": [(lexer.has("ws") ? {type: "ws"} : ws)], "postprocess": id},
    {"name": "_$ebnf$2$subexpression$2$ebnf$1", "symbols": [], "postprocess": function(d) {return null;}},
    {"name": "_$ebnf$2$subexpression$2", "symbols": [(lexer.has("comment") ? {type: "comment"} : comment), "_$ebnf$2$subexpression$2$ebnf$1"]},
    {"name": "_$ebnf$2", "symbols": ["_$ebnf$2", "_$ebnf$2$subexpression$2"], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "_", "symbols": ["_$ebnf$1", "_$ebnf$2"], "postprocess": () => null},
    {"name": "_$ebnf$3", "symbols": [(lexer.has("beat_ws") ? {type: "beat_ws"} : beat_ws)], "postprocess": id},
    {"name": "_$ebnf$3", "symbols": [], "postprocess": function(d) {return null;}},
    {"name": "_$ebnf$4$subexpression$1$ebnf$1", "symbols": [(lexer.has("beat_ws") ? {type: "beat_ws"} : beat_ws)], "postprocess": id},
    {"name": "_$ebnf$4$subexpression$1$ebnf$1", "symbols": [], "postprocess": function(d) {return null;}},
    {"name": "_$ebnf$4$subexpression$1", "symbols": [(lexer.has("comment") ? {type: "comment"} : comment), "_$ebnf$4$subexpression$1$ebnf$1"]},
    {"name": "_$ebnf$4", "symbols": ["_$ebnf$4$subexpression$1"]},
    {"name": "_$ebnf$4$subexpression$2$ebnf$1", "symbols": [(lexer.has("beat_ws") ? {type: "beat_ws"} : beat_ws)], "postprocess": id},
    {"name": "_$ebnf$4$subexpression$2$ebnf$1", "symbols": [], "postprocess": function(d) {return null;}},
    {"name": "_$ebnf$4$subexpression$2", "symbols": [(lexer.has("comment") ? {type: "comment"} : comment), "_$ebnf$4$subexpression$2$ebnf$1"]},
    {"name": "_$ebnf$4", "symbols": ["_$ebnf$4", "_$ebnf$4$subexpression$2"], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "_", "symbols": ["_$ebnf$3", "_$ebnf$4"], "postprocess": () => null}
]
  , ParserStart: "main"
}
if (typeof module !== 'undefined'&& typeof module.exports !== 'undefined') {
   module.exports = grammar;
} else {
   window.grammar = grammar;
}
})();
